; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_sdmmc.o --depend=stm32nes\stm32f4xx_ll_sdmmc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_sdmmc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_sdmmc.c]
                          THUMB

                          AREA ||i.SDIO_ConfigData||, CODE, READONLY, ALIGN=1

                  SDIO_ConfigData PROC
;;;439      */
;;;440    HAL_StatusTypeDef SDIO_ConfigData(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* Data)
000000  680a              LDR      r2,[r1,#0]
;;;441    {
;;;442      uint32_t tmpreg = 0U;
;;;443      
;;;444      /* Check the parameters */
;;;445      assert_param(IS_SDIO_DATA_LENGTH(Data->DataLength));
;;;446      assert_param(IS_SDIO_BLOCK_SIZE(Data->DataBlockSize));
;;;447      assert_param(IS_SDIO_TRANSFER_DIR(Data->TransferDir));
;;;448      assert_param(IS_SDIO_TRANSFER_MODE(Data->TransferMode));
;;;449      assert_param(IS_SDIO_DPSM(Data->DPSM));
;;;450    
;;;451      /* Set the SDMMC Data TimeOut value */
;;;452      SDIOx->DTIMER = Data->DataTimeOut;
000002  6242              STR      r2,[r0,#0x24]
;;;453    
;;;454      /* Set the SDMMC DataLength value */
;;;455      SDIOx->DLEN = Data->DataLength;
000004  684a              LDR      r2,[r1,#4]
000006  6282              STR      r2,[r0,#0x28]
000008  e9d12302          LDRD     r2,r3,[r1,#8]
;;;456    
;;;457      /* Set the SDMMC data configuration parameters */
;;;458      tmpreg |= (uint32_t)(Data->DataBlockSize |\
00000c  431a              ORRS     r2,r2,r3
00000e  e9d13104          LDRD     r3,r1,[r1,#0x10]
000012  4319              ORRS     r1,r1,r3
000014  4311              ORRS     r1,r1,r2
;;;459                           Data->TransferDir   |\
;;;460                           Data->TransferMode  |\
;;;461                           Data->DPSM);
;;;462      
;;;463      /* Write to SDMMC DCTRL */
;;;464      MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
000016  6ac2              LDR      r2,[r0,#0x2c]
000018  f02202f7          BIC      r2,r2,#0xf7
00001c  4311              ORRS     r1,r1,r2
00001e  62c1              STR      r1,[r0,#0x2c]
;;;465    
;;;466      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;467    
;;;468    }
000022  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.SDIO_GetCommandResponse||, CODE, READONLY, ALIGN=1

                  SDIO_GetCommandResponse PROC
;;;401      */
;;;402    uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
000000  6900              LDR      r0,[r0,#0x10]
;;;403    {
;;;404      return (uint8_t)(SDIOx->RESPCMD);
000002  b2c0              UXTB     r0,r0
;;;405    }
000004  4770              BX       lr
;;;406    
                          ENDP


                          AREA ||i.SDIO_GetDataCounter||, CODE, READONLY, ALIGN=1

                  SDIO_GetDataCounter PROC
;;;474      */
;;;475    uint32_t SDIO_GetDataCounter(SDIO_TypeDef *SDIOx)
000000  6b00              LDR      r0,[r0,#0x30]
;;;476    {
;;;477      return (SDIOx->DCOUNT);
;;;478    }
000002  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.SDIO_GetFIFOCount||, CODE, READONLY, ALIGN=1

                  SDIO_GetFIFOCount PROC
;;;484      */
;;;485    uint32_t SDIO_GetFIFOCount(SDIO_TypeDef *SDIOx)
000000  f8d00080          LDR      r0,[r0,#0x80]
;;;486    {
;;;487      return (SDIOx->FIFO);
;;;488    }
000004  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.SDIO_GetPowerState||, CODE, READONLY, ALIGN=1

                  SDIO_GetPowerState PROC
;;;358      */
;;;359    uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
000000  6800              LDR      r0,[r0,#0]
;;;360    {
;;;361      return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
000002  f0000003          AND      r0,r0,#3
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.SDIO_GetResponse||, CODE, READONLY, ALIGN=1

                  SDIO_GetResponse PROC
;;;418      */
;;;419    uint32_t SDIO_GetResponse(SDIO_TypeDef *SDIOx, uint32_t Response)
000000  b081              SUB      sp,sp,#4
;;;420    {
;;;421      __IO uint32_t tmp = 0U;
;;;422    
;;;423      /* Check the parameters */
;;;424      assert_param(IS_SDIO_RESP(Response));
;;;425      
;;;426      /* Get the response */
;;;427      tmp = (uint32_t)&(SDIOx->RESP1) + Response;
000002  4408              ADD      r0,r0,r1
000004  3014              ADDS     r0,r0,#0x14
;;;428      
;;;429      return (*(__IO uint32_t *) tmp);
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
;;;430    }  
00000a  b001              ADD      sp,sp,#4
00000c  4770              BX       lr
;;;431    
                          ENDP


                          AREA ||i.SDIO_Init||, CODE, READONLY, ALIGN=1

                  SDIO_Init PROC
;;;231      */
;;;232    HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
000000  b430              PUSH     {r4,r5}
;;;233    {
;;;234      uint32_t tmpreg = 0U;
;;;235    
;;;236      /* Check the parameters */
;;;237      assert_param(IS_SDIO_ALL_INSTANCE(SDIOx));
;;;238      assert_param(IS_SDIO_CLOCK_EDGE(Init.ClockEdge)); 
;;;239      assert_param(IS_SDIO_CLOCK_BYPASS(Init.ClockBypass));
;;;240      assert_param(IS_SDIO_CLOCK_POWER_SAVE(Init.ClockPowerSave));
;;;241      assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
;;;242      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
;;;243      assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
;;;244      
;;;245      /* Set SDMMC configuration parameters */
;;;246      tmpreg |= (Init.ClockEdge           |\
000002  4311              ORRS     r1,r1,r2
000004  e9dd4502          LDRD     r4,r5,[sp,#8]         ;233
000008  ea430204          ORR      r2,r3,r4
00000c  4311              ORRS     r1,r1,r2
00000e  f8ddc010          LDR      r12,[sp,#0x10]
000012  4329              ORRS     r1,r1,r5
;;;247                 Init.ClockBypass         |\
;;;248                 Init.ClockPowerSave      |\
;;;249                 Init.BusWide             |\
;;;250                 Init.HardwareFlowControl |\
;;;251                 Init.ClockDiv
;;;252                 ); 
;;;253      
;;;254      /* Write to SDMMC CLKCR */
;;;255      MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
000014  6842              LDR      r2,[r0,#4]
000016  ea41010c          ORR      r1,r1,r12             ;246
00001a  f02202ff          BIC      r2,r2,#0xff
00001e  f42242fc          BIC      r2,r2,#0x7e00
000022  4311              ORRS     r1,r1,r2
000024  6041              STR      r1,[r0,#4]
;;;256    
;;;257      return HAL_OK;
;;;258    }
000026  bc30              POP      {r4,r5}
000028  2000              MOVS     r0,#0                 ;257
00002a  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.SDIO_PowerState_OFF||, CODE, READONLY, ALIGN=1

                  SDIO_PowerState_OFF PROC
;;;341      */
;;;342    HAL_StatusTypeDef SDIO_PowerState_OFF(SDIO_TypeDef *SDIOx)
000000  2100              MOVS     r1,#0
;;;343    {
;;;344      /* Set power state to OFF */
;;;345      SDIOx->POWER = 0x00000000U;
000002  6001              STR      r1,[r0,#0]
;;;346      
;;;347      return HAL_OK;
000004  4608              MOV      r0,r1
;;;348    }
000006  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.SDIO_PowerState_ON||, CODE, READONLY, ALIGN=1

                  SDIO_PowerState_ON PROC
;;;328      */
;;;329    HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
000000  2103              MOVS     r1,#3
;;;330    {  
;;;331      /* Set power state to ON */ 
;;;332      SDIOx->POWER = SDIO_POWER_PWRCTRL;
000002  6001              STR      r1,[r0,#0]
;;;333      
;;;334      return HAL_OK;
000004  2000              MOVS     r0,#0
;;;335    }
000006  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.SDIO_ReadFIFO||, CODE, READONLY, ALIGN=1

                  SDIO_ReadFIFO PROC
;;;284      */
;;;285    uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
000000  f8d00080          LDR      r0,[r0,#0x80]
;;;286    {
;;;287      /* Read data from Rx FIFO */ 
;;;288      return (SDIOx->FIFO);
;;;289    }
000004  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.SDIO_SendCommand||, CODE, READONLY, ALIGN=1

                  SDIO_SendCommand PROC
;;;371      */
;;;372    HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *Command)
000000  680a              LDR      r2,[r1,#0]
;;;373    {
;;;374      uint32_t tmpreg = 0U;
;;;375      
;;;376      /* Check the parameters */
;;;377      assert_param(IS_SDIO_CMD_INDEX(Command->CmdIndex));
;;;378      assert_param(IS_SDIO_RESPONSE(Command->Response));
;;;379      assert_param(IS_SDIO_WAIT(Command->WaitForInterrupt));
;;;380      assert_param(IS_SDIO_CPSM(Command->CPSM));
;;;381    
;;;382      /* Set the SDMMC Argument value */
;;;383      SDIOx->ARG = Command->Argument;
000002  6082              STR      r2,[r0,#8]
000004  e9d12301          LDRD     r2,r3,[r1,#4]
;;;384    
;;;385      /* Set SDMMC command parameters */
;;;386      tmpreg |= (uint32_t)(Command->CmdIndex         |\
000008  431a              ORRS     r2,r2,r3
00000a  e9d13103          LDRD     r3,r1,[r1,#0xc]
00000e  4319              ORRS     r1,r1,r3
000010  4311              ORRS     r1,r1,r2
;;;387                           Command->Response         |\
;;;388                           Command->WaitForInterrupt |\
;;;389                           Command->CPSM);
;;;390      
;;;391      /* Write to SDMMC CMD register */
;;;392      MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
000012  68c2              LDR      r2,[r0,#0xc]
000014  f36f020b          BFC      r2,#0,#12
000018  4311              ORRS     r1,r1,r2
00001a  60c1              STR      r1,[r0,#0xc]
;;;393      
;;;394      return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;395    }
00001e  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.SDIO_SetSDMMCReadWaitMode||, CODE, READONLY, ALIGN=1

                  SDIO_SetSDMMCReadWaitMode PROC
;;;498      */
;;;499    HAL_StatusTypeDef SDIO_SetSDMMCReadWaitMode(SDIO_TypeDef *SDIOx, uint32_t SDIO_ReadWaitMode)
000000  6ac2              LDR      r2,[r0,#0x2c]
;;;500    {
;;;501      /* Check the parameters */
;;;502      assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
;;;503    
;;;504      /* Set SDMMC read wait mode */
;;;505      MODIFY_REG(SDIOx->DCTRL, SDIO_DCTRL_RWMOD, SDIO_ReadWaitMode);
000002  f4226280          BIC      r2,r2,#0x400
000006  4311              ORRS     r1,r1,r2
000008  62c1              STR      r1,[r0,#0x2c]
;;;506      
;;;507      return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;508    }
00000c  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.SDIO_WriteFIFO||, CODE, READONLY, ALIGN=1

                  SDIO_WriteFIFO PROC
;;;296      */
;;;297    HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
000000  6809              LDR      r1,[r1,#0]
;;;298    { 
;;;299      /* Write data to FIFO */ 
;;;300      SDIOx->FIFO = *pWriteData;
000002  f8c01080          STR      r1,[r0,#0x80]
;;;301    
;;;302      return HAL_OK;
000006  2000              MOVS     r0,#0
;;;303    }
000008  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.SDMMC_CmdAppCommand||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdAppCommand PROC
;;;875      */
;;;876    uint32_t SDMMC_CmdAppCommand(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404177          MOV      r1,#0x477
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;877    {
;;;878      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;879      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;880      
;;;881      sdmmc_cmdinit.Argument         = (uint32_t)Argument;
;;;882      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
;;;883      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;884      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;885      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;886      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;887      
;;;888      /* Check for error conditions */
;;;889      /* If there is a HAL_ERROR, it is a MMC card, else
;;;890      it is a SD card: SD card 2.0 (voltage range mismatch)
;;;891         or SD card 1.x */
;;;892      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_CMD, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2137              MOVS     r1,#0x37
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;893    
;;;894      return errorstate;
;;;895    }
;;;896    
                          ENDP


                          AREA ||i.SDMMC_CmdAppOperCommand||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdAppOperCommand PROC
;;;902      */
;;;903    uint32_t SDMMC_CmdAppOperCommand(SDIO_TypeDef *SDIOx, uint32_t SdType)
000000  f4411180          ORR      r1,r1,#0x100000
;;;904    {
;;;905      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;906      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;907      
;;;908      sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
000004  f0414100          ORR      r1,r1,#0x80000000
;;;909      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
;;;910      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;911      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000008  2200              MOVS     r2,#0
00000a  6081              STR      r1,[r0,#8]
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  f2404369          MOV      r3,#0x469
000012  f36f010b          BFC      r1,#0,#12
000016  4319              ORRS     r1,r1,r3
000018  60c1              STR      r1,[r0,#0xc]
00001a  490e              LDR      r1,|L15.84|
00001c  f44f53fa          MOV      r3,#0x1f40
000020  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000022  fbb1f1f3          UDIV     r1,r1,r3
000026  f2413388          MOV      r3,#0x1388
00002a  4359              MULS     r1,r3,r1
                  |L15.44|
00002c  1e49              SUBS     r1,r1,#1
00002e  d203              BCS      |L15.56|
000030  f04f4200          MOV      r2,#0x80000000
                  |L15.52|
;;;912      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;913      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;914      
;;;915      /* Check for error conditions */
;;;916      errorstate = SDMMC_GetCmdResp3(SDIOx);
000034  4610              MOV      r0,r2
;;;917    
;;;918      return errorstate;
;;;919    }
000036  4770              BX       lr
                  |L15.56|
000038  6b43              LDR      r3,[r0,#0x34]
00003a  f0130f45          TST      r3,#0x45
00003e  d0f5              BEQ      |L15.44|
000040  6b41              LDR      r1,[r0,#0x34]
000042  f0110f04          TST      r1,#4
000046  bf07              ITTEE    EQ
000048  f24051ff          MOVEQ    r1,#0x5ff
00004c  6381              STREQ    r1,[r0,#0x38]
00004e  2204              MOVNE    r2,#4
000050  6382              STRNE    r2,[r0,#0x38]
000052  e7ef              B        |L15.52|
;;;920    
                          ENDP

                  |L15.84|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdBlockLength||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdBlockLength PROC
;;;533      */
;;;534    uint32_t SDMMC_CmdBlockLength(SDIO_TypeDef *SDIOx, uint32_t BlockSize)
000000  6081              STR      r1,[r0,#8]
000002  68c1              LDR      r1,[r0,#0xc]
000004  f36f010b          BFC      r1,#0,#12
000008  f441618a          ORR      r1,r1,#0x450
00000c  60c1              STR      r1,[r0,#0xc]
;;;535    {
;;;536      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;537      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;538      
;;;539      /* Set Block Size for Card */ 
;;;540      sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
;;;541      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
;;;542      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;543      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;544      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;545      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;546      
;;;547      /* Check for error conditions */
;;;548      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SET_BLOCKLEN, SDIO_CMDTIMEOUT);
00000e  f2413288          MOV      r2,#0x1388
000012  2110              MOVS     r1,#0x10
000014  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;549    
;;;550      return errorstate;
;;;551    }
;;;552    
                          ENDP


                          AREA ||i.SDMMC_CmdBusWidth||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdBusWidth PROC
;;;925      */
;;;926    uint32_t SDMMC_CmdBusWidth(SDIO_TypeDef *SDIOx, uint32_t BusWidth)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404146          MOV      r1,#0x446
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;927    {
;;;928      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;929      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;930      
;;;931      sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
;;;932      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
;;;933      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;934      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;935      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;936      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;937      
;;;938      /* Check for error conditions */
;;;939      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2106              MOVS     r1,#6
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;940    
;;;941      return errorstate;
;;;942    }
;;;943    
                          ENDP


                          AREA ||i.SDMMC_CmdErase||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdErase PROC
;;;749      */
;;;750    uint32_t SDMMC_CmdErase(SDIO_TypeDef *SDIOx)
000000  2100              MOVS     r1,#0
000002  6081              STR      r1,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f2404266          MOV      r2,#0x466
00000a  f36f010b          BFC      r1,#0,#12
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;751    {
;;;752      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;753      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;754      
;;;755      /* Set Block Size for Card */ 
;;;756      sdmmc_cmdinit.Argument         = 0U;
;;;757      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
;;;758      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;759      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;760      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;761      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;762      
;;;763      /* Check for error conditions */
;;;764      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE, SDIO_MAXERASETIMEOUT);
000012  f24f6218          MOV      r2,#0xf618
000016  2126              MOVS     r1,#0x26
000018  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;765    
;;;766      return errorstate;
;;;767    }
;;;768    
                          ENDP


                          AREA ||i.SDMMC_CmdEraseEndAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdEraseEndAdd PROC
;;;725      */
;;;726    uint32_t SDMMC_CmdEraseEndAdd(SDIO_TypeDef *SDIOx, uint32_t EndAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404164          MOV      r1,#0x464
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;727    {
;;;728      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;729      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;730      
;;;731      /* Set Block Size for Card */ 
;;;732      sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
;;;733      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
;;;734      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;735      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;736      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;737      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;738      
;;;739      /* Check for error conditions */
;;;740      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE_GRP_END, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2124              MOVS     r1,#0x24
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;741    
;;;742      return errorstate;
;;;743    }
;;;744    
                          ENDP


                          AREA ||i.SDMMC_CmdEraseStartAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdEraseStartAdd PROC
;;;701      */
;;;702    uint32_t SDMMC_CmdEraseStartAdd(SDIO_TypeDef *SDIOx, uint32_t StartAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404163          MOV      r1,#0x463
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;703    {
;;;704      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;705      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;706      
;;;707      /* Set Block Size for Card */ 
;;;708      sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
;;;709      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
;;;710      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;711      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;712      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;713      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;714      
;;;715      /* Check for error conditions */
;;;716      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE_GRP_START, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2123              MOVS     r1,#0x23
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;717    
;;;718      return errorstate;
;;;719    }
;;;720    
                          ENDP


                          AREA ||i.SDMMC_CmdGoIdleState||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdGoIdleState PROC
;;;822      */
;;;823    uint32_t SDMMC_CmdGoIdleState(SDIO_TypeDef *SDIOx)
000000  2300              MOVS     r3,#0
000002  6083              STR      r3,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f36f010b          BFC      r1,#0,#12
00000a  f4416180          ORR      r1,r1,#0x400
00000e  60c1              STR      r1,[r0,#0xc]
000010  490b              LDR      r1,|L21.64|
000012  f44f52fa          MOV      r2,#0x1f40
000016  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000018  fbb1f1f2          UDIV     r1,r1,r2
00001c  f2413288          MOV      r2,#0x1388
000020  4351              MULS     r1,r2,r1
                  |L21.34|
000022  1e49              SUBS     r1,r1,#1
000024  d202              BCS      |L21.44|
000026  f04f4300          MOV      r3,#0x80000000
00002a  e006              B        |L21.58|
                  |L21.44|
00002c  6b42              LDR      r2,[r0,#0x34]
00002e  f0120f80          TST      r2,#0x80
000032  d0f6              BEQ      |L21.34|
000034  f24051ff          MOV      r1,#0x5ff
000038  6381              STR      r1,[r0,#0x38]
                  |L21.58|
;;;824    {
;;;825      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;826      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;827      
;;;828      sdmmc_cmdinit.Argument         = 0U;
;;;829      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
;;;830      sdmmc_cmdinit.Response         = SDIO_RESPONSE_NO;
;;;831      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;832      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;833      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;834      
;;;835      /* Check for error conditions */
;;;836      errorstate = SDMMC_GetCmdError(SDIOx);
00003a  4618              MOV      r0,r3
;;;837    
;;;838      return errorstate;
;;;839    }
00003c  4770              BX       lr
;;;840    
                          ENDP

00003e  0000              DCW      0x0000
                  |L21.64|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdOpCondition||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdOpCondition PROC
;;;1092     */
;;;1093   uint32_t SDMMC_CmdOpCondition(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  2200              MOVS     r2,#0
000002  6081              STR      r1,[r0,#8]
000004  68c3              LDR      r3,[r0,#0xc]
000006  f2404141          MOV      r1,#0x441
00000a  f36f030b          BFC      r3,#0,#12
00000e  4319              ORRS     r1,r1,r3
000010  60c1              STR      r1,[r0,#0xc]
000012  490e              LDR      r1,|L22.76|
000014  f44f53fa          MOV      r3,#0x1f40
000018  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00001a  fbb1f1f3          UDIV     r1,r1,r3
00001e  f2413388          MOV      r3,#0x1388
000022  4359              MULS     r1,r3,r1
                  |L22.36|
000024  1e49              SUBS     r1,r1,#1
000026  d203              BCS      |L22.48|
000028  f04f4200          MOV      r2,#0x80000000
                  |L22.44|
;;;1094   {
;;;1095     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1096     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1097     
;;;1098     sdmmc_cmdinit.Argument         = Argument;
;;;1099     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
;;;1100     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;1101     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1102     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1103     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1104     
;;;1105     /* Check for error conditions */
;;;1106     errorstate = SDMMC_GetCmdResp3(SDIOx);
00002c  4610              MOV      r0,r2
;;;1107   
;;;1108     return errorstate;
;;;1109   }
00002e  4770              BX       lr
                  |L22.48|
000030  6b43              LDR      r3,[r0,#0x34]
000032  f0130f45          TST      r3,#0x45
000036  d0f5              BEQ      |L22.36|
000038  6b41              LDR      r1,[r0,#0x34]
00003a  f0110f04          TST      r1,#4
00003e  bf07              ITTEE    EQ
000040  f24051ff          MOVEQ    r1,#0x5ff
000044  6381              STREQ    r1,[r0,#0x38]
000046  2204              MOVNE    r2,#4
000048  6382              STRNE    r2,[r0,#0x38]
00004a  e7ef              B        |L22.44|
;;;1110   
                          ENDP

                  |L22.76|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdOperCond||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdOperCond PROC
;;;845      */
;;;846    uint32_t SDMMC_CmdOperCond(SDIO_TypeDef *SDIOx)
000000  f44f71d5          MOV      r1,#0x1aa
;;;847    {
;;;848      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;849      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;850      
;;;851      /* Send CMD8 to verify SD card interface operating condition */
;;;852      /* Argument: - [31:12]: Reserved (shall be set to '0')
;;;853      - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
;;;854      - [7:0]: Check Pattern (recommended 0xAA) */
;;;855      /* CMD Response: R7 */
;;;856      sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
;;;857      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
;;;858      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000004  f04f0c40          MOV      r12,#0x40
;;;859      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000008  2200              MOVS     r2,#0
00000a  6081              STR      r1,[r0,#8]
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  f36f010b          BFC      r1,#0,#12
000012  f4416189          ORR      r1,r1,#0x448
000016  60c1              STR      r1,[r0,#0xc]
000018  4910              LDR      r1,|L23.92|
00001a  f44f53fa          MOV      r3,#0x1f40
00001e  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000020  fbb1f1f3          UDIV     r1,r1,r3
000024  f2413388          MOV      r3,#0x1388
000028  4359              MULS     r1,r3,r1
                  |L23.42|
00002a  1e49              SUBS     r1,r1,#1
00002c  d202              BCS      |L23.52|
00002e  f04f4200          MOV      r2,#0x80000000
000032  e011              B        |L23.88|
                  |L23.52|
000034  6b43              LDR      r3,[r0,#0x34]
000036  f0130f45          TST      r3,#0x45
00003a  d0f6              BEQ      |L23.42|
00003c  6b41              LDR      r1,[r0,#0x34]
00003e  f0110f04          TST      r1,#4
000042  bf1c              ITT      NE
000044  f8c0c038          STRNE    r12,[r0,#0x38]
000048  2204              MOVNE    r2,#4
00004a  d105              BNE      |L23.88|
00004c  6b41              LDR      r1,[r0,#0x34]
00004e  f0110f40          TST      r1,#0x40
000052  bf18              IT       NE
000054  f8c0c038          STRNE    r12,[r0,#0x38]
                  |L23.88|
;;;860      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;861      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;862      
;;;863      /* Check for error conditions */
;;;864      errorstate = SDMMC_GetCmdResp7(SDIOx);
000058  4610              MOV      r0,r2
;;;865    
;;;866      return errorstate;
;;;867    }
00005a  4770              BX       lr
;;;868    
                          ENDP

                  |L23.92|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdReadMultiBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdReadMultiBlock PROC
;;;581      */
;;;582    uint32_t SDMMC_CmdReadMultiBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404152          MOV      r1,#0x452
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;583    {
;;;584      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;585      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;586      
;;;587      /* Set Block Size for Card */ 
;;;588      sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
;;;589      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
;;;590      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;591      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;592      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;593      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;594      
;;;595      /* Check for error conditions */
;;;596      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_MULT_BLOCK, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2112              MOVS     r1,#0x12
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;597    
;;;598      return errorstate;
;;;599    }
;;;600    
                          ENDP


                          AREA ||i.SDMMC_CmdReadSingleBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdReadSingleBlock PROC
;;;557      */
;;;558    uint32_t SDMMC_CmdReadSingleBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404151          MOV      r1,#0x451
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;559    {
;;;560      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;561      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;562      
;;;563      /* Set Block Size for Card */ 
;;;564      sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
;;;565      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
;;;566      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;567      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;568      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;569      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;570      
;;;571      /* Check for error conditions */
;;;572      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2111              MOVS     r1,#0x11
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;573    
;;;574      return errorstate;
;;;575    }
;;;576    
                          ENDP


                          AREA ||i.SDMMC_CmdSDEraseEndAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSDEraseEndAdd PROC
;;;677      */
;;;678    uint32_t SDMMC_CmdSDEraseEndAdd(SDIO_TypeDef *SDIOx, uint32_t EndAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404161          MOV      r1,#0x461
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;679    {
;;;680      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;681      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;682      
;;;683      /* Set Block Size for Card */ 
;;;684      sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
;;;685      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
;;;686      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;687      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;688      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;689      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;690      
;;;691      /* Check for error conditions */
;;;692      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_ERASE_GRP_END, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2121              MOVS     r1,#0x21
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;693    
;;;694      return errorstate;
;;;695    }
;;;696    
                          ENDP


                          AREA ||i.SDMMC_CmdSDEraseStartAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSDEraseStartAdd PROC
;;;653      */
;;;654    uint32_t SDMMC_CmdSDEraseStartAdd(SDIO_TypeDef *SDIOx, uint32_t StartAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c1              LDR      r1,[r0,#0xc]
000004  f36f010b          BFC      r1,#0,#12
000008  f441618c          ORR      r1,r1,#0x460
00000c  60c1              STR      r1,[r0,#0xc]
;;;655    {
;;;656      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;657      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;658      
;;;659      /* Set Block Size for Card */ 
;;;660      sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
;;;661      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
;;;662      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;663      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;664      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;665      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;666      
;;;667      /* Check for error conditions */
;;;668      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_ERASE_GRP_START, SDIO_CMDTIMEOUT);
00000e  f2413288          MOV      r2,#0x1388
000012  2120              MOVS     r1,#0x20
000014  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;669    
;;;670      return errorstate;
;;;671    }
;;;672    
                          ENDP


                          AREA ||i.SDMMC_CmdSelDesel||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSelDesel PROC
;;;798      */
;;;799    uint32_t SDMMC_CmdSelDesel(SDIO_TypeDef *SDIOx, uint64_t Addr)
000000  6082              STR      r2,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404147          MOV      r1,#0x447
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;800    {
;;;801      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;802      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;803      
;;;804      /* Send CMD7 SDMMC_SEL_DESEL_CARD */
;;;805      sdmmc_cmdinit.Argument         = (uint32_t)Addr;
;;;806      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
;;;807      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;808      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;809      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;810      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;811      
;;;812      /* Check for error conditions */
;;;813      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEL_DESEL_CARD, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2107              MOVS     r1,#7
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;814    
;;;815      return errorstate;
;;;816    }
;;;817    
                          ENDP


                          AREA ||i.SDMMC_CmdSendCID||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdSendCID PROC
;;;972      */
;;;973    uint32_t SDMMC_CmdSendCID(SDIO_TypeDef *SDIOx)
000000  2200              MOVS     r2,#0
000002  6082              STR      r2,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f24043c2          MOV      r3,#0x4c2
00000a  f36f010b          BFC      r1,#0,#12
00000e  4319              ORRS     r1,r1,r3
000010  60c1              STR      r1,[r0,#0xc]
000012  4912              LDR      r1,|L29.92|
000014  f44f53fa          MOV      r3,#0x1f40
000018  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00001a  fbb1f1f3          UDIV     r1,r1,r3
00001e  f2413388          MOV      r3,#0x1388
000022  4359              MULS     r1,r3,r1
                  |L29.36|
000024  1e49              SUBS     r1,r1,#1
000026  d202              BCS      |L29.46|
000028  f04f4200          MOV      r2,#0x80000000
00002c  e00a              B        |L29.68|
                  |L29.46|
00002e  6b43              LDR      r3,[r0,#0x34]
000030  f0130f45          TST      r3,#0x45
000034  d0f6              BEQ      |L29.36|
000036  6b41              LDR      r1,[r0,#0x34]
000038  f0110f04          TST      r1,#4
00003c  bf18              IT       NE
00003e  2204              MOVNE    r2,#4
000040  d002              BEQ      |L29.72|
                  |L29.66|
000042  6382              STR      r2,[r0,#0x38]
                  |L29.68|
;;;974    {
;;;975      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;976      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;977      
;;;978      /* Send CMD2 ALL_SEND_CID */
;;;979      sdmmc_cmdinit.Argument         = 0U;
;;;980      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
;;;981      sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
;;;982      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;983      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;984      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;985      
;;;986      /* Check for error conditions */
;;;987      errorstate = SDMMC_GetCmdResp2(SDIOx);
000044  4610              MOV      r0,r2
;;;988    
;;;989      return errorstate;
;;;990    }
000046  4770              BX       lr
                  |L29.72|
000048  6b41              LDR      r1,[r0,#0x34]
00004a  f0110f01          TST      r1,#1
00004e  bf12              ITEE     NE
000050  2201              MOVNE    r2,#1
000052  f24051ff          MOVEQ    r1,#0x5ff
000056  6381              STREQ    r1,[r0,#0x38]
000058  d1f3              BNE      |L29.66|
00005a  e7f3              B        |L29.68|
;;;991    
                          ENDP

                  |L29.92|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdSendCSD||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdSendCSD PROC
;;;996      */
;;;997    uint32_t SDMMC_CmdSendCSD(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  2200              MOVS     r2,#0
000002  6081              STR      r1,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f24043c9          MOV      r3,#0x4c9
00000a  f36f010b          BFC      r1,#0,#12
00000e  4319              ORRS     r1,r1,r3
000010  60c1              STR      r1,[r0,#0xc]
000012  4912              LDR      r1,|L30.92|
000014  f44f53fa          MOV      r3,#0x1f40
000018  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00001a  fbb1f1f3          UDIV     r1,r1,r3
00001e  f2413388          MOV      r3,#0x1388
000022  4359              MULS     r1,r3,r1
                  |L30.36|
000024  1e49              SUBS     r1,r1,#1
000026  d202              BCS      |L30.46|
000028  f04f4200          MOV      r2,#0x80000000
00002c  e00a              B        |L30.68|
                  |L30.46|
00002e  6b43              LDR      r3,[r0,#0x34]
000030  f0130f45          TST      r3,#0x45
000034  d0f6              BEQ      |L30.36|
000036  6b41              LDR      r1,[r0,#0x34]
000038  f0110f04          TST      r1,#4
00003c  bf18              IT       NE
00003e  2204              MOVNE    r2,#4
000040  d002              BEQ      |L30.72|
                  |L30.66|
000042  6382              STR      r2,[r0,#0x38]
                  |L30.68|
;;;998    {
;;;999      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1000     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1001     
;;;1002     /* Send CMD9 SEND_CSD */
;;;1003     sdmmc_cmdinit.Argument         = (uint32_t)Argument;
;;;1004     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
;;;1005     sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
;;;1006     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1007     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1008     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1009     
;;;1010     /* Check for error conditions */
;;;1011     errorstate = SDMMC_GetCmdResp2(SDIOx);
000044  4610              MOV      r0,r2
;;;1012   
;;;1013     return errorstate;
;;;1014   }
000046  4770              BX       lr
                  |L30.72|
000048  6b41              LDR      r1,[r0,#0x34]
00004a  f0110f01          TST      r1,#1
00004e  bf12              ITEE     NE
000050  2201              MOVNE    r2,#1
000052  f24051ff          MOVEQ    r1,#0x5ff
000056  6381              STREQ    r1,[r0,#0x38]
000058  d1f3              BNE      |L30.66|
00005a  e7f3              B        |L30.68|
;;;1015   
                          ENDP

                  |L30.92|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdSendSCR||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendSCR PROC
;;;948      */
;;;949    uint32_t SDMMC_CmdSendSCR(SDIO_TypeDef *SDIOx)
000000  2100              MOVS     r1,#0
000002  6081              STR      r1,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f2404273          MOV      r2,#0x473
00000a  f36f010b          BFC      r1,#0,#12
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;950    {
;;;951      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;952      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;953      
;;;954      /* Send CMD51 SD_APP_SEND_SCR */
;;;955      sdmmc_cmdinit.Argument         = 0U;
;;;956      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
;;;957      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;958      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;959      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;960      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;961      
;;;962      /* Check for error conditions */
;;;963      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_SEND_SCR, SDIO_CMDTIMEOUT);
000012  f2413288          MOV      r2,#0x1388
000016  2133              MOVS     r1,#0x33
000018  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;964    
;;;965      return errorstate;
;;;966    }
;;;967    
                          ENDP


                          AREA ||i.SDMMC_CmdSendStatus||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendStatus PROC
;;;1044     */
;;;1045   uint32_t SDMMC_CmdSendStatus(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f240414d          MOV      r1,#0x44d
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;1046   {
;;;1047     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1048     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1049     
;;;1050     sdmmc_cmdinit.Argument         = (uint32_t)Argument;
;;;1051     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
;;;1052     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;1053     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1054     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1055     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1056     
;;;1057     /* Check for error conditions */
;;;1058     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEND_STATUS, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  210d              MOVS     r1,#0xd
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;1059   
;;;1060     return errorstate;
;;;1061   }
;;;1062   
                          ENDP


                          AREA ||i.SDMMC_CmdSetRelAdd||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdSetRelAdd PROC
;;;1020     */
;;;1021   uint32_t SDMMC_CmdSetRelAdd(SDIO_TypeDef *SDIOx, uint16_t *pRCA)
000000  b438              PUSH     {r3-r5}
;;;1022   {
;;;1023     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1024     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1025     
;;;1026     /* Send CMD3 SD_CMD_SET_REL_ADDR */
;;;1027     sdmmc_cmdinit.Argument         = 0U;
000002  2400              MOVS     r4,#0
000004  6084              STR      r4,[r0,#8]
000006  68c3              LDR      r3,[r0,#0xc]
000008  f2404243          MOV      r2,#0x443
00000c  f36f030b          BFC      r3,#0,#12
000010  431a              ORRS     r2,r2,r3
000012  60c2              STR      r2,[r0,#0xc]
000014  4a21              LDR      r2,|L33.156|
000016  f44f53fa          MOV      r3,#0x1f40
;;;1028     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
;;;1029     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;1030     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1031     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1032     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1033     
;;;1034     /* Check for error conditions */
;;;1035     errorstate = SDMMC_GetCmdResp6(SDIOx, SDMMC_CMD_SET_REL_ADDR, pRCA);
00001a  2503              MOVS     r5,#3
00001c  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00001e  fbb2f2f3          UDIV     r2,r2,r3
000022  f2413388          MOV      r3,#0x1388
000026  4353              MULS     r3,r2,r3
                  |L33.40|
000028  1e5b              SUBS     r3,r3,#1
00002a  d202              BCS      |L33.50|
00002c  f04f4200          MOV      r2,#0x80000000
000030  e029              B        |L33.134|
                  |L33.50|
000032  6b42              LDR      r2,[r0,#0x34]
000034  f0120f45          TST      r2,#0x45
000038  d0f6              BEQ      |L33.40|
00003a  6b42              LDR      r2,[r0,#0x34]
00003c  f0120f04          TST      r2,#4
000040  bf1c              ITT      NE
000042  2204              MOVNE    r2,#4
000044  6382              STRNE    r2,[r0,#0x38]
000046  d11e              BNE      |L33.134|
000048  6b42              LDR      r2,[r0,#0x34]
00004a  f0120f01          TST      r2,#1
00004e  f04f0201          MOV      r2,#1
000052  bf18              IT       NE
000054  6382              STRNE    r2,[r0,#0x38]
000056  d116              BNE      |L33.134|
000058  6903              LDR      r3,[r0,#0x10]
00005a  b2db              UXTB     r3,r3
00005c  42ab              CMP      r3,r5
00005e  d112              BNE      |L33.134|
000060  f24052ff          MOV      r2,#0x5ff
000064  6382              STR      r2,[r0,#0x38]
000066  3014              ADDS     r0,r0,#0x14
000068  9000              STR      r0,[sp,#0]
00006a  6800              LDR      r0,[r0,#0]
00006c  4622              MOV      r2,r4
00006e  f4104f60          TST      r0,#0xe000
000072  bf04              ITT      EQ
000074  0c00              LSREQ    r0,r0,#16
000076  8008              STRHEQ   r0,[r1,#0]
000078  d005              BEQ      |L33.134|
00007a  f4104f80          TST      r0,#0x4000
00007e  bf18              IT       NE
000080  f44f5200          MOVNE    r2,#0x2000
000084  d002              BEQ      |L33.140|
                  |L33.134|
;;;1036   
;;;1037     return errorstate;
;;;1038   }
000086  bc38              POP      {r3-r5}
000088  4610              MOV      r0,r2                 ;1035
00008a  4770              BX       lr
                  |L33.140|
00008c  f4104f00          TST      r0,#0x8000
000090  bf14              ITE      NE
000092  f44f5280          MOVNE    r2,#0x1000
000096  f44f3280          MOVEQ    r2,#0x10000
00009a  e7f4              B        |L33.134|
;;;1039   
                          ENDP

                  |L33.156|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_CmdStatusRegister||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdStatusRegister PROC
;;;1067     */
;;;1068   uint32_t SDMMC_CmdStatusRegister(SDIO_TypeDef *SDIOx)
000000  2100              MOVS     r1,#0
000002  6081              STR      r1,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f240424d          MOV      r2,#0x44d
00000a  f36f010b          BFC      r1,#0,#12
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;1069   {
;;;1070     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1071     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1072     
;;;1073     sdmmc_cmdinit.Argument         = 0U;
;;;1074     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
;;;1075     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;1076     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1077     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1078     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1079     
;;;1080     /* Check for error conditions */
;;;1081     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_STATUS, SDIO_CMDTIMEOUT);
000012  f2413288          MOV      r2,#0x1388
000016  210d              MOVS     r1,#0xd
000018  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;1082   
;;;1083     return errorstate;
;;;1084   }
;;;1085   
                          ENDP


                          AREA ||i.SDMMC_CmdStopTransfer||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdStopTransfer PROC
;;;773      */
;;;774    uint32_t SDMMC_CmdStopTransfer(SDIO_TypeDef *SDIOx)
000000  2100              MOVS     r1,#0
000002  6081              STR      r1,[r0,#8]
000004  68c1              LDR      r1,[r0,#0xc]
000006  f240424c          MOV      r2,#0x44c
00000a  f36f010b          BFC      r1,#0,#12
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;775    {
;;;776      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;777      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;778      
;;;779      /* Send CMD12 STOP_TRANSMISSION  */
;;;780      sdmmc_cmdinit.Argument         = 0U;
;;;781      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
;;;782      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;783      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;784      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;785      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;786      
;;;787      /* Check for error conditions */
;;;788      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_STOP_TRANSMISSION, 100000000U);
000012  4a02              LDR      r2,|L35.28|
000014  210c              MOVS     r1,#0xc
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;789    
;;;790      return errorstate;
;;;791    }
;;;792    
                          ENDP

00001a  0000              DCW      0x0000
                  |L35.28|
                          DCD      0x05f5e100

                          AREA ||i.SDMMC_CmdSwitch||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSwitch PROC
;;;1116     */
;;;1117   uint32_t SDMMC_CmdSwitch(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404146          MOV      r1,#0x446
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;1118   {
;;;1119     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1120     uint32_t errorstate = SDMMC_ERROR_NONE;
;;;1121     
;;;1122     sdmmc_cmdinit.Argument         = Argument;
;;;1123     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
;;;1124     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;1125     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;1126     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;1127     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;1128     
;;;1129     /* Check for error conditions */
;;;1130     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_HS_SWITCH, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2106              MOVS     r1,#6
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;1131   
;;;1132     return errorstate;
;;;1133   }
;;;1134   
                          ENDP


                          AREA ||i.SDMMC_CmdWriteMultiBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdWriteMultiBlock PROC
;;;629      */
;;;630    uint32_t SDMMC_CmdWriteMultiBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c2              LDR      r2,[r0,#0xc]
000004  f2404159          MOV      r1,#0x459
000008  f36f020b          BFC      r2,#0,#12
00000c  4311              ORRS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;631    {
;;;632      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;633      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;634      
;;;635      /* Set Block Size for Card */ 
;;;636      sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
;;;637      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
;;;638      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;639      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;640      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;641      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;642      
;;;643      /* Check for error conditions */
;;;644      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_MULT_BLOCK, SDIO_CMDTIMEOUT);
000010  f2413288          MOV      r2,#0x1388
000014  2119              MOVS     r1,#0x19
000016  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;645    
;;;646      return errorstate;
;;;647    }
;;;648    
                          ENDP


                          AREA ||i.SDMMC_CmdWriteSingleBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdWriteSingleBlock PROC
;;;605      */
;;;606    uint32_t SDMMC_CmdWriteSingleBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
000000  6081              STR      r1,[r0,#8]
000002  68c1              LDR      r1,[r0,#0xc]
000004  f36f010b          BFC      r1,#0,#12
000008  f441618b          ORR      r1,r1,#0x458
00000c  60c1              STR      r1,[r0,#0xc]
;;;607    {
;;;608      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;609      uint32_t errorstate = SDMMC_ERROR_NONE;
;;;610      
;;;611      /* Set Block Size for Card */ 
;;;612      sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
;;;613      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
;;;614      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
;;;615      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
;;;616      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
;;;617      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
;;;618      
;;;619      /* Check for error conditions */
;;;620      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
00000e  f2413288          MOV      r2,#0x1388
000012  2118              MOVS     r1,#0x18
000014  f7ffbffe          B.W      SDMMC_GetCmdResp1
;;;621    
;;;622      return errorstate;
;;;623    }
;;;624    
                          ENDP


                          AREA ||i.SDMMC_GetCmdResp1||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp1 PROC
;;;1175     */
;;;1176   static uint32_t SDMMC_GetCmdResp1(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint32_t Timeout)
000000  4b5a              LDR      r3,|L39.364|
;;;1177   {
;;;1178     uint32_t response_r1;
;;;1179     
;;;1180     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1181     The Timeout is expressed in ms */
;;;1182     register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
000002  f44f5cfa          MOV      r12,#0x1f40
000006  b081              SUB      sp,sp,#4              ;1177
000008  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
00000a  fbb3f3fc          UDIV     r3,r3,r12
00000e  435a              MULS     r2,r3,r2
                  |L39.16|
000010  1e52              SUBS     r2,r2,#1
;;;1183     
;;;1184     do
;;;1185     {
;;;1186       if (count-- == 0U)
000012  d203              BCS      |L39.28|
;;;1187       {
;;;1188         return SDMMC_ERROR_TIMEOUT;
000014  f04f4000          MOV      r0,#0x80000000
;;;1189       }
;;;1190       
;;;1191     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1192     
;;;1193     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1194     {
;;;1195       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
;;;1196       
;;;1197       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1198     }
;;;1199     else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
;;;1200     {
;;;1201       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
;;;1202       
;;;1203       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1204     }
;;;1205     
;;;1206     /* Check response received is of desired command */
;;;1207     if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
;;;1208     {
;;;1209       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1210     }
;;;1211     
;;;1212     /* Clear all the static flags */
;;;1213     __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1214     
;;;1215     /* We have received response, retrieve it for analysis  */
;;;1216     response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
;;;1217     
;;;1218     if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
;;;1219     {
;;;1220       return SDMMC_ERROR_NONE;
;;;1221     }
;;;1222     else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
;;;1223     {
;;;1224       return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
;;;1225     }
;;;1226     else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
;;;1227     {
;;;1228       return SDMMC_ERROR_ADDR_MISALIGNED;
;;;1229     }
;;;1230     else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
;;;1231     {
;;;1232       return SDMMC_ERROR_BLOCK_LEN_ERR;
;;;1233     }
;;;1234     else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
;;;1235     {
;;;1236       return SDMMC_ERROR_ERASE_SEQ_ERR;
;;;1237     }
;;;1238     else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
;;;1239     {
;;;1240       return SDMMC_ERROR_BAD_ERASE_PARAM;
;;;1241     }
;;;1242     else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
;;;1243     {
;;;1244       return SDMMC_ERROR_WRITE_PROT_VIOLATION;
;;;1245     }
;;;1246     else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
;;;1247     {
;;;1248       return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
;;;1249     }
;;;1250     else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
;;;1251     {
;;;1252       return SDMMC_ERROR_COM_CRC_FAILED;
;;;1253     }
;;;1254     else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
;;;1255     {
;;;1256       return SDMMC_ERROR_ILLEGAL_CMD;
;;;1257     }
;;;1258     else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
;;;1259     {
;;;1260       return SDMMC_ERROR_CARD_ECC_FAILED;
;;;1261     }
;;;1262     else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
;;;1263     {
;;;1264       return SDMMC_ERROR_CC_ERR;
;;;1265     }
;;;1266     else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
;;;1267     {
;;;1268       return SDMMC_ERROR_STREAM_READ_UNDERRUN;
;;;1269     }
;;;1270     else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
;;;1271     {
;;;1272       return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
;;;1273     }
;;;1274     else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
;;;1275     {
;;;1276       return SDMMC_ERROR_CID_CSD_OVERWRITE;
;;;1277     }
;;;1278     else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
;;;1279     {
;;;1280       return SDMMC_ERROR_WP_ERASE_SKIP;
;;;1281     }
;;;1282     else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
;;;1283     {
;;;1284       return SDMMC_ERROR_CARD_ECC_DISABLED;
;;;1285     }
;;;1286     else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
;;;1287     {
;;;1288       return SDMMC_ERROR_ERASE_RESET;
;;;1289     }
;;;1290     else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
;;;1291     {
;;;1292       return SDMMC_ERROR_AKE_SEQ_ERR;
;;;1293     }
;;;1294     else
;;;1295     {
;;;1296       return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
;;;1297     }
;;;1298   }
000018  b001              ADD      sp,sp,#4
00001a  4770              BX       lr
                  |L39.28|
00001c  6b43              LDR      r3,[r0,#0x34]         ;1191
00001e  f0130f45          TST      r3,#0x45              ;1191
000022  d0f5              BEQ      |L39.16|
000024  6b42              LDR      r2,[r0,#0x34]         ;1193
000026  f0120f04          TST      r2,#4                 ;1193
00002a  d004              BEQ      |L39.54|
00002c  2104              MOVS     r1,#4                 ;1195
00002e  6381              STR      r1,[r0,#0x38]         ;1195
000030  4608              MOV      r0,r1                 ;1197
000032  b001              ADD      sp,sp,#4
000034  4770              BX       lr
                  |L39.54|
000036  6b42              LDR      r2,[r0,#0x34]         ;1199
000038  f0120f01          TST      r2,#1                 ;1199
00003c  d004              BEQ      |L39.72|
00003e  2101              MOVS     r1,#1                 ;1201
000040  6381              STR      r1,[r0,#0x38]         ;1201
000042  4608              MOV      r0,r1                 ;1203
000044  b001              ADD      sp,sp,#4
000046  4770              BX       lr
                  |L39.72|
000048  6902              LDR      r2,[r0,#0x10]
00004a  b2d2              UXTB     r2,r2
00004c  428a              CMP      r2,r1                 ;1207
00004e  bf1e              ITTT     NE                    ;1209
000050  2001              MOVNE    r0,#1                 ;1209
000052  b001              ADDNE    sp,sp,#4
000054  4770              BXNE     lr
000056  f24051ff          MOV      r1,#0x5ff             ;1213
00005a  6381              STR      r1,[r0,#0x38]         ;1213
00005c  3014              ADDS     r0,r0,#0x14           ;1213
00005e  9000              STR      r0,[sp,#0]            ;1213
000060  6800              LDR      r0,[r0,#0]            ;1213
000062  4943              LDR      r1,|L39.368|
000064  4208              TST      r0,r1                 ;1218
000066  bf02              ITTT     EQ                    ;1220
000068  2000              MOVEQ    r0,#0                 ;1220
00006a  b001              ADDEQ    sp,sp,#4
00006c  4770              BXEQ     lr
00006e  f0104f00          TST      r0,#0x80000000        ;1222
000072  bf1e              ITTT     NE                    ;1224
000074  f04f7000          MOVNE    r0,#0x2000000         ;1224
000078  b001              ADDNE    sp,sp,#4
00007a  4770              BXNE     lr
00007c  f0104f80          TST      r0,#0x40000000        ;1226
000080  bf1e              ITTT     NE                    ;1228
000082  2040              MOVNE    r0,#0x40              ;1228
000084  b001              ADDNE    sp,sp,#4
000086  4770              BXNE     lr
000088  f0105f00          TST      r0,#0x20000000        ;1230
00008c  bf1e              ITTT     NE                    ;1232
00008e  2080              MOVNE    r0,#0x80              ;1232
000090  b001              ADDNE    sp,sp,#4
000092  4770              BXNE     lr
000094  f0105f80          TST      r0,#0x10000000        ;1234
000098  bf1e              ITTT     NE                    ;1236
00009a  f44f7080          MOVNE    r0,#0x100             ;1236
00009e  b001              ADDNE    sp,sp,#4
0000a0  4770              BXNE     lr
0000a2  f0106f00          TST      r0,#0x8000000         ;1238
0000a6  bf1e              ITTT     NE                    ;1240
0000a8  f44f7000          MOVNE    r0,#0x200             ;1240
0000ac  b001              ADDNE    sp,sp,#4
0000ae  4770              BXNE     lr
0000b0  f0106f80          TST      r0,#0x4000000         ;1242
0000b4  bf1e              ITTT     NE                    ;1244
0000b6  f44f6080          MOVNE    r0,#0x400             ;1244
0000ba  b001              ADDNE    sp,sp,#4
0000bc  4770              BXNE     lr
0000be  f0107f80          TST      r0,#0x1000000         ;1246
0000c2  bf1e              ITTT     NE                    ;1248
0000c4  f44f6000          MOVNE    r0,#0x800             ;1248
0000c8  b001              ADDNE    sp,sp,#4
0000ca  4770              BXNE     lr
0000cc  f4100f00          TST      r0,#0x800000          ;1250
0000d0  bf1e              ITTT     NE                    ;1252
0000d2  f44f5080          MOVNE    r0,#0x1000            ;1252
0000d6  b001              ADDNE    sp,sp,#4
0000d8  4770              BXNE     lr
0000da  f4100f80          TST      r0,#0x400000          ;1254
0000de  bf1e              ITTT     NE                    ;1256
0000e0  f44f5000          MOVNE    r0,#0x2000            ;1256
0000e4  b001              ADDNE    sp,sp,#4
0000e6  4770              BXNE     lr
0000e8  f4101f00          TST      r0,#0x200000          ;1258
0000ec  bf1e              ITTT     NE                    ;1260
0000ee  f44f4080          MOVNE    r0,#0x4000            ;1260
0000f2  b001              ADDNE    sp,sp,#4
0000f4  4770              BXNE     lr
0000f6  f4101f80          TST      r0,#0x100000          ;1262
0000fa  bf1e              ITTT     NE                    ;1264
0000fc  f44f4000          MOVNE    r0,#0x8000            ;1264
000100  b001              ADDNE    sp,sp,#4
000102  4770              BXNE     lr
000104  f4102f80          TST      r0,#0x40000           ;1266
000108  bf1e              ITTT     NE                    ;1268
00010a  f44f3000          MOVNE    r0,#0x20000           ;1268
00010e  b001              ADDNE    sp,sp,#4
000110  4770              BXNE     lr
000112  f4103f00          TST      r0,#0x20000           ;1270
000116  bf1e              ITTT     NE                    ;1272
000118  f44f2080          MOVNE    r0,#0x40000           ;1272
00011c  b001              ADDNE    sp,sp,#4
00011e  4770              BXNE     lr
000120  f4103f80          TST      r0,#0x10000           ;1274
000124  bf1e              ITTT     NE                    ;1276
000126  f44f2000          MOVNE    r0,#0x80000           ;1276
00012a  b001              ADDNE    sp,sp,#4
00012c  4770              BXNE     lr
00012e  f4104f00          TST      r0,#0x8000            ;1278
000132  bf1e              ITTT     NE                    ;1280
000134  f44f1080          MOVNE    r0,#0x100000          ;1280
000138  b001              ADDNE    sp,sp,#4
00013a  4770              BXNE     lr
00013c  f4104f80          TST      r0,#0x4000            ;1282
000140  bf1e              ITTT     NE                    ;1284
000142  f44f1000          MOVNE    r0,#0x200000          ;1284
000146  b001              ADDNE    sp,sp,#4
000148  4770              BXNE     lr
00014a  f4105f00          TST      r0,#0x2000            ;1286
00014e  bf1e              ITTT     NE                    ;1288
000150  f44f0080          MOVNE    r0,#0x400000          ;1288
000154  b001              ADDNE    sp,sp,#4
000156  4770              BXNE     lr
000158  f0100f08          TST      r0,#8                 ;1290
00015c  bf14              ITE      NE                    ;1292
00015e  f44f0000          MOVNE    r0,#0x800000          ;1292
000162  f44f3080          MOVEQ    r0,#0x10000           ;1296
000166  b001              ADD      sp,sp,#4
000168  4770              BX       lr
;;;1299   
                          ENDP

00016a  0000              DCW      0x0000
                  |L39.364|
                          DCD      SystemCoreClock
                  |L39.368|
                          DCD      0xfdffe008

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_sdmmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REVSH|
#line 402
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____RRX|
#line 587
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
