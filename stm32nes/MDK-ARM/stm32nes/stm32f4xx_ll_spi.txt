; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_spi.o --depend=stm32nes\stm32f4xx_ll_spi.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_spi.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_spi.c]
                          THUMB

                          AREA ||i.LL_I2S_ConfigPrescaler||, CODE, READONLY, ALIGN=1

                  LL_I2S_ConfigPrescaler PROC
;;;542      */
;;;543    void LL_I2S_ConfigPrescaler(SPI_TypeDef *SPIx, uint32_t PrescalerLinear, uint32_t PrescalerParity)
000000  6a03              LDR      r3,[r0,#0x20]
;;;544    {
;;;545      /* Check the I2S parameters */
;;;546      assert_param(IS_I2S_ALL_INSTANCE(SPIx));
;;;547      assert_param(IS_LL_I2S_PRESCALER_LINEAR(PrescalerLinear));
;;;548      assert_param(IS_LL_I2S_PRESCALER_PARITY(PrescalerParity));
;;;549    
;;;550      /* Write to SPIx I2SPR */
;;;551      MODIFY_REG(SPIx->I2SPR, SPI_I2SPR_I2SDIV | SPI_I2SPR_ODD, PrescalerLinear | (PrescalerParity << 8U));
000002  ea412102          ORR      r1,r1,r2,LSL #8
000006  f36f0308          BFC      r3,#0,#9
00000a  4319              ORRS     r1,r1,r3
00000c  6201              STR      r1,[r0,#0x20]
;;;552    }
00000e  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.LL_I2S_DeInit||, CODE, READONLY, ALIGN=2

                  LL_I2S_DeInit PROC
;;;400      */
;;;401    ErrorStatus LL_I2S_DeInit(SPI_TypeDef *SPIx)
000000  4601              MOV      r1,r0
000002  2000              MOVS     r0,#0
000004  f8dfc054          LDR      r12,|L2.92|
000008  4b15              LDR      r3,|L2.96|
00000a  f1a14280          SUB      r2,r1,#0x40000000
00000e  f5b23298          SUBS     r2,r2,#0x13000
;;;402    {
000012  d00c              BEQ      |L2.46|
000014  4a13              LDR      r2,|L2.100|
000016  4561              CMP      r1,r12
000018  d113              BNE      |L2.66|
00001a  6810              LDR      r0,[r2,#0]
00001c  f4404080          ORR      r0,r0,#0x4000
000020  6010              STR      r0,[r2,#0]
000022  6810              LDR      r0,[r2,#0]
000024  f4204080          BIC      r0,r0,#0x4000
000028  6010              STR      r0,[r2,#0]
00002a  2001              MOVS     r0,#1
;;;403      return LL_SPI_DeInit(SPIx);
;;;404    }
00002c  4770              BX       lr
                  |L2.46|
00002e  480e              LDR      r0,|L2.104|
000030  6801              LDR      r1,[r0,#0]
000032  f4415180          ORR      r1,r1,#0x1000
000036  6001              STR      r1,[r0,#0]
000038  6801              LDR      r1,[r0,#0]
00003a  f4215180          BIC      r1,r1,#0x1000
00003e  6001              STR      r1,[r0,#0]
000040  e00a              B        |L2.88|
                  |L2.66|
000042  4299              CMP      r1,r3
000044  bf18              IT       NE
000046  4770              BXNE     lr
000048  6810              LDR      r0,[r2,#0]
00004a  f4404000          ORR      r0,r0,#0x8000
00004e  6010              STR      r0,[r2,#0]
000050  6810              LDR      r0,[r2,#0]
000052  f4204000          BIC      r0,r0,#0x8000
000056  6010              STR      r0,[r2,#0]
                  |L2.88|
000058  2001              MOVS     r0,#1
00005a  4770              BX       lr
;;;405    
                          ENDP

                  |L2.92|
                          DCD      0x40003800
                  |L2.96|
                          DCD      0x40003c00
                  |L2.100|
                          DCD      0x40023820
                  |L2.104|
                          DCD      0x40023824

                          AREA ||i.LL_I2S_Init||, CODE, READONLY, ALIGN=2

                  LL_I2S_Init PROC
;;;415      */
;;;416    ErrorStatus LL_I2S_Init(SPI_TypeDef *SPIx, LL_I2S_InitTypeDef *I2S_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;417    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;418      uint16_t i2sdiv = 2U, i2sodd = 0U, packetlength = 1U;
000006  2100              MOVS     r1,#0
000008  2002              MOVS     r0,#2
;;;419      uint32_t tmp = 0U;
;;;420      uint32_t sourceclock = 0U;
;;;421      ErrorStatus status = ERROR;
;;;422    
;;;423      /* Check the I2S parameters */
;;;424      assert_param(IS_I2S_ALL_INSTANCE(SPIx));
;;;425      assert_param(IS_LL_I2S_MODE(I2S_InitStruct->Mode));
;;;426      assert_param(IS_LL_I2S_STANDARD(I2S_InitStruct->Standard));
;;;427      assert_param(IS_LL_I2S_DATAFORMAT(I2S_InitStruct->DataFormat));
;;;428      assert_param(IS_LL_I2S_MCLK_OUTPUT(I2S_InitStruct->MCLKOutput));
;;;429      assert_param(IS_LL_I2S_AUDIO_FREQ(I2S_InitStruct->AudioFreq));
;;;430      assert_param(IS_LL_I2S_CPOL(I2S_InitStruct->ClockPolarity));
;;;431    
;;;432      if (LL_I2S_IsEnabled(SPIx) == 0x00000000U)
00000a  69eb              LDR      r3,[r5,#0x1c]
00000c  2601              MOVS     r6,#1                 ;418
00000e  460a              MOV      r2,r1                 ;421
000010  f4136f80          TST      r3,#0x400
000014  d142              BNE      |L3.156|
000016  e9d42300          LDRD     r2,r3,[r4,#0]         ;417
;;;433      {
;;;434        /*---------------------------- SPIx I2SCFGR Configuration --------------------
;;;435         * Configure SPIx I2SCFGR with parameters:
;;;436         * - Mode:          SPI_I2SCFGR_I2SCFG[1:0] bit
;;;437         * - Standard:      SPI_I2SCFGR_I2SSTD[1:0] and SPI_I2SCFGR_PCMSYNC bits
;;;438         * - DataFormat:    SPI_I2SCFGR_CHLEN and SPI_I2SCFGR_DATLEN bits
;;;439         * - ClockPolarity: SPI_I2SCFGR_CKPOL bit
;;;440         */
;;;441    
;;;442        /* Write to SPIx I2SCFGR */
;;;443        MODIFY_REG(SPIx->I2SCFGR,
00001a  431a              ORRS     r2,r2,r3
00001c  f8d4c014          LDR      r12,[r4,#0x14]
000020  68a3              LDR      r3,[r4,#8]
000022  ea43030c          ORR      r3,r3,r12
000026  431a              ORRS     r2,r2,r3
000028  69eb              LDR      r3,[r5,#0x1c]
00002a  f023033f          BIC      r3,r3,#0x3f
00002e  f4236330          BIC      r3,r3,#0xb00
000032  431a              ORRS     r2,r2,r3
000034  f4426200          ORR      r2,r2,#0x800
000038  61ea              STR      r2,[r5,#0x1c]
;;;444                   I2S_I2SCFGR_CLEAR_MASK,
;;;445                   I2S_InitStruct->Mode | I2S_InitStruct->Standard |
;;;446                   I2S_InitStruct->DataFormat | I2S_InitStruct->ClockPolarity |
;;;447                   SPI_I2SCFGR_I2SMOD);
;;;448    
;;;449        /*---------------------------- SPIx I2SPR Configuration ----------------------
;;;450         * Configure SPIx I2SPR with parameters:
;;;451         * - MCLKOutput:    SPI_I2SPR_MCKOE bit
;;;452         * - AudioFreq:     SPI_I2SPR_I2SDIV[7:0] and SPI_I2SPR_ODD bits
;;;453         */
;;;454    
;;;455        /* If the requested audio frequency is not the default, compute the prescaler (i2sodd, i2sdiv)
;;;456         * else, default values are used:  i2sodd = 0U, i2sdiv = 2U.
;;;457         */
;;;458        if (I2S_InitStruct->AudioFreq != LL_I2S_AUDIOFREQ_DEFAULT)
00003a  6922              LDR      r2,[r4,#0x10]
00003c  2a02              CMP      r2,#2
00003e  d028              BEQ      |L3.146|
;;;459        {
;;;460          /* Check the frame length (For the Prescaler computing)
;;;461           * Default value: LL_I2S_DATAFORMAT_16B (packetlength = 1U).
;;;462           */
;;;463          if (I2S_InitStruct->DataFormat != LL_I2S_DATAFORMAT_16B)
000040  68a0              LDR      r0,[r4,#8]
000042  2800              CMP      r0,#0
;;;464          {
;;;465            /* Packet length is 32 bits */
;;;466            packetlength = 2U;
000044  bf18              IT       NE
000046  2602              MOVNE    r6,#2
;;;467          }
;;;468    
;;;469          /* If an external I2S clock has to be used, the specific define should be set
;;;470          in the project configuration or in the stm32f4xx_ll_rcc.h file */
;;;471          /* Get the I2S source clock value */
;;;472          sourceclock = LL_RCC_GetI2SClockFreq(LL_RCC_I2S1_CLKSOURCE);
000048  f44f0000          MOV      r0,#0x800000
00004c  f7fffffe          BL       LL_RCC_GetI2SClockFreq
;;;473    
;;;474          /* Compute the Real divider depending on the MCLK output state with a floating point */
;;;475          if (I2S_InitStruct->MCLKOutput == LL_I2S_MCLK_OUTPUT_ENABLE)
000050  68e1              LDR      r1,[r4,#0xc]
000052  f5b17f00          CMP      r1,#0x200
000056  d023              BEQ      |L3.160|
;;;476          {
;;;477            /* MCLK output is enabled */
;;;478            tmp = (uint16_t)(((((sourceclock / 256U) * 10U) / I2S_InitStruct->AudioFreq)) + 5U);
;;;479          }
;;;480          else
;;;481          {
;;;482            /* MCLK output is disabled */
;;;483            tmp = (uint16_t)(((((sourceclock / (32U * packetlength)) * 10U) / I2S_InitStruct->AudioFreq)) + 5U);
000058  0171              LSLS     r1,r6,#5
00005a  fbb0f0f1          UDIV     r0,r0,r1
00005e  eb000080          ADD      r0,r0,r0,LSL #2
000062  6921              LDR      r1,[r4,#0x10]
000064  0040              LSLS     r0,r0,#1
000066  fbb0f0f1          UDIV     r0,r0,r1
00006a  1d40              ADDS     r0,r0,#5
00006c  b280              UXTH     r0,r0
                  |L3.110|
;;;484          }
;;;485    
;;;486          /* Remove the floating point */
;;;487          tmp = tmp / 10U;
00006e  4911              LDR      r1,|L3.180|
;;;488    
;;;489          /* Check the parity of the divider */
;;;490          i2sodd = (uint16_t)(tmp & (uint16_t)0x0001U);
;;;491    
;;;492          /* Compute the i2sdiv prescaler */
;;;493          i2sdiv = (uint16_t)((tmp - i2sodd) / 2U);
;;;494    
;;;495          /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;496          i2sodd = (uint16_t)(i2sodd << 8U);
000070  f64f72ff          MOV      r2,#0xffff
000074  fba11000          UMULL    r1,r0,r1,r0           ;487
000078  08c0              LSRS     r0,r0,#3              ;487
00007a  f0000101          AND      r1,r0,#1              ;490
00007e  1a40              SUBS     r0,r0,r1              ;493
000080  f3c0004f          UBFX     r0,r0,#1,#16          ;493
000084  ea022101          AND      r1,r2,r1,LSL #8
;;;497        }
;;;498    
;;;499        /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;500        if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
000088  1e82              SUBS     r2,r0,#2
00008a  2afe              CMP      r2,#0xfe
;;;501        {
;;;502          /* Set the default values */
;;;503          i2sdiv = 2U;
00008c  bf24              ITT      CS
00008e  2002              MOVCS    r0,#2
;;;504          i2sodd = 0U;
000090  2100              MOVCS    r1,#0
                  |L3.146|
;;;505        }
;;;506    
;;;507        /* Write to SPIx I2SPR register the computed value */
;;;508        WRITE_REG(SPIx->I2SPR, i2sdiv | i2sodd | I2S_InitStruct->MCLKOutput);
000092  4308              ORRS     r0,r0,r1
000094  68e2              LDR      r2,[r4,#0xc]
000096  4310              ORRS     r0,r0,r2
000098  6228              STR      r0,[r5,#0x20]
;;;509    
;;;510        status = SUCCESS;
00009a  2201              MOVS     r2,#1
                  |L3.156|
;;;511      }
;;;512      return status;
00009c  4610              MOV      r0,r2
;;;513    }
00009e  bd70              POP      {r4-r6,pc}
                  |L3.160|
0000a0  0a00              LSRS     r0,r0,#8              ;478
0000a2  eb000080          ADD      r0,r0,r0,LSL #2       ;478
0000a6  6921              LDR      r1,[r4,#0x10]         ;478
0000a8  0040              LSLS     r0,r0,#1              ;478
0000aa  fbb0f0f1          UDIV     r0,r0,r1              ;478
0000ae  1d40              ADDS     r0,r0,#5              ;478
0000b0  b280              UXTH     r0,r0                 ;478
0000b2  e7dc              B        |L3.110|
;;;514    
                          ENDP

                  |L3.180|
                          DCD      0xcccccccd

                          AREA ||i.LL_I2S_InitFullDuplex||, CODE, READONLY, ALIGN=1

                  LL_I2S_InitFullDuplex PROC
;;;568      */
;;;569    ErrorStatus  LL_I2S_InitFullDuplex(SPI_TypeDef *I2Sxext, LL_I2S_InitTypeDef *I2S_InitStruct)
000000  2200              MOVS     r2,#0
;;;570    {
;;;571      uint16_t mode = 0U;
;;;572      ErrorStatus status = ERROR;
;;;573    
;;;574      /* Check the I2S parameters */
;;;575      assert_param(IS_I2S_EXT_ALL_INSTANCE(I2Sxext));
;;;576      assert_param(IS_LL_I2S_MODE(I2S_InitStruct->Mode));
;;;577      assert_param(IS_LL_I2S_STANDARD(I2S_InitStruct->Standard));
;;;578      assert_param(IS_LL_I2S_DATAFORMAT(I2S_InitStruct->DataFormat));
;;;579      assert_param(IS_LL_I2S_CPOL(I2S_InitStruct->ClockPolarity));
;;;580    
;;;581      if (LL_I2S_IsEnabled(I2Sxext) == 0x00000000U)
000002  f8d0c01c          LDR      r12,[r0,#0x1c]
000006  4613              MOV      r3,r2                 ;572
000008  f41c6f80          TST      r12,#0x400
00000c  d001              BEQ      |L4.18|
                  |L4.14|
;;;582      {
;;;583        /*---------------------------- SPIx I2SCFGR Configuration --------------------
;;;584         * Configure SPIx I2SCFGR with parameters:
;;;585         * - Mode:          SPI_I2SCFGR_I2SCFG[1:0] bit
;;;586         * - Standard:      SPI_I2SCFGR_I2SSTD[1:0] and SPI_I2SCFGR_PCMSYNC bits
;;;587         * - DataFormat:    SPI_I2SCFGR_CHLEN and SPI_I2SCFGR_DATLEN bits
;;;588         * - ClockPolarity: SPI_I2SCFGR_CKPOL bit
;;;589         */
;;;590    
;;;591        /* Reset I2SPR registers */
;;;592        WRITE_REG(I2Sxext->I2SPR, I2S_I2SPR_CLEAR_MASK);
;;;593    
;;;594        /* Get the mode to be configured for the extended I2S */
;;;595        if ((I2S_InitStruct->Mode == LL_I2S_MODE_MASTER_TX) || (I2S_InitStruct->Mode == LL_I2S_MODE_SLAVE_TX))
;;;596        {
;;;597          mode = LL_I2S_MODE_SLAVE_RX;
;;;598        }
;;;599        else
;;;600        {
;;;601          if ((I2S_InitStruct->Mode == LL_I2S_MODE_MASTER_RX) || (I2S_InitStruct->Mode == LL_I2S_MODE_SLAVE_RX))
;;;602          {
;;;603            mode = LL_I2S_MODE_SLAVE_TX;
;;;604          }
;;;605        }
;;;606    
;;;607        /* Write to SPIx I2SCFGR */
;;;608        MODIFY_REG(I2Sxext->I2SCFGR,
;;;609                   I2S_I2SCFGR_CLEAR_MASK,
;;;610                   I2S_InitStruct->Standard |
;;;611                   I2S_InitStruct->DataFormat | I2S_InitStruct->ClockPolarity |
;;;612                   SPI_I2SCFGR_I2SMOD | mode);
;;;613    
;;;614        status = SUCCESS;
;;;615      }
;;;616      return status;
00000e  4618              MOV      r0,r3
;;;617    }
000010  4770              BX       lr
                  |L4.18|
000012  2302              MOVS     r3,#2                 ;592
000014  6203              STR      r3,[r0,#0x20]         ;592
000016  680b              LDR      r3,[r1,#0]            ;595
000018  f5b37f00          CMP      r3,#0x200             ;595
00001c  bf14              ITE      NE                    ;595
00001e  2b00              CMPNE    r3,#0                 ;595
000020  f44f7280          MOVEQ    r2,#0x100             ;597
000024  e9d13c01          LDRD     r3,r12,[r1,#4]        ;597
000028  6949              LDR      r1,[r1,#0x14]         ;608
00002a  ea43030c          ORR      r3,r3,r12             ;608
00002e  ea410102          ORR      r1,r1,r2              ;608
000032  69c2              LDR      r2,[r0,#0x1c]         ;608
000034  ea430101          ORR      r1,r3,r1              ;608
000038  f022023f          BIC      r2,r2,#0x3f           ;608
00003c  f4226230          BIC      r2,r2,#0xb00          ;608
000040  ea410102          ORR      r1,r1,r2              ;608
000044  f4416100          ORR      r1,r1,#0x800          ;608
000048  61c1              STR      r1,[r0,#0x1c]         ;608
00004a  f04f0301          MOV      r3,#1                 ;614
00004e  e7de              B        |L4.14|
;;;618    #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
                          ENDP


                          AREA ||i.LL_I2S_StructInit||, CODE, READONLY, ALIGN=1

                  LL_I2S_StructInit PROC
;;;520      */
;;;521    void LL_I2S_StructInit(LL_I2S_InitTypeDef *I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;522    {
;;;523      /*--------------- Reset I2S init structure parameters values -----------------*/
;;;524      I2S_InitStruct->Mode              = LL_I2S_MODE_SLAVE_TX;
;;;525      I2S_InitStruct->Standard          = LL_I2S_STANDARD_PHILIPS;
000002  6001              STR      r1,[r0,#0]
;;;526      I2S_InitStruct->DataFormat        = LL_I2S_DATAFORMAT_16B;
000004  6041              STR      r1,[r0,#4]
;;;527      I2S_InitStruct->MCLKOutput        = LL_I2S_MCLK_OUTPUT_DISABLE;
;;;528      I2S_InitStruct->AudioFreq         = LL_I2S_AUDIOFREQ_DEFAULT;
000006  2202              MOVS     r2,#2
000008  6081              STR      r1,[r0,#8]
00000a  e9c01203          STRD     r1,r2,[r0,#0xc]
;;;529      I2S_InitStruct->ClockPolarity     = LL_I2S_POLARITY_LOW;
00000e  6141              STR      r1,[r0,#0x14]
;;;530    }
000010  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.LL_SPI_DeInit||, CODE, READONLY, ALIGN=2

                  LL_SPI_DeInit PROC
;;;138      */
;;;139    ErrorStatus LL_SPI_DeInit(SPI_TypeDef *SPIx)
000000  4602              MOV      r2,r0
;;;140    {
;;;141      ErrorStatus status = ERROR;
000002  2000              MOVS     r0,#0
;;;142    
;;;143      /* Check the parameters */
;;;144      assert_param(IS_SPI_ALL_INSTANCE(SPIx));
;;;145    
;;;146    #if defined(SPI1)
;;;147      if (SPIx == SPI1)
;;;148      {
;;;149        /* Force reset of SPI clock */
;;;150        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
;;;151    
;;;152        /* Release reset of SPI clock */
;;;153        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
;;;154    
;;;155        status = SUCCESS;
;;;156      }
;;;157    #endif /* SPI1 */
;;;158    #if defined(SPI2)
;;;159      if (SPIx == SPI2)
000004  f8dfc054          LDR      r12,|L6.92|
;;;160      {
;;;161        /* Force reset of SPI clock */
;;;162        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
;;;163    
;;;164        /* Release reset of SPI clock */
;;;165        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
;;;166    
;;;167        status = SUCCESS;
;;;168      }
;;;169    #endif /* SPI2 */
;;;170    #if defined(SPI3)
;;;171      if (SPIx == SPI3)
000008  4b15              LDR      r3,|L6.96|
00000a  f1a24180          SUB      r1,r2,#0x40000000     ;147
00000e  f5b13198          SUBS     r1,r1,#0x13000        ;147
000012  d00c              BEQ      |L6.46|
000014  4913              LDR      r1,|L6.100|
000016  4562              CMP      r2,r12                ;159
000018  d113              BNE      |L6.66|
00001a  6808              LDR      r0,[r1,#0]            ;159
00001c  f4404080          ORR      r0,r0,#0x4000         ;159
000020  6008              STR      r0,[r1,#0]            ;159
000022  6808              LDR      r0,[r1,#0]            ;159
000024  f4204080          BIC      r0,r0,#0x4000         ;159
000028  6008              STR      r0,[r1,#0]            ;159
00002a  2001              MOVS     r0,#1                 ;167
;;;172      {
;;;173        /* Force reset of SPI clock */
;;;174        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI3);
;;;175    
;;;176        /* Release reset of SPI clock */
;;;177        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI3);
;;;178    
;;;179        status = SUCCESS;
;;;180      }
;;;181    #endif /* SPI3 */
;;;182    #if defined(SPI4)
;;;183      if (SPIx == SPI4)
;;;184      {
;;;185        /* Force reset of SPI clock */
;;;186        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI4);
;;;187    
;;;188        /* Release reset of SPI clock */
;;;189        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI4);
;;;190    
;;;191        status = SUCCESS;
;;;192      }
;;;193    #endif /* SPI4 */
;;;194    #if defined(SPI5)
;;;195      if (SPIx == SPI5)
;;;196      {
;;;197        /* Force reset of SPI clock */
;;;198        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI5);
;;;199    
;;;200        /* Release reset of SPI clock */
;;;201        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI5);
;;;202    
;;;203        status = SUCCESS;
;;;204      }
;;;205    #endif /* SPI5 */
;;;206    #if defined(SPI6)
;;;207      if (SPIx == SPI6)
;;;208      {
;;;209        /* Force reset of SPI clock */
;;;210        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI6);
;;;211    
;;;212        /* Release reset of SPI clock */
;;;213        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI6);
;;;214    
;;;215        status = SUCCESS;
;;;216      }
;;;217    #endif /* SPI6 */
;;;218    
;;;219      return status;
;;;220    }
00002c  4770              BX       lr
                  |L6.46|
00002e  480e              LDR      r0,|L6.104|
000030  6801              LDR      r1,[r0,#0]
000032  f4415180          ORR      r1,r1,#0x1000
000036  6001              STR      r1,[r0,#0]
000038  6801              LDR      r1,[r0,#0]
00003a  f4215180          BIC      r1,r1,#0x1000
00003e  6001              STR      r1,[r0,#0]
000040  e00a              B        |L6.88|
                  |L6.66|
000042  429a              CMP      r2,r3                 ;171
000044  bf18              IT       NE
000046  4770              BXNE     lr
000048  6808              LDR      r0,[r1,#0]
00004a  f4404000          ORR      r0,r0,#0x8000
00004e  6008              STR      r0,[r1,#0]
000050  6808              LDR      r0,[r1,#0]
000052  f4204000          BIC      r0,r0,#0x8000
000056  6008              STR      r0,[r1,#0]
                  |L6.88|
000058  2001              MOVS     r0,#1                 ;179
00005a  4770              BX       lr
;;;221    
                          ENDP

                  |L6.92|
                          DCD      0x40003800
                  |L6.96|
                          DCD      0x40003c00
                  |L6.100|
                          DCD      0x40023820
                  |L6.104|
                          DCD      0x40023824

                          AREA ||i.LL_SPI_Init||, CODE, READONLY, ALIGN=1

                  LL_SPI_Init PROC
;;;229      */
;;;230    ErrorStatus LL_SPI_Init(SPI_TypeDef *SPIx, LL_SPI_InitTypeDef *SPI_InitStruct)
000000  6803              LDR      r3,[r0,#0]
;;;231    {
;;;232      ErrorStatus status = ERROR;
000002  2200              MOVS     r2,#0
;;;233    
;;;234      /* Check the SPI Instance SPIx*/
;;;235      assert_param(IS_SPI_ALL_INSTANCE(SPIx));
;;;236    
;;;237      /* Check the SPI parameters from SPI_InitStruct*/
;;;238      assert_param(IS_LL_SPI_TRANSFER_DIRECTION(SPI_InitStruct->TransferDirection));
;;;239      assert_param(IS_LL_SPI_MODE(SPI_InitStruct->Mode));
;;;240      assert_param(IS_LL_SPI_DATAWIDTH(SPI_InitStruct->DataWidth));
;;;241      assert_param(IS_LL_SPI_POLARITY(SPI_InitStruct->ClockPolarity));
;;;242      assert_param(IS_LL_SPI_PHASE(SPI_InitStruct->ClockPhase));
;;;243      assert_param(IS_LL_SPI_NSS(SPI_InitStruct->NSS));
;;;244      assert_param(IS_LL_SPI_BAUDRATE(SPI_InitStruct->BaudRate));
;;;245      assert_param(IS_LL_SPI_BITORDER(SPI_InitStruct->BitOrder));
;;;246      assert_param(IS_LL_SPI_CRCCALCULATION(SPI_InitStruct->CRCCalculation));
;;;247    
;;;248      if (LL_SPI_IsEnabled(SPIx) == 0x00000000U)
000004  f0130f40          TST      r3,#0x40
000008  d127              BNE      |L7.90|
00000a  e9d12300          LDRD     r2,r3,[r1,#0]         ;231
;;;249      {
;;;250        /*---------------------------- SPIx CR1 Configuration ------------------------
;;;251         * Configure SPIx CR1 with parameters:
;;;252         * - TransferDirection:  SPI_CR1_BIDIMODE, SPI_CR1_BIDIOE and SPI_CR1_RXONLY bits
;;;253         * - Master/Slave Mode:  SPI_CR1_MSTR bit
;;;254         * - DataWidth:          SPI_CR1_DFF bit
;;;255         * - ClockPolarity:      SPI_CR1_CPOL bit
;;;256         * - ClockPhase:         SPI_CR1_CPHA bit
;;;257         * - NSS management:     SPI_CR1_SSM bit
;;;258         * - BaudRate prescaler: SPI_CR1_BR[2:0] bits
;;;259         * - BitOrder:           SPI_CR1_LSBFIRST bit
;;;260         * - CRCCalculation:     SPI_CR1_CRCEN bit
;;;261         */
;;;262        MODIFY_REG(SPIx->CR1,
00000e  431a              ORRS     r2,r2,r3
000010  e9d13c02          LDRD     r3,r12,[r1,#8]
000014  ea43030c          ORR      r3,r3,r12
000018  431a              ORRS     r2,r2,r3
00001a  690b              LDR      r3,[r1,#0x10]
00001c  431a              ORRS     r2,r2,r3
00001e  694b              LDR      r3,[r1,#0x14]
000020  431a              ORRS     r2,r2,r3
000022  698b              LDR      r3,[r1,#0x18]
000024  431a              ORRS     r2,r2,r3
000026  69cb              LDR      r3,[r1,#0x1c]
000028  431a              ORRS     r2,r2,r3
00002a  6a0b              LDR      r3,[r1,#0x20]
00002c  431a              ORRS     r2,r2,r3
00002e  6803              LDR      r3,[r0,#0]
000030  f02303bf          BIC      r3,r3,#0xbf
000034  f423437f          BIC      r3,r3,#0xff00
000038  431a              ORRS     r2,r2,r3
00003a  6002              STR      r2,[r0,#0]
;;;263                   SPI_CR1_CLEAR_MASK,
;;;264                   SPI_InitStruct->TransferDirection | SPI_InitStruct->Mode | SPI_InitStruct->DataWidth |
;;;265                   SPI_InitStruct->ClockPolarity | SPI_InitStruct->ClockPhase |
;;;266                   SPI_InitStruct->NSS | SPI_InitStruct->BaudRate |
;;;267                   SPI_InitStruct->BitOrder | SPI_InitStruct->CRCCalculation);
;;;268    
;;;269        /*---------------------------- SPIx CR2 Configuration ------------------------
;;;270         * Configure SPIx CR2 with parameters:
;;;271         * - NSS management:     SSOE bit
;;;272         */
;;;273        MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, (SPI_InitStruct->NSS >> 16U));
00003c  6842              LDR      r2,[r0,#4]
00003e  694b              LDR      r3,[r1,#0x14]
000040  f0220204          BIC      r2,r2,#4
000044  ea424213          ORR      r2,r2,r3,LSR #16
000048  6042              STR      r2,[r0,#4]
;;;274    
;;;275        /*---------------------------- SPIx CRCPR Configuration ----------------------
;;;276         * Configure SPIx CRCPR with parameters:
;;;277         * - CRCPoly:            CRCPOLY[15:0] bits
;;;278         */
;;;279        if (SPI_InitStruct->CRCCalculation == LL_SPI_CRCCALCULATION_ENABLE)
00004a  6a0a              LDR      r2,[r1,#0x20]
00004c  f5b25f00          CMP      r2,#0x2000
000050  d102              BNE      |L7.88|
;;;280        {
;;;281          assert_param(IS_LL_SPI_CRC_POLYNOMIAL(SPI_InitStruct->CRCPoly));
;;;282          LL_SPI_SetCRCPolynomial(SPIx, SPI_InitStruct->CRCPoly);
000052  8c89              LDRH     r1,[r1,#0x24]
000054  b289              UXTH     r1,r1
000056  6101              STR      r1,[r0,#0x10]
                  |L7.88|
;;;283        }
;;;284        status = SUCCESS;
000058  2201              MOVS     r2,#1
                  |L7.90|
;;;285      }
;;;286    
;;;287      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;288      CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD);
00005a  69c1              LDR      r1,[r0,#0x1c]
00005c  f4216100          BIC      r1,r1,#0x800
000060  61c1              STR      r1,[r0,#0x1c]
;;;289      return status;
000062  4610              MOV      r0,r2
;;;290    }
000064  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.LL_SPI_StructInit||, CODE, READONLY, ALIGN=1

                  LL_SPI_StructInit PROC
;;;297      */
;;;298    void LL_SPI_StructInit(LL_SPI_InitTypeDef *SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;299    {
;;;300      /* Set SPI_InitStruct fields to default values */
;;;301      SPI_InitStruct->TransferDirection = LL_SPI_FULL_DUPLEX;
;;;302      SPI_InitStruct->Mode              = LL_SPI_MODE_SLAVE;
000002  6001              STR      r1,[r0,#0]
;;;303      SPI_InitStruct->DataWidth         = LL_SPI_DATAWIDTH_8BIT;
000004  6041              STR      r1,[r0,#4]
;;;304      SPI_InitStruct->ClockPolarity     = LL_SPI_POLARITY_LOW;
000006  6081              STR      r1,[r0,#8]
;;;305      SPI_InitStruct->ClockPhase        = LL_SPI_PHASE_1EDGE;
000008  60c1              STR      r1,[r0,#0xc]
;;;306      SPI_InitStruct->NSS               = LL_SPI_NSS_HARD_INPUT;
00000a  6101              STR      r1,[r0,#0x10]
;;;307      SPI_InitStruct->BaudRate          = LL_SPI_BAUDRATEPRESCALER_DIV2;
00000c  6141              STR      r1,[r0,#0x14]
;;;308      SPI_InitStruct->BitOrder          = LL_SPI_MSB_FIRST;
00000e  6181              STR      r1,[r0,#0x18]
;;;309      SPI_InitStruct->CRCCalculation    = LL_SPI_CRCCALCULATION_DISABLE;
000010  61c1              STR      r1,[r0,#0x1c]
;;;310      SPI_InitStruct->CRCPoly           = 7U;
000012  6201              STR      r1,[r0,#0x20]
000014  2107              MOVS     r1,#7
000016  6241              STR      r1,[r0,#0x24]
;;;311    }
000018  4770              BX       lr
;;;312    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____RRX|
#line 587
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
