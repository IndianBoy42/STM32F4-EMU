; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_usart.o --depend=stm32nes\stm32f4xx_ll_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_usart.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usart.c]
                          THUMB

                          AREA ||i.LL_USART_ClockInit||, CODE, READONLY, ALIGN=1

                  LL_USART_ClockInit PROC
;;;433      */
;;;434    ErrorStatus LL_USART_ClockInit(USART_TypeDef *USARTx, LL_USART_ClockInitTypeDef *USART_ClockInitStruct)
000000  68c3              LDR      r3,[r0,#0xc]
;;;435    {
;;;436      ErrorStatus status = SUCCESS;
000002  2201              MOVS     r2,#1
;;;437    
;;;438      /* Check USART Instance and Clock signal output parameters */
;;;439      assert_param(IS_UART_INSTANCE(USARTx));
;;;440      assert_param(IS_LL_USART_CLOCKOUTPUT(USART_ClockInitStruct->ClockOutput));
;;;441    
;;;442      /* USART needs to be in disabled state, in order to be able to configure some bits in
;;;443         CRx registers */
;;;444      if (LL_USART_IsEnabled(USARTx) == 0U)
000004  f4135f00          TST      r3,#0x2000
;;;445      {
;;;446        /*---------------------------- USART CR2 Configuration -----------------------*/
;;;447        /* If Clock signal has to be output */
;;;448        if (USART_ClockInitStruct->ClockOutput == LL_USART_CLOCK_DISABLE)
;;;449        {
;;;450          /* Deactivate Clock signal delivery :
;;;451           * - Disable Clock Output:        USART_CR2_CLKEN cleared
;;;452           */
;;;453          LL_USART_DisableSCLKOutput(USARTx);
;;;454        }
;;;455        else
;;;456        {
;;;457          /* Ensure USART instance is USART capable */
;;;458          assert_param(IS_USART_INSTANCE(USARTx));
;;;459    
;;;460          /* Check clock related parameters */
;;;461          assert_param(IS_LL_USART_CLOCKPOLARITY(USART_ClockInitStruct->ClockPolarity));
;;;462          assert_param(IS_LL_USART_CLOCKPHASE(USART_ClockInitStruct->ClockPhase));
;;;463          assert_param(IS_LL_USART_LASTBITCLKOUTPUT(USART_ClockInitStruct->LastBitClockPulse));
;;;464    
;;;465          /*---------------------------- USART CR2 Configuration -----------------------
;;;466           * Configure USARTx CR2 (Clock signal related bits) with parameters:
;;;467           * - Enable Clock Output:         USART_CR2_CLKEN set
;;;468           * - Clock Polarity:              USART_CR2_CPOL bit according to USART_ClockInitStruct->ClockPolarity value
;;;469           * - Clock Phase:                 USART_CR2_CPHA bit according to USART_ClockInitStruct->ClockPhase value
;;;470           * - Last Bit Clock Pulse Output: USART_CR2_LBCL bit according to USART_ClockInitStruct->LastBitClockPulse value.
;;;471           */
;;;472          MODIFY_REG(USARTx->CR2,
;;;473                     USART_CR2_CLKEN | USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_LBCL,
;;;474                     USART_CR2_CLKEN | USART_ClockInitStruct->ClockPolarity |
;;;475                     USART_ClockInitStruct->ClockPhase | USART_ClockInitStruct->LastBitClockPulse);
;;;476        }
;;;477      }
;;;478      /* Else (USART not in Disabled state => return ERROR */
;;;479      else
;;;480      {
;;;481        status = ERROR;
000008  bf18              IT       NE
00000a  2200              MOVNE    r2,#0
00000c  d001              BEQ      |L1.18|
                  |L1.14|
;;;482      }
;;;483    
;;;484      return (status);
00000e  4610              MOV      r0,r2
;;;485    }
000010  4770              BX       lr
                  |L1.18|
000012  680b              LDR      r3,[r1,#0]            ;448
000014  2b00              CMP      r3,#0                 ;448
000016  bf04              ITT      EQ                    ;448
000018  6901              LDREQ    r1,[r0,#0x10]         ;448
00001a  f4216100          BICEQ    r1,r1,#0x800          ;448
00001e  d00d              BEQ      |L1.60|
000020  e9d13c01          LDRD     r3,r12,[r1,#4]        ;448
000024  ea43030c          ORR      r3,r3,r12             ;472
000028  68c9              LDR      r1,[r1,#0xc]          ;472
00002a  f8d0c010          LDR      r12,[r0,#0x10]        ;472
00002e  f42c6c70          BIC      r12,r12,#0xf00        ;472
000032  ea41010c          ORR      r1,r1,r12             ;472
000036  4319              ORRS     r1,r1,r3              ;472
000038  f4416100          ORR      r1,r1,#0x800          ;472
                  |L1.60|
00003c  6101              STR      r1,[r0,#0x10]         ;472
00003e  e7e6              B        |L1.14|
;;;486    
                          ENDP


                          AREA ||i.LL_USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  LL_USART_ClockStructInit PROC
;;;492      */
;;;493    void LL_USART_ClockStructInit(LL_USART_ClockInitTypeDef *USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;494    {
;;;495      /* Set LL_USART_ClockInitStruct fields with default values */
;;;496      USART_ClockInitStruct->ClockOutput       = LL_USART_CLOCK_DISABLE;
;;;497      USART_ClockInitStruct->ClockPolarity     = LL_USART_POLARITY_LOW;            /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */
000002  6001              STR      r1,[r0,#0]
;;;498      USART_ClockInitStruct->ClockPhase        = LL_USART_PHASE_1EDGE;             /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */
000004  6041              STR      r1,[r0,#4]
;;;499      USART_ClockInitStruct->LastBitClockPulse = LL_USART_LASTCLKPULSE_NO_OUTPUT;  /* Not relevant when ClockOutput = LL_USART_CLOCK_DISABLE */
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;500    }
00000a  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.LL_USART_DeInit||, CODE, READONLY, ALIGN=2

                  LL_USART_DeInit PROC
;;;142      */
;;;143    ErrorStatus LL_USART_DeInit(USART_TypeDef *USARTx)
000000  2301              MOVS     r3,#1
000002  4a2b              LDR      r2,|L3.176|
;;;144    {
;;;145      ErrorStatus status = SUCCESS;
;;;146    
;;;147      /* Check the parameters */
;;;148      assert_param(IS_UART_INSTANCE(USARTx));
;;;149    
;;;150      if (USARTx == USART1)
000004  f1a04180          SUB      r1,r0,#0x40000000
000008  f5b13188          SUBS     r1,r1,#0x11000
00000c  d01c              BEQ      |L3.72|
00000e  1f11              SUBS     r1,r2,#4              ;144
;;;151      {
;;;152        /* Force reset of USART clock */
;;;153        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART1);
;;;154    
;;;155        /* Release reset of USART clock */
;;;156        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART1);
;;;157      }
;;;158      else if (USARTx == USART2)
000010  f1a04c80          SUB      r12,r0,#0x40000000
000014  f5bc4c88          SUBS     r12,r12,#0x4400
000018  d01e              BEQ      |L3.88|
;;;159      {
;;;160        /* Force reset of USART clock */
;;;161        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART2);
;;;162    
;;;163        /* Release reset of USART clock */
;;;164        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART2);
;;;165      }
;;;166    #if defined(USART3)
;;;167      else if (USARTx == USART3)
00001a  f1a04c80          SUB      r12,r0,#0x40000000
00001e  f5bc4c90          SUBS     r12,r12,#0x4800
000022  d021              BEQ      |L3.104|
;;;168      {
;;;169        /* Force reset of USART clock */
;;;170        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_USART3);
;;;171    
;;;172        /* Release reset of USART clock */
;;;173        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART3);
;;;174      }
;;;175    #endif /* USART3 */
;;;176    #if defined(USART6)
;;;177      else if (USARTx == USART6)
000024  f1a04c80          SUB      r12,r0,#0x40000000
000028  f5bc3c8a          SUBS     r12,r12,#0x11400
00002c  d025              BEQ      |L3.122|
;;;178      {
;;;179        /* Force reset of USART clock */
;;;180        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART6);
;;;181    
;;;182        /* Release reset of USART clock */
;;;183        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART6);
;;;184      }
;;;185    #endif /* USART6 */
;;;186    #if defined(UART4)
;;;187      else if (USARTx == UART4)
00002e  f1a04280          SUB      r2,r0,#0x40000000
000032  f5b24298          SUBS     r2,r2,#0x4c00
000036  d02a              BEQ      |L3.142|
;;;188      {
;;;189        /* Force reset of UART clock */
;;;190        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART4);
;;;191    
;;;192        /* Release reset of UART clock */
;;;193        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART4);
;;;194      }
;;;195    #endif /* UART4 */
;;;196    #if defined(UART5)
;;;197      else if (USARTx == UART5)
000038  f1a04280          SUB      r2,r0,#0x40000000
00003c  f5b242a0          SUBS     r2,r2,#0x5000
;;;198      {
;;;199        /* Force reset of UART clock */
;;;200        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART5);
;;;201    
;;;202        /* Release reset of UART clock */
;;;203        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART5);
;;;204      }
;;;205    #endif /* UART5 */
;;;206    #if defined(UART7)
;;;207      else if (USARTx == UART7)
;;;208      {
;;;209        /* Force reset of UART clock */
;;;210        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART7);
;;;211    
;;;212        /* Release reset of UART clock */
;;;213        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART7);
;;;214      }
;;;215    #endif /* UART7 */
;;;216    #if defined(UART8)
;;;217      else if (USARTx == UART8)
;;;218      {
;;;219        /* Force reset of UART clock */
;;;220        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_UART8);
;;;221    
;;;222        /* Release reset of UART clock */
;;;223        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_UART8);
;;;224      }
;;;225    #endif /* UART8 */
;;;226    #if defined(UART9)
;;;227      else if (USARTx == UART9)
;;;228      {
;;;229        /* Force reset of UART clock */
;;;230        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_UART9);
;;;231    
;;;232        /* Release reset of UART clock */
;;;233        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_UART9);
;;;234      }
;;;235    #endif /* UART9 */
;;;236    #if defined(UART10)
;;;237      else if (USARTx == UART10)
;;;238      {
;;;239        /* Force reset of UART clock */
;;;240        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_UART10);
;;;241    
;;;242        /* Release reset of UART clock */
;;;243        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_UART10);
;;;244      }
;;;245    #endif /* UART10 */
;;;246      else
;;;247      {
;;;248        status = ERROR;
000040  bf18              IT       NE
000042  2300              MOVNE    r3,#0
000044  d02b              BEQ      |L3.158|
000046  e020              B        |L3.138|
                  |L3.72|
000048  6810              LDR      r0,[r2,#0]            ;197
00004a  f0400010          ORR      r0,r0,#0x10           ;197
00004e  6010              STR      r0,[r2,#0]            ;197
000050  6810              LDR      r0,[r2,#0]            ;197
000052  f0200010          BIC      r0,r0,#0x10           ;197
000056  e017              B        |L3.136|
                  |L3.88|
000058  6808              LDR      r0,[r1,#0]            ;156
00005a  f4403000          ORR      r0,r0,#0x20000        ;156
00005e  6008              STR      r0,[r1,#0]            ;156
000060  6808              LDR      r0,[r1,#0]            ;156
000062  f4203000          BIC      r0,r0,#0x20000        ;156
000066  e006              B        |L3.118|
                  |L3.104|
000068  6808              LDR      r0,[r1,#0]            ;164
00006a  f4402080          ORR      r0,r0,#0x40000        ;164
00006e  6008              STR      r0,[r1,#0]            ;164
000070  6808              LDR      r0,[r1,#0]            ;164
000072  f4202080          BIC      r0,r0,#0x40000        ;164
                  |L3.118|
000076  6008              STR      r0,[r1,#0]            ;164
000078  e007              B        |L3.138|
                  |L3.122|
00007a  6810              LDR      r0,[r2,#0]            ;164
00007c  f0400020          ORR      r0,r0,#0x20           ;164
000080  6010              STR      r0,[r2,#0]            ;164
000082  6810              LDR      r0,[r2,#0]            ;164
000084  f0200020          BIC      r0,r0,#0x20           ;164
                  |L3.136|
000088  6010              STR      r0,[r2,#0]            ;164
                  |L3.138|
;;;249      }
;;;250    
;;;251      return (status);
00008a  4618              MOV      r0,r3
;;;252    }
00008c  4770              BX       lr
                  |L3.142|
00008e  6808              LDR      r0,[r1,#0]
000090  f4402000          ORR      r0,r0,#0x80000
000094  6008              STR      r0,[r1,#0]
000096  6808              LDR      r0,[r1,#0]
000098  f4202000          BIC      r0,r0,#0x80000
00009c  e7eb              B        |L3.118|
                  |L3.158|
00009e  6808              LDR      r0,[r1,#0]            ;193
0000a0  f4401080          ORR      r0,r0,#0x100000       ;193
0000a4  6008              STR      r0,[r1,#0]            ;193
0000a6  6808              LDR      r0,[r1,#0]            ;193
0000a8  f4201080          BIC      r0,r0,#0x100000       ;193
0000ac  e7e3              B        |L3.118|
;;;253    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L3.176|
                          DCD      0x40023824

                          AREA ||i.LL_USART_Init||, CODE, READONLY, ALIGN=2

                  LL_USART_Init PROC
;;;266      */
;;;267    ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;268    {
000004  4604              MOV      r4,r0
;;;269      ErrorStatus status = ERROR;
;;;270      uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO;
;;;271      LL_RCC_ClocksTypeDef rcc_clocks;
;;;272    
;;;273      /* Check the parameters */
;;;274      assert_param(IS_UART_INSTANCE(USARTx));
;;;275      assert_param(IS_LL_USART_BAUDRATE(USART_InitStruct->BaudRate));
;;;276      assert_param(IS_LL_USART_DATAWIDTH(USART_InitStruct->DataWidth));
;;;277      assert_param(IS_LL_USART_STOPBITS(USART_InitStruct->StopBits));
;;;278      assert_param(IS_LL_USART_PARITY(USART_InitStruct->Parity));
;;;279      assert_param(IS_LL_USART_DIRECTION(USART_InitStruct->TransferDirection));
;;;280      assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
;;;281      assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));
;;;282    
;;;283      /* USART needs to be in disabled state, in order to be able to configure some bits in
;;;284         CRx registers */
;;;285      if (LL_USART_IsEnabled(USARTx) == 0U)
000006  68c0              LDR      r0,[r0,#0xc]
000008  b084              SUB      sp,sp,#0x10           ;268
00000a  460d              MOV      r5,r1                 ;268
00000c  2600              MOVS     r6,#0                 ;269
00000e  f4105f00          TST      r0,#0x2000
000012  d17d              BNE      |L4.272|
;;;286      {
;;;287        /*---------------------------- USART CR1 Configuration -----------------------
;;;288         * Configure USARTx CR1 (USART Word Length, Parity, Mode and Oversampling bits) with parameters:
;;;289         * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
;;;290         * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
;;;291         * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
;;;292         * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
;;;293         */
;;;294        MODIFY_REG(USARTx->CR1,
000014  68e9              LDR      r1,[r5,#0xc]
000016  6868              LDR      r0,[r5,#4]
000018  69aa              LDR      r2,[r5,#0x18]
00001a  4308              ORRS     r0,r0,r1
00001c  6929              LDR      r1,[r5,#0x10]
00001e  4311              ORRS     r1,r1,r2
000020  4308              ORRS     r0,r0,r1
000022  68e1              LDR      r1,[r4,#0xc]
000024  f4217103          BIC      r1,r1,#0x20c
000028  f4214114          BIC      r1,r1,#0x9400
00002c  4308              ORRS     r0,r0,r1
00002e  60e0              STR      r0,[r4,#0xc]
000030  68a8              LDR      r0,[r5,#8]
000032  6921              LDR      r1,[r4,#0x10]
000034  f4215140          BIC      r1,r1,#0x3000
000038  4308              ORRS     r0,r0,r1
00003a  6120              STR      r0,[r4,#0x10]
00003c  6968              LDR      r0,[r5,#0x14]
00003e  6961              LDR      r1,[r4,#0x14]
000040  f4217140          BIC      r1,r1,#0x300
000044  4308              ORRS     r0,r0,r1
000046  6160              STR      r0,[r4,#0x14]
;;;295                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS |
;;;296                    USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;297                   (USART_InitStruct->DataWidth | USART_InitStruct->Parity |
;;;298                    USART_InitStruct->TransferDirection | USART_InitStruct->OverSampling));
;;;299    
;;;300        /*---------------------------- USART CR2 Configuration -----------------------
;;;301         * Configure USARTx CR2 (Stop bits) with parameters:
;;;302         * - Stop Bits:          USART_CR2_STOP bits according to USART_InitStruct->StopBits value.
;;;303         * - CLKEN, CPOL, CPHA and LBCL bits are to be configured using LL_USART_ClockInit().
;;;304         */
;;;305        LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
;;;306    
;;;307        /*---------------------------- USART CR3 Configuration -----------------------
;;;308         * Configure USARTx CR3 (Hardware Flow Control) with parameters:
;;;309         * - HardwareFlowControl: USART_CR3_RTSE, USART_CR3_CTSE bits according to USART_InitStruct->HardwareFlowControl value.
;;;310         */
;;;311        LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
;;;312    
;;;313        /*---------------------------- USART BRR Configuration -----------------------
;;;314         * Retrieve Clock frequency used for USART Peripheral
;;;315         */
;;;316        LL_RCC_GetSystemClocksFreq(&rcc_clocks);
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       LL_RCC_GetSystemClocksFreq
;;;317        if (USARTx == USART1)
00004e  f1a44080          SUB      r0,r4,#0x40000000
000052  f5b03088          SUBS     r0,r0,#0x11000
000056  d019              BEQ      |L4.140|
;;;318        {
;;;319          periphclk = rcc_clocks.PCLK2_Frequency;
;;;320        }
;;;321        else if (USARTx == USART2)
000058  f1a44080          SUB      r0,r4,#0x40000000
00005c  f5b04088          SUBS     r0,r0,#0x4400
;;;322        {
;;;323          periphclk = rcc_clocks.PCLK1_Frequency;
;;;324        }
;;;325    #if defined(USART3)
;;;326        else if (USARTx == USART3)
000060  bf1c              ITT      NE
000062  f1a44080          SUBNE    r0,r4,#0x40000000
000066  f5b04090          SUBSNE   r0,r0,#0x4800
00006a  d011              BEQ      |L4.144|
;;;327        {
;;;328          periphclk = rcc_clocks.PCLK1_Frequency;
;;;329        }
;;;330    #endif /* USART3 */
;;;331    #if defined(USART6)
;;;332        else if (USARTx == USART6)
00006c  f1a44080          SUB      r0,r4,#0x40000000
000070  f5b0308a          SUBS     r0,r0,#0x11400
000074  d00a              BEQ      |L4.140|
;;;333        {
;;;334          periphclk = rcc_clocks.PCLK2_Frequency;
;;;335        }
;;;336    #endif /* USART6 */
;;;337    #if defined(UART4)
;;;338        else if (USARTx == UART4)
000076  f1a44080          SUB      r0,r4,#0x40000000
00007a  f5b04098          SUBS     r0,r0,#0x4c00
;;;339        {
;;;340          periphclk = rcc_clocks.PCLK1_Frequency;
;;;341        }
;;;342    #endif /* UART4 */
;;;343    #if defined(UART5)
;;;344        else if (USARTx == UART5)
00007e  bf1c              ITT      NE
000080  f1a44080          SUBNE    r0,r4,#0x40000000
000084  f5b040a0          SUBSNE   r0,r0,#0x5000
000088  d002              BEQ      |L4.144|
00008a  e04b              B        |L4.292|
                  |L4.140|
00008c  9803              LDR      r0,[sp,#0xc]          ;334
00008e  e000              B        |L4.146|
                  |L4.144|
;;;345        {
;;;346          periphclk = rcc_clocks.PCLK1_Frequency;
000090  9802              LDR      r0,[sp,#8]
                  |L4.146|
;;;347        }
;;;348    #endif /* UART5 */
;;;349    #if defined(UART7)
;;;350        else if (USARTx == UART7)
;;;351        {
;;;352          periphclk = rcc_clocks.PCLK1_Frequency;
;;;353        }
;;;354    #endif /* UART7 */
;;;355    #if defined(UART8)
;;;356        else if (USARTx == UART8)
;;;357        {
;;;358          periphclk = rcc_clocks.PCLK1_Frequency;
;;;359        }
;;;360    #endif /* UART8 */
;;;361    #if defined(UART9)
;;;362        else if (USARTx == UART9)
;;;363        {
;;;364          periphclk = rcc_clocks.PCLK1_Frequency;
;;;365        }
;;;366    #endif /* UART9 */
;;;367    #if defined(UART10)
;;;368        else if (USARTx == UART10)
;;;369        {
;;;370          periphclk = rcc_clocks.PCLK1_Frequency;
;;;371        }
;;;372    #endif /* UART10 */
;;;373        else
;;;374        {
;;;375          /* Nothing to do, as error code is already assigned to ERROR value */
;;;376        }
;;;377    
;;;378        /* Configure the USART Baud Rate :
;;;379           - valid baud rate value (different from 0) is required
;;;380           - Peripheral clock as returned by RCC service, should be valid (different from 0).
;;;381        */
;;;382        if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
000092  2800              CMP      r0,#0
;;;383            && (USART_InitStruct->BaudRate != 0U))
000094  bf1c              ITT      NE
000096  682b              LDRNE    r3,[r5,#0]
000098  2b00              CMPNE    r3,#0
00009a  d043              BEQ      |L4.292|
00009c  f8d5c018          LDR      r12,[r5,#0x18]        ;382
0000a0  493d              LDR      r1,|L4.408|
0000a2  f5bc4f00          CMP      r12,#0x8000           ;382
0000a6  eb000cc0          ADD      r12,r0,r0,LSL #3      ;382
;;;384        {
;;;385          status = SUCCESS;
0000aa  f04f0601          MOV      r6,#1
0000ae  f04f0232          MOV      r2,#0x32
0000b2  eb0c1000          ADD      r0,r12,r0,LSL #4
0000b6  d039              BEQ      |L4.300|
0000b8  009b              LSLS     r3,r3,#2
0000ba  fbb0fcf3          UDIV     r12,r0,r3
0000be  fba17c0c          UMULL    r7,r12,r1,r12
0000c2  fbb0f5f3          UDIV     r5,r0,r3
0000c6  ea4f1c5c          LSR      r12,r12,#5
0000ca  f06f0718          MVN      r7,#0x18
0000ce  fb0cfc07          MUL      r12,r12,r7
0000d2  eb050c8c          ADD      r12,r5,r12,LSL #2
0000d6  eb021c0c          ADD      r12,r2,r12,LSL #4
0000da  fba15c0c          UMULL    r5,r12,r1,r12
0000de  ea4f1c5c          LSR      r12,r12,#5
0000e2  f00c05f0          AND      r5,r12,#0xf0
0000e6  fbb0fcf3          UDIV     r12,r0,r3
0000ea  fba17c0c          UMULL    r7,r12,r1,r12
0000ee  ea4f1c5c          LSR      r12,r12,#5
0000f2  eb051c0c          ADD      r12,r5,r12,LSL #4
0000f6  fbb0f5f3          UDIV     r5,r0,r3
0000fa  fbb0f0f3          UDIV     r0,r0,r3
0000fe  fba13000          UMULL    r3,r0,r1,r0
000102  0940              LSRS     r0,r0,#5
000104  f06f0318          MVN      r3,#0x18
000108  4358              MULS     r0,r3,r0
00010a  eb050080          ADD      r0,r5,r0,LSL #2
00010e  e000              B        |L4.274|
                  |L4.272|
000110  e008              B        |L4.292|
                  |L4.274|
000112  eb021000          ADD      r0,r2,r0,LSL #4
000116  fba11000          UMULL    r1,r0,r1,r0
00011a  f3c01043          UBFX     r0,r0,#5,#4
00011e  4460              ADD      r0,r0,r12
000120  b280              UXTH     r0,r0
000122  60a0              STR      r0,[r4,#8]
                  |L4.292|
;;;386          LL_USART_SetBaudRate(USARTx,
;;;387                               periphclk,
;;;388                               USART_InitStruct->OverSampling,
;;;389                               USART_InitStruct->BaudRate);
;;;390    
;;;391          /* Check BRR is greater than or equal to 16d */
;;;392          assert_param(IS_LL_USART_BRR_MIN(USARTx->BRR));
;;;393    
;;;394          /* Check BRR is greater than or equal to 16d */
;;;395          assert_param(IS_LL_USART_BRR_MAX(USARTx->BRR));
;;;396        }
;;;397      }
;;;398      /* Endif (=> USART not in Disabled state => return ERROR) */
;;;399    
;;;400      return (status);
;;;401    }
000124  b004              ADD      sp,sp,#0x10
000126  4630              MOV      r0,r6                 ;400
000128  e8bd81f0          POP      {r4-r8,pc}
                  |L4.300|
00012c  005b              LSLS     r3,r3,#1
00012e  fbb0fcf3          UDIV     r12,r0,r3
000132  fba15c0c          UMULL    r5,r12,r1,r12
000136  ea4f1c5c          LSR      r12,r12,#5
00013a  ea4f150c          LSL      r5,r12,#4
00013e  fbb0fcf3          UDIV     r12,r0,r3
000142  fba18c0c          UMULL    r8,r12,r1,r12
000146  fbb0f7f3          UDIV     r7,r0,r3
00014a  ea4f1c5c          LSR      r12,r12,#5
00014e  f06f0818          MVN      r8,#0x18
000152  fb0cfc08          MUL      r12,r12,r8
000156  eb070c8c          ADD      r12,r7,r12,LSL #2
00015a  eb020ccc          ADD      r12,r2,r12,LSL #3
00015e  fba17c0c          UMULL    r7,r12,r1,r12
000162  ea4f1c5c          LSR      r12,r12,#5
000166  f00c0cf8          AND      r12,r12,#0xf8
00016a  eb050c4c          ADD      r12,r5,r12,LSL #1
00016e  fbb0f5f3          UDIV     r5,r0,r3
000172  fbb0f0f3          UDIV     r0,r0,r3
000176  fba13000          UMULL    r3,r0,r1,r0
00017a  0940              LSRS     r0,r0,#5
00017c  fb00f008          MUL      r0,r0,r8
000180  eb050080          ADD      r0,r5,r0,LSL #2
000184  eb0200c0          ADD      r0,r2,r0,LSL #3
000188  fba11000          UMULL    r1,r0,r1,r0
00018c  f3c01042          UBFX     r0,r0,#5,#3
000190  4460              ADD      r0,r0,r12
000192  b280              UXTH     r0,r0
000194  60a0              STR      r0,[r4,#8]
000196  e7c5              B        |L4.292|
;;;402    
                          ENDP

                  |L4.408|
                          DCD      0x51eb851f

                          AREA ||i.LL_USART_StructInit||, CODE, READONLY, ALIGN=1

                  LL_USART_StructInit PROC
;;;409    
;;;410    void LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;411    {
;;;412      /* Set USART_InitStruct fields to default values */
;;;413      USART_InitStruct->BaudRate            = 9600U;
;;;414      USART_InitStruct->DataWidth           = LL_USART_DATAWIDTH_8B;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
;;;415      USART_InitStruct->StopBits            = LL_USART_STOPBITS_1;
000008  6041              STR      r1,[r0,#4]
;;;416      USART_InitStruct->Parity              = LL_USART_PARITY_NONE ;
;;;417      USART_InitStruct->TransferDirection   = LL_USART_DIRECTION_TX_RX;
00000a  220c              MOVS     r2,#0xc
00000c  6081              STR      r1,[r0,#8]
00000e  e9c01203          STRD     r1,r2,[r0,#0xc]
;;;418      USART_InitStruct->HardwareFlowControl = LL_USART_HWCONTROL_NONE;
;;;419      USART_InitStruct->OverSampling        = LL_USART_OVERSAMPLING_16;
000012  6141              STR      r1,[r0,#0x14]
000014  6181              STR      r1,[r0,#0x18]
;;;420    }
000016  4770              BX       lr
;;;421    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_usart_c_f3db86c2____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_ll_usart_c_f3db86c2____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_usart_c_f3db86c2____REVSH|
#line 402
|__asm___20_stm32f4xx_ll_usart_c_f3db86c2____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_usart_c_f3db86c2____RRX|
#line 587
|__asm___20_stm32f4xx_ll_usart_c_f3db86c2____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
