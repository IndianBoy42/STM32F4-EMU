; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_sd.o --depend=stm32nes\stm32f4xx_hal_sd.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_sd.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_sd.c]
                          THUMB

                          AREA ||i.HAL_SD_Abort||, CODE, READONLY, ALIGN=1

                  HAL_SD_Abort PROC
;;;2167     */
;;;2168   HAL_StatusTypeDef HAL_SD_Abort(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;2169   {
000002  4604              MOV      r4,r0
;;;2170     HAL_SD_CardStateTypeDef CardState;
;;;2171     
;;;2172     /* DIsable All interrupts */
;;;2173     __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
000004  6800              LDR      r0,[r0,#0]
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  f421719d          BIC      r1,r1,#0x13a
00000c  63c1              STR      r1,[r0,#0x3c]
;;;2174                              SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2175     
;;;2176     /* Clear All flags */
;;;2177     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
00000e  6821              LDR      r1,[r4,#0]
000010  f24050ff          MOV      r0,#0x5ff
000014  6388              STR      r0,[r1,#0x38]
;;;2178     
;;;2179     if((hsd->hdmatx != NULL) || (hsd->hdmarx != NULL))
000016  6c20              LDR      r0,[r4,#0x40]
000018  2800              CMP      r0,#0
00001a  bf04              ITT      EQ
00001c  6be0              LDREQ    r0,[r4,#0x3c]
00001e  2800              CMPEQ    r0,#0
000020  d00e              BEQ      |L1.64|
;;;2180     {
;;;2181       /* Disable the SD DMA request */
;;;2182       hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
000022  6820              LDR      r0,[r4,#0]
000024  6ac1              LDR      r1,[r0,#0x2c]
000026  f0210108          BIC      r1,r1,#8
00002a  62c1              STR      r1,[r0,#0x2c]
;;;2183       
;;;2184       /* Abort the SD DMA Tx Stream */
;;;2185       if(hsd->hdmatx != NULL)
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  2800              CMP      r0,#0
;;;2186       {
;;;2187         HAL_DMA_Abort(hsd->hdmatx);
000030  bf18              IT       NE
000032  f7fffffe          BLNE     HAL_DMA_Abort
;;;2188       }
;;;2189       /* Abort the SD DMA Rx Stream */
;;;2190       if(hsd->hdmarx != NULL)
000036  6be0              LDR      r0,[r4,#0x3c]
000038  2800              CMP      r0,#0
;;;2191       {
;;;2192         HAL_DMA_Abort(hsd->hdmarx);
00003a  bf18              IT       NE
00003c  f7fffffe          BLNE     HAL_DMA_Abort
                  |L1.64|
;;;2193       }
;;;2194     }
;;;2195     
;;;2196     hsd->State = HAL_SD_STATE_READY;
000040  2001              MOVS     r0,#1
000042  f8840034          STRB     r0,[r4,#0x34]
;;;2197     CardState = HAL_SD_GetCardState(hsd);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_SD_GetCardState
;;;2198     if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
00004c  2806              CMP      r0,#6
00004e  bf18              IT       NE
000050  2805              CMPNE    r0,#5
000052  d103              BNE      |L1.92|
;;;2199     {
;;;2200       hsd->ErrorCode = SDMMC_CmdStopTransfer(hsd->Instance);
000054  6820              LDR      r0,[r4,#0]
000056  f7fffffe          BL       SDMMC_CmdStopTransfer
00005a  63a0              STR      r0,[r4,#0x38]
                  |L1.92|
;;;2201     }
;;;2202     if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
00005c  6ba0              LDR      r0,[r4,#0x38]
00005e  2800              CMP      r0,#0
;;;2203     {
;;;2204       return HAL_ERROR;
000060  bf18              IT       NE
000062  2001              MOVNE    r0,#1
;;;2205     }
;;;2206     return HAL_OK;
;;;2207   }
000064  bd10              POP      {r4,pc}
;;;2208   
                          ENDP


                          AREA ||i.HAL_SD_AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_AbortCallback PROC
;;;1693     */
;;;1694   __weak void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1695   {
;;;1696     /* Prevent unused argument(s) compilation warning */
;;;1697     UNUSED(hsd);
;;;1698    
;;;1699     /* NOTE : This function should not be modified, when the callback is needed,
;;;1700               the HAL_SD_ErrorCallback can be implemented in the user file
;;;1701      */ 
;;;1702   }
;;;1703   
                          ENDP


                          AREA ||i.HAL_SD_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SD_Abort_IT PROC
;;;2214     */
;;;2215   HAL_StatusTypeDef HAL_SD_Abort_IT(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2216   {
000002  4604              MOV      r4,r0
;;;2217     HAL_SD_CardStateTypeDef CardState;
;;;2218       
;;;2219     /* DIsable All interrupts */
;;;2220     __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
000004  6800              LDR      r0,[r0,#0]
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  f421719d          BIC      r1,r1,#0x13a
00000c  63c1              STR      r1,[r0,#0x3c]
;;;2221                              SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2222     
;;;2223     /* Clear All flags */
;;;2224     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
00000e  6821              LDR      r1,[r4,#0]
000010  f24050ff          MOV      r0,#0x5ff
000014  6388              STR      r0,[r1,#0x38]
;;;2225     
;;;2226     if((hsd->hdmatx != NULL) || (hsd->hdmarx != NULL))
000016  6c20              LDR      r0,[r4,#0x40]
000018  2800              CMP      r0,#0
00001a  bf04              ITT      EQ
00001c  6be0              LDREQ    r0,[r4,#0x3c]
00001e  2800              CMPEQ    r0,#0
000020  d020              BEQ      |L3.100|
;;;2227     {
;;;2228       /* Disable the SD DMA request */
;;;2229       hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
000022  6820              LDR      r0,[r4,#0]
000024  6ac1              LDR      r1,[r0,#0x2c]
000026  f0210108          BIC      r1,r1,#8
00002a  62c1              STR      r1,[r0,#0x2c]
;;;2230       
;;;2231       /* Abort the SD DMA Tx Stream */
;;;2232       if(hsd->hdmatx != NULL)
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  f04f0500          MOV      r5,#0
000032  b138              CBZ      r0,|L3.68|
;;;2233       {
;;;2234         hsd->hdmatx->XferAbortCallback =  SD_DMATxAbort;
000034  4917              LDR      r1,|L3.148|
;;;2235         if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
000036  6501              STR      r1,[r0,#0x50]
000038  6c20              LDR      r0,[r4,#0x40]
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  2800              CMP      r0,#0
;;;2236         {
;;;2237           hsd->hdmatx = NULL;
000040  bf18              IT       NE
000042  6425              STRNE    r5,[r4,#0x40]
                  |L3.68|
;;;2238         }
;;;2239       }
;;;2240       /* Abort the SD DMA Rx Stream */
;;;2241       if(hsd->hdmarx != NULL)
000044  6be0              LDR      r0,[r4,#0x3c]
000046  b138              CBZ      r0,|L3.88|
;;;2242       {
;;;2243         hsd->hdmarx->XferAbortCallback =  SD_DMARxAbort;
000048  4913              LDR      r1,|L3.152|
;;;2244         if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
00004a  6501              STR      r1,[r0,#0x50]
00004c  6be0              LDR      r0,[r4,#0x3c]
00004e  f7fffffe          BL       HAL_DMA_Abort_IT
000052  2800              CMP      r0,#0
;;;2245         {
;;;2246           hsd->hdmarx = NULL;
000054  bf18              IT       NE
000056  63e5              STRNE    r5,[r4,#0x3c]
                  |L3.88|
;;;2247         }
;;;2248       }
;;;2249     }
;;;2250     
;;;2251     /* No transfer ongoing on both DMA channels*/
;;;2252     if((hsd->hdmatx == NULL) && (hsd->hdmarx == NULL))
000058  6c20              LDR      r0,[r4,#0x40]
00005a  2800              CMP      r0,#0
00005c  bf04              ITT      EQ
00005e  6be0              LDREQ    r0,[r4,#0x3c]
000060  2800              CMPEQ    r0,#0
000062  d115              BNE      |L3.144|
                  |L3.100|
;;;2253     {
;;;2254       CardState = HAL_SD_GetCardState(hsd);
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       HAL_SD_GetCardState
;;;2255       hsd->State = HAL_SD_STATE_READY;
00006a  2101              MOVS     r1,#1
00006c  f8841034          STRB     r1,[r4,#0x34]
;;;2256       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
000070  2806              CMP      r0,#6
000072  bf18              IT       NE
000074  2805              CMPNE    r0,#5
000076  d103              BNE      |L3.128|
;;;2257       {
;;;2258         hsd->ErrorCode = SDMMC_CmdStopTransfer(hsd->Instance);
000078  6820              LDR      r0,[r4,#0]
00007a  f7fffffe          BL       SDMMC_CmdStopTransfer
00007e  63a0              STR      r0,[r4,#0x38]
                  |L3.128|
;;;2259       }
;;;2260       if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
000080  6ba0              LDR      r0,[r4,#0x38]
000082  2800              CMP      r0,#0
;;;2261       {
;;;2262         return HAL_ERROR;
000084  bf1c              ITT      NE
000086  2001              MOVNE    r0,#1
;;;2263       }
;;;2264       else
;;;2265       {
;;;2266         HAL_SD_AbortCallback(hsd);
;;;2267       }
;;;2268     }
;;;2269     
;;;2270     return HAL_OK;
;;;2271   }
000088  bd70              POPNE    {r4-r6,pc}
00008a  4620              MOV      r0,r4                 ;2266
00008c  f7fffffe          BL       HAL_SD_AbortCallback
                  |L3.144|
000090  2000              MOVS     r0,#0                 ;2270
000092  bd70              POP      {r4-r6,pc}
;;;2272   
                          ENDP

                  |L3.148|
                          DCD      SD_DMATxAbort
                  |L3.152|
                          DCD      SD_DMARxAbort

                          AREA ||i.HAL_SD_ConfigWideBusOperation||, CODE, READONLY, ALIGN=1

                  HAL_SD_ConfigWideBusOperation PROC
;;;2072     */
;;;2073   HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2074   {
000004  4604              MOV      r4,r0
000006  b084              SUB      sp,sp,#0x10
;;;2075     SDIO_InitTypeDef Init;
;;;2076     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;2077     
;;;2078     /* Check the parameters */
;;;2079     assert_param(IS_SDIO_BUS_WIDE(WideMode));
;;;2080     
;;;2081     /* Chnage Satte */
;;;2082     hsd->State = HAL_SD_STATE_BUSY;
000008  2003              MOVS     r0,#3
00000a  460d              MOV      r5,r1                 ;2074
00000c  f8840034          STRB     r0,[r4,#0x34]
;;;2083     
;;;2084     if(hsd->SdCard.CardType != CARD_SECURED) 
000010  6c60              LDR      r0,[r4,#0x44]
000012  2803              CMP      r0,#3
000014  d05d              BEQ      |L4.210|
;;;2085     {
;;;2086       if(WideMode == SDIO_BUS_WIDE_8B)
000016  f5b55f80          CMP      r5,#0x1000
;;;2087       {
;;;2088         hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
00001a  bf04              ITT      EQ
00001c  6ba0              LDREQ    r0,[r4,#0x38]
00001e  f0405080          ORREQ    r0,r0,#0x10000000
000022  d032              BEQ      |L4.138|
000024  2600              MOVS     r6,#0                 ;2086
000026  f44f6800          MOV      r8,#0x800             ;2074
00002a  f04f6780          MOV      r7,#0x4000000         ;2074
;;;2089       }
;;;2090       else if(WideMode == SDIO_BUS_WIDE_4B)
00002e  f5b56f00          CMP      r5,#0x800
000032  d006              BEQ      |L4.66|
;;;2091       {
;;;2092         errorstate = SD_WideBus_Enable(hsd);
;;;2093         
;;;2094         hsd->ErrorCode |= errorstate;
;;;2095       }
;;;2096       else if(WideMode == SDIO_BUS_WIDE_1B)
000034  2d00              CMP      r5,#0
;;;2097       {
;;;2098         errorstate = SD_WideBus_Disable(hsd);
;;;2099         
;;;2100         hsd->ErrorCode |= errorstate;
;;;2101       }
;;;2102       else
;;;2103       {
;;;2104         /* WideMode is not a valid argument*/
;;;2105         hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000036  bf1c              ITT      NE
000038  6ba0              LDRNE    r0,[r4,#0x38]
00003a  f0406000          ORRNE    r0,r0,#0x8000000
00003e  d026              BEQ      |L4.142|
000040  e023              B        |L4.138|
                  |L4.66|
000042  9600              STR      r6,[sp,#0]            ;2096
000044  9601              STR      r6,[sp,#4]            ;2096
000046  2100              MOVS     r1,#0                 ;2096
000048  6820              LDR      r0,[r4,#0]            ;2096
00004a  f7fffffe          BL       SDIO_GetResponse
00004e  f0107f00          TST      r0,#0x2000000         ;2096
000052  d001              BEQ      |L4.88|
                  |L4.84|
000054  4640              MOV      r0,r8                 ;2096
000056  e039              B        |L4.204|
                  |L4.88|
000058  4669              MOV      r1,sp                 ;2096
00005a  4620              MOV      r0,r4                 ;2096
00005c  f7fffffe          BL       SD_FindSCR
000060  bba0              CBNZ     r0,|L4.204|
000062  9801              LDR      r0,[sp,#4]            ;2096
000064  f4102f80          TST      r0,#0x40000           ;2096
000068  d00d              BEQ      |L4.134|
00006a  f8b40050          LDRH     r0,[r4,#0x50]         ;2096
00006e  0401              LSLS     r1,r0,#16             ;2096
000070  6820              LDR      r0,[r4,#0]            ;2096
000072  f7fffffe          BL       SDMMC_CmdAppCommand
000076  bb48              CBNZ     r0,|L4.204|
000078  2102              MOVS     r1,#2                 ;2096
00007a  6820              LDR      r0,[r4,#0]            ;2096
00007c  f7fffffe          BL       SDMMC_CmdBusWidth
000080  bb20              CBNZ     r0,|L4.204|
                  |L4.130|
000082  4630              MOV      r0,r6                 ;2096
000084  e022              B        |L4.204|
                  |L4.134|
000086  4638              MOV      r0,r7                 ;2096
000088  e020              B        |L4.204|
                  |L4.138|
00008a  63a0              STR      r0,[r4,#0x38]         ;2094
00008c  e025              B        |L4.218|
                  |L4.142|
00008e  9600              STR      r6,[sp,#0]            ;2094
000090  9601              STR      r6,[sp,#4]            ;2094
000092  2100              MOVS     r1,#0                 ;2094
000094  6820              LDR      r0,[r4,#0]            ;2094
000096  f7fffffe          BL       SDIO_GetResponse
00009a  f0107f00          TST      r0,#0x2000000         ;2094
00009e  d1d9              BNE      |L4.84|
0000a0  4669              MOV      r1,sp                 ;2094
0000a2  4620              MOV      r0,r4                 ;2094
0000a4  f7fffffe          BL       SD_FindSCR
0000a8  b980              CBNZ     r0,|L4.204|
0000aa  9801              LDR      r0,[sp,#4]            ;2094
0000ac  f4103f80          TST      r0,#0x10000           ;2094
0000b0  d0e9              BEQ      |L4.134|
0000b2  f8b40050          LDRH     r0,[r4,#0x50]         ;2094
0000b6  0401              LSLS     r1,r0,#16             ;2094
0000b8  6820              LDR      r0,[r4,#0]            ;2094
0000ba  f7fffffe          BL       SDMMC_CmdAppCommand
0000be  b928              CBNZ     r0,|L4.204|
0000c0  2100              MOVS     r1,#0                 ;2094
0000c2  6820              LDR      r0,[r4,#0]            ;2094
0000c4  f7fffffe          BL       SDMMC_CmdBusWidth
0000c8  2800              CMP      r0,#0                 ;2094
0000ca  d0da              BEQ      |L4.130|
                  |L4.204|
0000cc  6ba1              LDR      r1,[r4,#0x38]         ;2100
0000ce  4308              ORRS     r0,r0,r1              ;2100
0000d0  e7db              B        |L4.138|
                  |L4.210|
;;;2106       }
;;;2107     }  
;;;2108     else
;;;2109     {
;;;2110       /* MMC Card does not support this feature */
;;;2111       hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
0000d2  6ba0              LDR      r0,[r4,#0x38]
0000d4  f0405080          ORR      r0,r0,#0x10000000
0000d8  63a0              STR      r0,[r4,#0x38]
                  |L4.218|
;;;2112     }
;;;2113     
;;;2114     if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
0000da  6ba0              LDR      r0,[r4,#0x38]
;;;2115     {
;;;2116       /* Clear all the static flags */
;;;2117       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2118       hsd->State = HAL_SD_STATE_READY;
0000dc  2601              MOVS     r6,#1
0000de  b148              CBZ      r0,|L4.244|
0000e0  6821              LDR      r1,[r4,#0]            ;2117
0000e2  f24050ff          MOV      r0,#0x5ff             ;2117
0000e6  6388              STR      r0,[r1,#0x38]         ;2117
0000e8  f8846034          STRB     r6,[r4,#0x34]
;;;2119       return HAL_ERROR;
;;;2120     }
;;;2121     else
;;;2122     {
;;;2123       /* Configure the SDIO peripheral */
;;;2124       Init.ClockEdge           = hsd->Init.ClockEdge;
;;;2125       Init.ClockBypass         = hsd->Init.ClockBypass;
;;;2126       Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
;;;2127       Init.BusWide             = WideMode;
;;;2128       Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
;;;2129       Init.ClockDiv            = hsd->Init.ClockDiv;
;;;2130       SDIO_Init(hsd->Instance, Init);
;;;2131     }
;;;2132   
;;;2133     /* Change State */
;;;2134     hsd->State = HAL_SD_STATE_READY;
;;;2135     
;;;2136     return HAL_OK;
;;;2137   }
0000ec  b004              ADD      sp,sp,#0x10
0000ee  2001              MOVS     r0,#1                 ;2119
0000f0  e8bd81f0          POP      {r4-r8,pc}
                  |L4.244|
0000f4  e9d40c05          LDRD     r0,r12,[r4,#0x14]     ;2126
0000f8  e9d41201          LDRD     r1,r2,[r4,#4]         ;2126
0000fc  68e3              LDR      r3,[r4,#0xc]          ;2130
0000fe  e9cd5000          STRD     r5,r0,[sp,#0]         ;2130
000102  f8cdc008          STR      r12,[sp,#8]           ;2130
000106  6820              LDR      r0,[r4,#0]            ;2130
000108  f7fffffe          BL       SDIO_Init
00010c  f8846034          STRB     r6,[r4,#0x34]         ;2134
000110  b004              ADD      sp,sp,#0x10
000112  2000              MOVS     r0,#0                 ;2136
000114  e8bd81f0          POP      {r4-r8,pc}
;;;2138   
                          ENDP


                          AREA ||i.HAL_SD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_DeInit PROC
;;;410      */
;;;411    HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
000000  2800              CMP      r0,#0
;;;412    {
;;;413      /* Check the SD handle allocation */
;;;414      if(hsd == NULL)
;;;415      {
;;;416        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;417      }
;;;418      
;;;419      /* Check the parameters */
;;;420      assert_param(IS_SDIO_ALL_INSTANCE(hsd->Instance));
;;;421    
;;;422      hsd->State = HAL_SD_STATE_BUSY;
;;;423      
;;;424      /* Set SD power state to off */ 
;;;425      SD_PowerOFF(hsd);
;;;426      
;;;427      /* De-Initialize the MSP layer */
;;;428      HAL_SD_MspDeInit(hsd);
;;;429      
;;;430      hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;431      hsd->State = HAL_SD_STATE_RESET;
;;;432      
;;;433      return HAL_OK;
;;;434    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;412
00000a  4604              MOV      r4,r0                 ;412
00000c  2003              MOVS     r0,#3                 ;422
00000e  f8840034          STRB     r0,[r4,#0x34]         ;422
000012  6820              LDR      r0,[r4,#0]            ;422
000014  f7fffffe          BL       SDIO_PowerState_OFF
000018  4620              MOV      r0,r4                 ;428
00001a  f7fffffe          BL       HAL_SD_MspDeInit
00001e  2000              MOVS     r0,#0                 ;430
000020  63a0              STR      r0,[r4,#0x38]         ;430
000022  f8840034          STRB     r0,[r4,#0x34]         ;431
000026  bd10              POP      {r4,pc}
;;;435    
                          ENDP


                          AREA ||i.HAL_SD_Erase||, CODE, READONLY, ALIGN=1

                  HAL_SD_Erase PROC
;;;1305     */
;;;1306   HAL_StatusTypeDef HAL_SD_Erase(SD_HandleTypeDef *hsd, uint32_t BlockStartAdd, uint32_t BlockEndAdd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1307   {
000004  4604              MOV      r4,r0
;;;1308     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;1309     
;;;1310     if(hsd->State == HAL_SD_STATE_READY)
000006  f8900034          LDRB     r0,[r0,#0x34]
00000a  4615              MOV      r5,r2                 ;1307
00000c  4688              MOV      r8,r1                 ;1307
00000e  2801              CMP      r0,#1
;;;1311     {
;;;1312       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;1313       
;;;1314       if(BlockEndAdd < BlockStartAdd)
;;;1315       {
;;;1316         hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;1317         return HAL_ERROR;
;;;1318       }
;;;1319       
;;;1320       if(BlockEndAdd > (hsd->SdCard.LogBlockNbr))
;;;1321       {
;;;1322         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1323         return HAL_ERROR;
;;;1324       }
;;;1325       
;;;1326       hsd->State = HAL_SD_STATE_BUSY;
;;;1327       
;;;1328       /* Check if the card command class supports erase command */
;;;1329       if(((hsd->SdCard.Class) & SDIO_CCCC_ERASE) == 0U)
;;;1330       {
;;;1331         /* Clear all the static flags */
;;;1332         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1333         hsd->ErrorCode |= HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
;;;1334         hsd->State = HAL_SD_STATE_READY;
;;;1335         return HAL_ERROR;
;;;1336       }
;;;1337       
;;;1338       if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
;;;1339       {
;;;1340         /* Clear all the static flags */
;;;1341         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;1342         hsd->ErrorCode |= HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
;;;1343         hsd->State = HAL_SD_STATE_READY;
;;;1344         return HAL_ERROR;
;;;1345       }
;;;1346       
;;;1347       /* Get start and end block for high capacity cards */
;;;1348       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1349       {
;;;1350         BlockStartAdd *= 512U;
;;;1351         BlockEndAdd   *= 512U;
;;;1352       }
;;;1353       
;;;1354       /* According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
;;;1355       if(hsd->SdCard.CardType != CARD_SECURED)
;;;1356       {
;;;1357         /* Send CMD32 SD_ERASE_GRP_START with argument as addr  */
;;;1358         errorstate = SDMMC_CmdSDEraseStartAdd(hsd->Instance, BlockStartAdd);
;;;1359         if(errorstate != HAL_SD_ERROR_NONE)
;;;1360         {
;;;1361           /* Clear all the static flags */
;;;1362           __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1363           hsd->ErrorCode |= errorstate;
;;;1364           hsd->State = HAL_SD_STATE_READY;
;;;1365           return HAL_ERROR;
;;;1366         }
;;;1367         
;;;1368         /* Send CMD33 SD_ERASE_GRP_END with argument as addr  */
;;;1369         errorstate = SDMMC_CmdSDEraseEndAdd(hsd->Instance, BlockEndAdd);
;;;1370         if(errorstate != HAL_SD_ERROR_NONE)
;;;1371         {
;;;1372           /* Clear all the static flags */
;;;1373           __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1374           hsd->ErrorCode |= errorstate;
;;;1375           hsd->State = HAL_SD_STATE_READY;
;;;1376           return HAL_ERROR;
;;;1377         }
;;;1378       }
;;;1379       
;;;1380       /* Send CMD38 ERASE */
;;;1381       errorstate = SDMMC_CmdErase(hsd->Instance);
;;;1382       if(errorstate != HAL_SD_ERROR_NONE)
;;;1383       {
;;;1384         /* Clear all the static flags */
;;;1385         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1386         hsd->ErrorCode |= errorstate;
;;;1387         hsd->State = HAL_SD_STATE_READY;
;;;1388         return HAL_ERROR;
;;;1389       }
;;;1390       
;;;1391       hsd->State = HAL_SD_STATE_READY;
;;;1392       
;;;1393       return HAL_OK;
;;;1394     }
;;;1395     else
;;;1396     {
;;;1397       return HAL_BUSY;
000010  bf1c              ITT      NE
000012  2002              MOVNE    r0,#2
;;;1398     }
;;;1399   }
000014  e8bd81f0          POPNE    {r4-r8,pc}
000018  2000              MOVS     r0,#0                 ;1312
00001a  63a0              STR      r0,[r4,#0x38]         ;1312
00001c  4545              CMP      r5,r8                 ;1314
00001e  bf3c              ITT      CC                    ;1316
000020  6ba0              LDRCC    r0,[r4,#0x38]         ;1316
000022  f0406000          ORRCC    r0,r0,#0x8000000      ;1316
000026  d306              BCC      |L6.54|
000028  6de0              LDR      r0,[r4,#0x5c]         ;1320
00002a  42a8              CMP      r0,r5                 ;1320
00002c  bf3c              ITT      CC                    ;1322
00002e  6ba0              LDRCC    r0,[r4,#0x38]         ;1322
000030  f0407000          ORRCC    r0,r0,#0x2000000      ;1322
000034  d201              BCS      |L6.58|
                  |L6.54|
000036  63a0              STR      r0,[r4,#0x38]         ;1322
000038  e01a              B        |L6.112|
                  |L6.58|
00003a  2003              MOVS     r0,#3                 ;1326
00003c  f8840034          STRB     r0,[r4,#0x34]         ;1326
000040  f894004c          LDRB     r0,[r4,#0x4c]         ;1329
000044  f04f0601          MOV      r6,#1                 ;1317
000048  f0100f20          TST      r0,#0x20              ;1329
00004c  6820              LDR      r0,[r4,#0]            ;1329
00004e  f24057ff          MOV      r7,#0x5ff             ;1332
000052  d010              BEQ      |L6.118|
000054  2100              MOVS     r1,#0                 ;1338
000056  f7fffffe          BL       SDIO_GetResponse
00005a  f0107f00          TST      r0,#0x2000000         ;1338
00005e  d014              BEQ      |L6.138|
000060  6820              LDR      r0,[r4,#0]            ;1341
000062  6387              STR      r7,[r0,#0x38]         ;1341
000064  6ba0              LDR      r0,[r4,#0x38]         ;1342
000066  f4406000          ORR      r0,r0,#0x800          ;1342
00006a  63a0              STR      r0,[r4,#0x38]         ;1342
00006c  f8846034          STRB     r6,[r4,#0x34]         ;1343
                  |L6.112|
000070  2001              MOVS     r0,#1                 ;1344
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L6.118|
000076  6387              STR      r7,[r0,#0x38]         ;1332
000078  6ba0              LDR      r0,[r4,#0x38]         ;1333
00007a  f0406080          ORR      r0,r0,#0x4000000      ;1333
00007e  63a0              STR      r0,[r4,#0x38]         ;1333
000080  f8846034          STRB     r6,[r4,#0x34]         ;1334
000084  2001              MOVS     r0,#1                 ;1335
000086  e8bd81f0          POP      {r4-r8,pc}
                  |L6.138|
00008a  6c60              LDR      r0,[r4,#0x44]         ;1348
00008c  2801              CMP      r0,#1                 ;1348
00008e  d004              BEQ      |L6.154|
000090  026d              LSLS     r5,r5,#9              ;1351
000092  ea4f2848          LSL      r8,r8,#9              ;1350
000096  2803              CMP      r0,#3                 ;1355
000098  d009              BEQ      |L6.174|
                  |L6.154|
00009a  4641              MOV      r1,r8                 ;1358
00009c  6820              LDR      r0,[r4,#0]            ;1358
00009e  f7fffffe          BL       SDMMC_CmdSDEraseStartAdd
0000a2  b968              CBNZ     r0,|L6.192|
0000a4  4629              MOV      r1,r5                 ;1369
0000a6  6820              LDR      r0,[r4,#0]            ;1369
0000a8  f7fffffe          BL       SDMMC_CmdSDEraseEndAdd
0000ac  b940              CBNZ     r0,|L6.192|
                  |L6.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1381
0000b0  f7fffffe          BL       SDMMC_CmdErase
0000b4  2800              CMP      r0,#0                 ;1382
0000b6  bf04              ITT      EQ                    ;1391
0000b8  f8846034          STRBEQ   r6,[r4,#0x34]         ;1391
0000bc  e8bd81f0          POPEQ    {r4-r8,pc}
                  |L6.192|
0000c0  6821              LDR      r1,[r4,#0]            ;1385
0000c2  638f              STR      r7,[r1,#0x38]         ;1385
0000c4  6ba1              LDR      r1,[r4,#0x38]         ;1386
0000c6  4308              ORRS     r0,r0,r1              ;1386
0000c8  63a0              STR      r0,[r4,#0x38]         ;1386
0000ca  f8846034          STRB     r6,[r4,#0x34]         ;1387
0000ce  e7cf              B        |L6.112|
;;;1400   
                          ENDP


                          AREA ||i.HAL_SD_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_ErrorCallback PROC
;;;1678     */
;;;1679   __weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1680   {
;;;1681     /* Prevent unused argument(s) compilation warning */
;;;1682     UNUSED(hsd);
;;;1683    
;;;1684     /* NOTE : This function should not be modified, when the callback is needed,
;;;1685               the HAL_SD_ErrorCallback can be implemented in the user file
;;;1686      */ 
;;;1687   }
;;;1688   
                          ENDP


                          AREA ||i.HAL_SD_GetCardCID||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardCID PROC
;;;1731     */
;;;1732   HAL_StatusTypeDef HAL_SD_GetCardCID(SD_HandleTypeDef *hsd, HAL_SD_CardCIDTypeDef *pCID)
000000  6f42              LDR      r2,[r0,#0x74]
;;;1733   {
;;;1734     uint32_t tmp = 0U;
;;;1735     
;;;1736     /* Byte 0 */
;;;1737     tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
000002  0e12              LSRS     r2,r2,#24
;;;1738     pCID->ManufacturerID = tmp;
000004  700a              STRB     r2,[r1,#0]
;;;1739     
;;;1740     /* Byte 1 */
;;;1741     tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
000006  6f42              LDR      r2,[r0,#0x74]
;;;1742     pCID->OEM_AppliID = tmp << 8U;
000008  f64f73ff          MOV      r3,#0xffff
00000c  0c12              LSRS     r2,r2,#16             ;1741
00000e  ea032202          AND      r2,r3,r2,LSL #8
000012  804a              STRH     r2,[r1,#2]
;;;1743     
;;;1744     /* Byte 2 */
;;;1745     tmp = (uint8_t)((hsd->CID[0U] & 0x000000FF00U) >> 8U);
000014  f8b02074          LDRH     r2,[r0,#0x74]
;;;1746     pCID->OEM_AppliID |= tmp;
000018  884b              LDRH     r3,[r1,#2]
00001a  f3c22207          UBFX     r2,r2,#8,#8           ;1745
00001e  431a              ORRS     r2,r2,r3
000020  804a              STRH     r2,[r1,#2]
;;;1747     
;;;1748     /* Byte 3 */
;;;1749     tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
000022  f8902074          LDRB     r2,[r0,#0x74]
;;;1750     pCID->ProdName1 = tmp << 24U;
000026  0612              LSLS     r2,r2,#24
000028  604a              STR      r2,[r1,#4]
;;;1751     
;;;1752     /* Byte 4 */
;;;1753     tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
00002a  6f82              LDR      r2,[r0,#0x78]
;;;1754     pCID->ProdName1 |= tmp << 16;
00002c  684b              LDR      r3,[r1,#4]
00002e  0e12              LSRS     r2,r2,#24             ;1753
000030  ea434202          ORR      r2,r3,r2,LSL #16
000034  604a              STR      r2,[r1,#4]
;;;1755     
;;;1756     /* Byte 5 */
;;;1757     tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
000036  6f82              LDR      r2,[r0,#0x78]
;;;1758     pCID->ProdName1 |= tmp << 8U;
000038  684b              LDR      r3,[r1,#4]
00003a  f3c24207          UBFX     r2,r2,#16,#8          ;1757
00003e  ea432202          ORR      r2,r3,r2,LSL #8
000042  604a              STR      r2,[r1,#4]
;;;1759     
;;;1760     /* Byte 6 */
;;;1761     tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
000044  f8b02078          LDRH     r2,[r0,#0x78]
;;;1762     pCID->ProdName1 |= tmp;
000048  684b              LDR      r3,[r1,#4]
00004a  f3c22207          UBFX     r2,r2,#8,#8           ;1761
00004e  431a              ORRS     r2,r2,r3
000050  604a              STR      r2,[r1,#4]
;;;1763     
;;;1764     /* Byte 7 */
;;;1765     tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
000052  f8902078          LDRB     r2,[r0,#0x78]
;;;1766     pCID->ProdName2 = tmp;
000056  720a              STRB     r2,[r1,#8]
;;;1767     
;;;1768     /* Byte 8 */
;;;1769     tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
000058  6fc2              LDR      r2,[r0,#0x7c]
00005a  0e12              LSRS     r2,r2,#24
;;;1770     pCID->ProdRev = tmp;
00005c  724a              STRB     r2,[r1,#9]
;;;1771     
;;;1772     /* Byte 9 */
;;;1773     tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
00005e  6fc2              LDR      r2,[r0,#0x7c]
000060  0c12              LSRS     r2,r2,#16
;;;1774     pCID->ProdSN = tmp << 24U;
000062  0612              LSLS     r2,r2,#24
000064  60ca              STR      r2,[r1,#0xc]
;;;1775     
;;;1776     /* Byte 10 */
;;;1777     tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
000066  f8b0207c          LDRH     r2,[r0,#0x7c]
;;;1778     pCID->ProdSN |= tmp << 16U;
00006a  68cb              LDR      r3,[r1,#0xc]
00006c  f3c22207          UBFX     r2,r2,#8,#8           ;1777
000070  ea434202          ORR      r2,r3,r2,LSL #16
000074  60ca              STR      r2,[r1,#0xc]
;;;1779     
;;;1780     /* Byte 11 */
;;;1781     tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
000076  f890207c          LDRB     r2,[r0,#0x7c]
;;;1782     pCID->ProdSN |= tmp << 8U;
00007a  68cb              LDR      r3,[r1,#0xc]
00007c  ea432202          ORR      r2,r3,r2,LSL #8
000080  60ca              STR      r2,[r1,#0xc]
;;;1783     
;;;1784     /* Byte 12 */
;;;1785     tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
;;;1786     pCID->ProdSN |= tmp;
000082  f8d02080          LDR      r2,[r0,#0x80]
000086  68cb              LDR      r3,[r1,#0xc]
000088  ea436212          ORR      r2,r3,r2,LSR #24
00008c  60ca              STR      r2,[r1,#0xc]
;;;1787     
;;;1788     /* Byte 13 */
;;;1789     tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
00008e  f8d02080          LDR      r2,[r0,#0x80]
;;;1790     pCID->Reserved1   |= (tmp & 0xF0U) >> 4U;
000092  7c0b              LDRB     r3,[r1,#0x10]
000094  f3c24207          UBFX     r2,r2,#16,#8          ;1789
000098  ea431312          ORR      r3,r3,r2,LSR #4
00009c  740b              STRB     r3,[r1,#0x10]
;;;1791     pCID->ManufactDate = (tmp & 0x0FU) << 8U;
00009e  0712              LSLS     r2,r2,#28
0000a0  0d12              LSRS     r2,r2,#20
0000a2  824a              STRH     r2,[r1,#0x12]
;;;1792     
;;;1793     /* Byte 14 */
;;;1794     tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
0000a4  f8b02080          LDRH     r2,[r0,#0x80]
;;;1795     pCID->ManufactDate |= tmp;
0000a8  8a4b              LDRH     r3,[r1,#0x12]
0000aa  f3c22207          UBFX     r2,r2,#8,#8           ;1794
0000ae  431a              ORRS     r2,r2,r3
0000b0  824a              STRH     r2,[r1,#0x12]
;;;1796     
;;;1797     /* Byte 15 */
;;;1798     tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
0000b2  f8900080          LDRB     r0,[r0,#0x80]
;;;1799     pCID->CID_CRC   = (tmp & 0xFEU) >> 1U;
0000b6  0840              LSRS     r0,r0,#1
0000b8  7508              STRB     r0,[r1,#0x14]
;;;1800     pCID->Reserved2 = 1U;
0000ba  2001              MOVS     r0,#1
0000bc  7548              STRB     r0,[r1,#0x15]
;;;1801   
;;;1802     return HAL_OK;
0000be  2000              MOVS     r0,#0
;;;1803   }
0000c0  4770              BX       lr
;;;1804   
                          ENDP


                          AREA ||i.HAL_SD_GetCardCSD||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardCSD PROC
;;;1812     */
;;;1813   HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
000000  b470              PUSH     {r4-r6}
;;;1814   {
;;;1815     uint32_t tmp = 0U;
;;;1816     
;;;1817     /* Byte 0 */
;;;1818     tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
000002  6e42              LDR      r2,[r0,#0x64]
000004  0e12              LSRS     r2,r2,#24
;;;1819     pCSD->CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
000006  0993              LSRS     r3,r2,#6
000008  700b              STRB     r3,[r1,#0]
;;;1820     pCSD->SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
00000a  f3c20383          UBFX     r3,r2,#2,#4
00000e  704b              STRB     r3,[r1,#1]
;;;1821     pCSD->Reserved1      = tmp & 0x03U;
000010  f0020203          AND      r2,r2,#3
000014  708a              STRB     r2,[r1,#2]
;;;1822     
;;;1823     /* Byte 1 */
;;;1824     tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
000016  6e42              LDR      r2,[r0,#0x64]
000018  0c12              LSRS     r2,r2,#16
;;;1825     pCSD->TAAC = (uint8_t)tmp;
00001a  70ca              STRB     r2,[r1,#3]
;;;1826     
;;;1827     /* Byte 2 */
;;;1828     tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
00001c  f8b02064          LDRH     r2,[r0,#0x64]
000020  0a12              LSRS     r2,r2,#8
;;;1829     pCSD->NSAC = (uint8_t)tmp;
000022  710a              STRB     r2,[r1,#4]
;;;1830     
;;;1831     /* Byte 3 */
;;;1832     tmp = hsd->CSD[0U] & 0x000000FFU;
000024  f8902064          LDRB     r2,[r0,#0x64]
;;;1833     pCSD->MaxBusClkFrec = (uint8_t)tmp;
000028  714a              STRB     r2,[r1,#5]
;;;1834     
;;;1835     /* Byte 4 */
;;;1836     tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
00002a  6e82              LDR      r2,[r0,#0x68]
;;;1837     pCSD->CardComdClasses = (uint16_t)(tmp << 4U);
00002c  f64f73ff          MOV      r3,#0xffff
000030  0e12              LSRS     r2,r2,#24             ;1836
000032  ea031202          AND      r2,r3,r2,LSL #4
000036  80ca              STRH     r2,[r1,#6]
;;;1838     
;;;1839     /* Byte 5 */
;;;1840     tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
000038  6e82              LDR      r2,[r0,#0x68]
;;;1841     pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0U) >> 4U);
00003a  88cb              LDRH     r3,[r1,#6]
00003c  f3c24207          UBFX     r2,r2,#16,#8          ;1840
000040  ea431312          ORR      r3,r3,r2,LSR #4
000044  80cb              STRH     r3,[r1,#6]
;;;1842     pCSD->RdBlockLen       = (uint8_t)(tmp & 0x0FU);
000046  f002020f          AND      r2,r2,#0xf
00004a  720a              STRB     r2,[r1,#8]
;;;1843     
;;;1844     /* Byte 6 */
;;;1845     tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
00004c  f8b02068          LDRH     r2,[r0,#0x68]
000050  f3c22207          UBFX     r2,r2,#8,#8
;;;1846     pCSD->PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
000054  09d3              LSRS     r3,r2,#7
000056  724b              STRB     r3,[r1,#9]
;;;1847     pCSD->WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
000058  f3c21380          UBFX     r3,r2,#6,#1
00005c  728b              STRB     r3,[r1,#0xa]
;;;1848     pCSD->RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
00005e  f3c21340          UBFX     r3,r2,#5,#1
000062  72cb              STRB     r3,[r1,#0xb]
;;;1849     pCSD->DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
000064  f3c21300          UBFX     r3,r2,#4,#1
000068  730b              STRB     r3,[r1,#0xc]
;;;1850     pCSD->Reserved2       = 0U; /*!< Reserved */
00006a  f04f0c00          MOV      r12,#0
00006e  f881c00d          STRB     r12,[r1,#0xd]
000072  6c45              LDR      r5,[r0,#0x44]         ;1814
;;;1851          
;;;1852     if(hsd->SdCard.CardType == CARD_SDSC)
;;;1853     {
;;;1854       pCSD->DeviceSize = (tmp & 0x03U) << 10U;
;;;1855       
;;;1856       /* Byte 7 */
;;;1857       tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
;;;1858       pCSD->DeviceSize |= (tmp) << 2U;
;;;1859       
;;;1860       /* Byte 8 */
;;;1861       tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
;;;1862       pCSD->DeviceSize |= (tmp & 0xC0U) >> 6U;
;;;1863       
;;;1864       pCSD->MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
;;;1865       pCSD->MaxRdCurrentVDDMax = (tmp & 0x07U);
;;;1866       
;;;1867       /* Byte 9 */
;;;1868       tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
;;;1869       pCSD->MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
;;;1870       pCSD->MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
;;;1871       pCSD->DeviceSizeMul      = (tmp & 0x03U) << 1U;
;;;1872       /* Byte 10 */
;;;1873       tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
;;;1874       pCSD->DeviceSizeMul |= (tmp & 0x80U) >> 7U;
;;;1875       
;;;1876       hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
;;;1877       hsd->SdCard.BlockNbr *= (1U << (pCSD->DeviceSizeMul + 2U));
;;;1878       hsd->SdCard.BlockSize = 1U << (pCSD->RdBlockLen);
;;;1879   
;;;1880       hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U); 
;;;1881       hsd->SdCard.LogBlockSize = 512U;
000074  f44f7400          MOV      r4,#0x200
000078  2301              MOVS     r3,#1                 ;1878
00007a  b175              CBZ      r5,|L9.154|
;;;1882     }
;;;1883     else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
00007c  2d01              CMP      r5,#1
00007e  d045              BEQ      |L9.268|
;;;1884     {
;;;1885       /* Byte 7 */
;;;1886       tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
;;;1887       pCSD->DeviceSize = (tmp & 0x3FU) << 16U;
;;;1888       
;;;1889       /* Byte 8 */
;;;1890       tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
;;;1891       
;;;1892       pCSD->DeviceSize |= (tmp << 8U);
;;;1893       
;;;1894       /* Byte 9 */
;;;1895       tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
;;;1896       
;;;1897       pCSD->DeviceSize |= (tmp);
;;;1898       
;;;1899       /* Byte 10 */
;;;1900       tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
;;;1901       
;;;1902       hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1U) * 1024U);
;;;1903       hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512U;
;;;1904     }
;;;1905     else
;;;1906     {
;;;1907       /* Clear all the static flags */
;;;1908       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);   
000080  6802              LDR      r2,[r0,#0]
000082  f24051ff          MOV      r1,#0x5ff
000086  6391              STR      r1,[r2,#0x38]
;;;1909       hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
000088  6b81              LDR      r1,[r0,#0x38]
00008a  f0415180          ORR      r1,r1,#0x10000000
00008e  6381              STR      r1,[r0,#0x38]
;;;1910       hsd->State = HAL_SD_STATE_READY;
000090  f8803034          STRB     r3,[r0,#0x34]
;;;1911       return HAL_ERROR;
;;;1912     }
;;;1913     
;;;1914     pCSD->EraseGrSize = (tmp & 0x40U) >> 6U;
;;;1915     pCSD->EraseGrMul  = (tmp & 0x3FU) << 1U;
;;;1916     
;;;1917     /* Byte 11 */
;;;1918     tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
;;;1919     pCSD->EraseGrMul     |= (tmp & 0x80U) >> 7U;
;;;1920     pCSD->WrProtectGrSize = (tmp & 0x7FU);
;;;1921     
;;;1922     /* Byte 12 */
;;;1923     tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
;;;1924     pCSD->WrProtectGrEnable = (tmp & 0x80U) >> 7U;
;;;1925     pCSD->ManDeflECC        = (tmp & 0x60U) >> 5U;
;;;1926     pCSD->WrSpeedFact       = (tmp & 0x1CU) >> 2U;
;;;1927     pCSD->MaxWrBlockLen     = (tmp & 0x03U) << 2U;
;;;1928     
;;;1929     /* Byte 13 */
;;;1930     tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
;;;1931     pCSD->MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
;;;1932     pCSD->WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
;;;1933     pCSD->Reserved3           = 0U;
;;;1934     pCSD->ContentProtectAppli = (tmp & 0x01U);
;;;1935     
;;;1936     /* Byte 14 */
;;;1937     tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
;;;1938     pCSD->FileFormatGrouop = (tmp & 0x80U) >> 7U;
;;;1939     pCSD->CopyFlag         = (tmp & 0x40U) >> 6U;
;;;1940     pCSD->PermWrProtect    = (tmp & 0x20U) >> 5U;
;;;1941     pCSD->TempWrProtect    = (tmp & 0x10U) >> 4U;
;;;1942     pCSD->FileFormat       = (tmp & 0x0CU) >> 2U;
;;;1943     pCSD->ECC              = (tmp & 0x03U);
;;;1944     
;;;1945     /* Byte 15 */
;;;1946     tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
;;;1947     pCSD->CSD_CRC   = (tmp & 0xFEU) >> 1U;
;;;1948     pCSD->Reserved4 = 1U;
;;;1949     
;;;1950     return HAL_OK;
;;;1951   }
000094  bc70              POP      {r4-r6}
000096  2001              MOVS     r0,#1                 ;1911
000098  4770              BX       lr
                  |L9.154|
00009a  0792              LSLS     r2,r2,#30             ;1854
00009c  0d12              LSRS     r2,r2,#20             ;1854
00009e  610a              STR      r2,[r1,#0x10]         ;1854
0000a0  f8902068          LDRB     r2,[r0,#0x68]         ;1857
0000a4  690d              LDR      r5,[r1,#0x10]         ;1858
0000a6  ea450282          ORR      r2,r5,r2,LSL #2       ;1858
0000aa  610a              STR      r2,[r1,#0x10]         ;1858
0000ac  6ec2              LDR      r2,[r0,#0x6c]         ;1861
0000ae  690d              LDR      r5,[r1,#0x10]         ;1862
0000b0  0e12              LSRS     r2,r2,#24             ;1861
0000b2  ea451592          ORR      r5,r5,r2,LSR #6       ;1862
0000b6  610d              STR      r5,[r1,#0x10]         ;1862
0000b8  f3c205c2          UBFX     r5,r2,#3,#3           ;1864
0000bc  750d              STRB     r5,[r1,#0x14]         ;1864
0000be  f0020207          AND      r2,r2,#7              ;1865
0000c2  754a              STRB     r2,[r1,#0x15]         ;1865
0000c4  6ec2              LDR      r2,[r0,#0x6c]         ;1868
0000c6  f3c24207          UBFX     r2,r2,#16,#8          ;1868
0000ca  0955              LSRS     r5,r2,#5              ;1869
0000cc  758d              STRB     r5,[r1,#0x16]         ;1869
0000ce  f3c20582          UBFX     r5,r2,#2,#3           ;1870
0000d2  75cd              STRB     r5,[r1,#0x17]         ;1870
0000d4  0792              LSLS     r2,r2,#30             ;1871
0000d6  0f52              LSRS     r2,r2,#29             ;1871
0000d8  760a              STRB     r2,[r1,#0x18]         ;1871
0000da  f8b0206c          LDRH     r2,[r0,#0x6c]         ;1873
0000de  7e0d              LDRB     r5,[r1,#0x18]         ;1874
0000e0  f3c22207          UBFX     r2,r2,#8,#8           ;1873
0000e4  ea4515d2          ORR      r5,r5,r2,LSR #7       ;1874
0000e8  760d              STRB     r5,[r1,#0x18]         ;1874
0000ea  690d              LDR      r5,[r1,#0x10]         ;1876
0000ec  1c6d              ADDS     r5,r5,#1              ;1876
0000ee  6545              STR      r5,[r0,#0x54]         ;1877
0000f0  7e0e              LDRB     r6,[r1,#0x18]         ;1877
0000f2  1cb6              ADDS     r6,r6,#2              ;1877
0000f4  fa05f606          LSL      r6,r5,r6              ;1877
0000f8  6546              STR      r6,[r0,#0x54]         ;1878
0000fa  7a0d              LDRB     r5,[r1,#8]            ;1878
0000fc  fa03f505          LSL      r5,r3,r5              ;1878
000100  6585              STR      r5,[r0,#0x58]         ;1880
000102  0a6d              LSRS     r5,r5,#9              ;1880
000104  4375              MULS     r5,r6,r5              ;1880
000106  e9c05417          STRD     r5,r4,[r0,#0x5c]      ;1880
00010a  e01c              B        |L9.326|
                  |L9.268|
00010c  f8902068          LDRB     r2,[r0,#0x68]         ;1886
000110  0692              LSLS     r2,r2,#26             ;1887
000112  0a92              LSRS     r2,r2,#10             ;1887
000114  610a              STR      r2,[r1,#0x10]         ;1887
000116  6ec2              LDR      r2,[r0,#0x6c]         ;1890
000118  690d              LDR      r5,[r1,#0x10]         ;1892
00011a  0e12              LSRS     r2,r2,#24             ;1890
00011c  ea452202          ORR      r2,r5,r2,LSL #8       ;1892
000120  610a              STR      r2,[r1,#0x10]         ;1892
000122  6ec2              LDR      r2,[r0,#0x6c]         ;1895
000124  690d              LDR      r5,[r1,#0x10]         ;1897
000126  f3c24207          UBFX     r2,r2,#16,#8          ;1895
00012a  432a              ORRS     r2,r2,r5              ;1897
00012c  610a              STR      r2,[r1,#0x10]         ;1897
00012e  f8b0206c          LDRH     r2,[r0,#0x6c]         ;1900
000132  690d              LDR      r5,[r1,#0x10]         ;1902
000134  f3c22207          UBFX     r2,r2,#8,#8           ;1900
000138  1c6d              ADDS     r5,r5,#1              ;1902
00013a  ea4f2585          LSL      r5,r5,#10             ;1902
00013e  6545              STR      r5,[r0,#0x54]         ;1902
000140  e9c04516          STRD     r4,r5,[r0,#0x58]      ;1902
000144  6604              STR      r4,[r0,#0x60]         ;1903
                  |L9.326|
000146  f3c21480          UBFX     r4,r2,#6,#1           ;1914
00014a  764c              STRB     r4,[r1,#0x19]         ;1914
00014c  ea4f6282          LSL      r2,r2,#26             ;1915
000150  ea4f6252          LSR      r2,r2,#25             ;1915
000154  768a              STRB     r2,[r1,#0x1a]         ;1915
000156  f890206c          LDRB     r2,[r0,#0x6c]         ;1918
00015a  7e8c              LDRB     r4,[r1,#0x1a]         ;1919
00015c  ea4414d2          ORR      r4,r4,r2,LSR #7       ;1919
000160  768c              STRB     r4,[r1,#0x1a]         ;1919
000162  f002027f          AND      r2,r2,#0x7f           ;1920
000166  76ca              STRB     r2,[r1,#0x1b]         ;1920
000168  6f02              LDR      r2,[r0,#0x70]         ;1923
00016a  ea4f6212          LSR      r2,r2,#24             ;1923
00016e  ea4f14d2          LSR      r4,r2,#7              ;1924
000172  770c              STRB     r4,[r1,#0x1c]         ;1924
000174  f3c21441          UBFX     r4,r2,#5,#2           ;1925
000178  774c              STRB     r4,[r1,#0x1d]         ;1925
00017a  f3c20482          UBFX     r4,r2,#2,#3           ;1926
00017e  778c              STRB     r4,[r1,#0x1e]         ;1926
000180  ea4f7282          LSL      r2,r2,#30             ;1927
000184  ea4f7212          LSR      r2,r2,#28             ;1927
000188  77ca              STRB     r2,[r1,#0x1f]         ;1927
00018a  6f02              LDR      r2,[r0,#0x70]         ;1930
00018c  7fcc              LDRB     r4,[r1,#0x1f]         ;1931
00018e  f3c24207          UBFX     r2,r2,#16,#8          ;1930
000192  ea441492          ORR      r4,r4,r2,LSR #6       ;1931
000196  77cc              STRB     r4,[r1,#0x1f]         ;1931
000198  f3c21440          UBFX     r4,r2,#5,#1           ;1932
00019c  f8814020          STRB     r4,[r1,#0x20]         ;1932
0001a0  f881c021          STRB     r12,[r1,#0x21]        ;1933
0001a4  f0020201          AND      r2,r2,#1              ;1934
0001a8  f8812022          STRB     r2,[r1,#0x22]         ;1934
0001ac  f8b02070          LDRH     r2,[r0,#0x70]         ;1937
0001b0  f3c22207          UBFX     r2,r2,#8,#8           ;1937
0001b4  ea4f1cd2          LSR      r12,r2,#7             ;1938
0001b8  f881c023          STRB     r12,[r1,#0x23]        ;1938
0001bc  f3c21c80          UBFX     r12,r2,#6,#1          ;1939
0001c0  f881c024          STRB     r12,[r1,#0x24]        ;1939
0001c4  f3c21c40          UBFX     r12,r2,#5,#1          ;1940
0001c8  f881c025          STRB     r12,[r1,#0x25]        ;1940
0001cc  f3c21c00          UBFX     r12,r2,#4,#1          ;1941
0001d0  f881c026          STRB     r12,[r1,#0x26]        ;1941
0001d4  f3c20c81          UBFX     r12,r2,#2,#2          ;1942
0001d8  f881c027          STRB     r12,[r1,#0x27]        ;1942
0001dc  f0020203          AND      r2,r2,#3              ;1943
0001e0  f8812028          STRB     r2,[r1,#0x28]         ;1943
0001e4  f8900070          LDRB     r0,[r0,#0x70]         ;1946
0001e8  ea4f0050          LSR      r0,r0,#1              ;1947
0001ec  f8810029          STRB     r0,[r1,#0x29]         ;1947
0001f0  f881302a          STRB     r3,[r1,#0x2a]         ;1948
0001f4  bc70              POP      {r4-r6}
0001f6  f04f0000          MOV      r0,#0                 ;1950
0001fa  4770              BX       lr
;;;1952   
                          ENDP


                          AREA ||i.HAL_SD_GetCardInfo||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardInfo PROC
;;;2047     */
;;;2048   HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
000000  6c42              LDR      r2,[r0,#0x44]
;;;2049   {
;;;2050     pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
;;;2051     pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
000002  600a              STR      r2,[r1,#0]
000004  6c82              LDR      r2,[r0,#0x48]
;;;2052     pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
000006  604a              STR      r2,[r1,#4]
000008  6cc2              LDR      r2,[r0,#0x4c]
;;;2053     pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
00000a  608a              STR      r2,[r1,#8]
00000c  6d02              LDR      r2,[r0,#0x50]
;;;2054     pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
00000e  60ca              STR      r2,[r1,#0xc]
000010  6d42              LDR      r2,[r0,#0x54]
;;;2055     pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
000012  610a              STR      r2,[r1,#0x10]
000014  6d82              LDR      r2,[r0,#0x58]
;;;2056     pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
000016  614a              STR      r2,[r1,#0x14]
000018  6dc2              LDR      r2,[r0,#0x5c]
;;;2057     pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
00001a  618a              STR      r2,[r1,#0x18]
00001c  6e00              LDR      r0,[r0,#0x60]
;;;2058     
;;;2059     return HAL_OK;
00001e  61c8              STR      r0,[r1,#0x1c]
000020  2000              MOVS     r0,#0
;;;2060   }
000022  4770              BX       lr
;;;2061   
                          ENDP


                          AREA ||i.HAL_SD_GetCardState||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardState PROC
;;;2144     */
;;;2145   HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2146   {
000002  4604              MOV      r4,r0
000004  f8b00050          LDRH     r0,[r0,#0x50]
;;;2147     HAL_SD_CardStateTypeDef cardstate =  HAL_SD_CARD_TRANSFER;
;;;2148     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;2149     uint32_t resp1 = 0;
000008  2500              MOVS     r5,#0
00000a  0401              LSLS     r1,r0,#16
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       SDMMC_CmdSendStatus
000012  b118              CBZ      r0,|L11.28|
;;;2150     
;;;2151     errorstate = SD_SendStatus(hsd, &resp1);
;;;2152     if(errorstate != HAL_OK)
;;;2153     {
;;;2154       hsd->ErrorCode |= errorstate;
000014  6ba1              LDR      r1,[r4,#0x38]
000016  4308              ORRS     r0,r0,r1
000018  63a0              STR      r0,[r4,#0x38]
00001a  e004              B        |L11.38|
                  |L11.28|
00001c  2100              MOVS     r1,#0
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       SDIO_GetResponse
000024  4605              MOV      r5,r0
                  |L11.38|
;;;2155     }
;;;2156   
;;;2157     cardstate = (HAL_SD_CardStateTypeDef)((resp1 >> 9U) & 0x0FU);
000026  f3c52043          UBFX     r0,r5,#9,#4
;;;2158     
;;;2159     return cardstate;
;;;2160   }
00002a  bd70              POP      {r4-r6,pc}
;;;2161   
                          ENDP


                          AREA ||i.HAL_SD_GetCardStatus||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardStatus PROC
;;;1959     */
;;;1960   HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1961   {
000004  b097              SUB      sp,sp,#0x5c
000006  460f              MOV      r7,r1
000008  4604              MOV      r4,r0
;;;1962     uint32_t tmp = 0U;
;;;1963     uint32_t sd_status[16U];
;;;1964     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;1965     
;;;1966     errorstate = SD_SendSDStatus(hsd, sd_status);
00000a  466d              MOV      r5,sp
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
000012  2100              MOVS     r1,#0
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       SDIO_GetResponse
00001a  f0107f00          TST      r0,#0x2000000
00001e  f2405bff          MOV      r11,#0x5ff
000022  bf18              IT       NE
000024  f44f6000          MOVNE    r0,#0x800
000028  f04080c2          BNE.W    |L12.432|
00002c  2140              MOVS     r1,#0x40
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       SDMMC_CmdBlockLength
000034  b118              CBZ      r0,|L12.62|
                  |L12.54|
000036  6ba1              LDR      r1,[r4,#0x38]
000038  63a1              STR      r1,[r4,#0x38]
00003a  f000b8b9          B.W      |L12.432|
                  |L12.62|
00003e  f8b40050          LDRH     r0,[r4,#0x50]
000042  0401              LSLS     r1,r0,#16
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       SDMMC_CmdAppCommand
00004a  2800              CMP      r0,#0
00004c  d1f3              BNE      |L12.54|
00004e  1e40              SUBS     r0,r0,#1
000050  9010              STR      r0,[sp,#0x40]
000052  2040              MOVS     r0,#0x40
000054  9011              STR      r0,[sp,#0x44]
000056  2060              MOVS     r0,#0x60
000058  f04f0902          MOV      r9,#2
00005c  e9cd0912          STRD     r0,r9,[sp,#0x48]
000060  2000              MOVS     r0,#0
000062  9014              STR      r0,[sp,#0x50]
000064  2001              MOVS     r0,#1
000066  9015              STR      r0,[sp,#0x54]
000068  a910              ADD      r1,sp,#0x40
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       SDIO_ConfigData
000070  6820              LDR      r0,[r4,#0]
000072  f7fffffe          BL       SDMMC_CmdStatusRegister
000076  2800              CMP      r0,#0
000078  d1dd              BNE      |L12.54|
00007a  6820              LDR      r0,[r4,#0]
00007c  6b40              LDR      r0,[r0,#0x34]
00007e  f2404a2a          MOV      r10,#0x42a
000082  ea100f0a          TST      r0,r10
000086  d11b              BNE      |L12.192|
                  |L12.136|
000088  6820              LDR      r0,[r4,#0]
00008a  6b40              LDR      r0,[r0,#0x34]
00008c  f4104f00          TST      r0,#0x8000
000090  bf18              IT       NE
000092  2600              MOVNE    r6,#0
000094  d008              BEQ      |L12.168|
                  |L12.150|
000096  6820              LDR      r0,[r4,#0]
000098  f7fffffe          BL       SDIO_ReadFIFO
00009c  f8450026          STR      r0,[r5,r6,LSL #2]
0000a0  1c76              ADDS     r6,r6,#1
0000a2  2e08              CMP      r6,#8
0000a4  d3f7              BCC      |L12.150|
0000a6  3520              ADDS     r5,r5,#0x20
                  |L12.168|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  eba00008          SUB      r0,r0,r8
0000b0  f1b03fff          CMP      r0,#0xffffffff
0000b4  d07a              BEQ      |L12.428|
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6b40              LDR      r0,[r0,#0x34]
0000ba  ea100f0a          TST      r0,r10
0000be  d0e3              BEQ      |L12.136|
                  |L12.192|
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6b41              LDR      r1,[r0,#0x34]
0000c4  f0110f08          TST      r1,#8
0000c8  bf18              IT       NE
0000ca  2008              MOVNE    r0,#8
0000cc  d170              BNE      |L12.432|
0000ce  6b41              LDR      r1,[r0,#0x34]
0000d0  f0110f02          TST      r1,#2
0000d4  bf18              IT       NE
0000d6  4648              MOVNE    r0,r9
0000d8  d16a              BNE      |L12.432|
0000da  6b41              LDR      r1,[r0,#0x34]
0000dc  f0110f20          TST      r1,#0x20
0000e0  bf18              IT       NE
0000e2  2020              MOVNE    r0,#0x20
0000e4  d164              BNE      |L12.432|
0000e6  6b40              LDR      r0,[r0,#0x34]
0000e8  f4101f00          TST      r0,#0x200000
0000ec  d010              BEQ      |L12.272|
                  |L12.238|
0000ee  6820              LDR      r0,[r4,#0]
0000f0  f7fffffe          BL       SDIO_ReadFIFO
0000f4  f8450b04          STR      r0,[r5],#4
0000f8  f7fffffe          BL       HAL_GetTick
0000fc  eba00008          SUB      r0,r0,r8
000100  f1b03fff          CMP      r0,#0xffffffff
000104  d052              BEQ      |L12.428|
000106  6820              LDR      r0,[r4,#0]
000108  6b40              LDR      r0,[r0,#0x34]
00010a  f4101f00          TST      r0,#0x200000
00010e  d1ee              BNE      |L12.238|
                  |L12.272|
000110  6820              LDR      r0,[r4,#0]
000112  f8c0b038          STR      r11,[r0,#0x38]
;;;1967     if(errorstate != HAL_OK)
;;;1968     {
;;;1969       /* Clear all the static flags */
;;;1970       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);   
;;;1971       hsd->ErrorCode |= errorstate;
;;;1972       hsd->State = HAL_SD_STATE_READY;
;;;1973       return HAL_ERROR;
;;;1974     }
;;;1975     else
;;;1976     {
;;;1977       /* Byte 0 */
;;;1978       tmp = (sd_status[0U] & 0xC0U) >> 6U;
000116  9800              LDR      r0,[sp,#0]
000118  f3c01081          UBFX     r0,r0,#6,#2
;;;1979       pStatus->DataBusWidth = (uint8_t)tmp;
00011c  7038              STRB     r0,[r7,#0]
;;;1980       
;;;1981       /* Byte 0 */
;;;1982       tmp = (sd_status[0U] & 0x20U) >> 5U;
00011e  9800              LDR      r0,[sp,#0]
000120  f3c01040          UBFX     r0,r0,#5,#1
;;;1983       pStatus->SecuredMode = (uint8_t)tmp;
000124  7078              STRB     r0,[r7,#1]
;;;1984       
;;;1985       /* Byte 2 */
;;;1986       tmp = (sd_status[0U] & 0x00FF0000U) >> 16U;
000126  9800              LDR      r0,[sp,#0]
;;;1987       pStatus->CardType = (uint16_t)(tmp << 8U);
000128  f64f71ff          MOV      r1,#0xffff
00012c  0c00              LSRS     r0,r0,#16             ;1986
00012e  ea012000          AND      r0,r1,r0,LSL #8
000132  8078              STRH     r0,[r7,#2]
;;;1988       
;;;1989       /* Byte 3 */
;;;1990       tmp = (sd_status[0U] & 0xFF000000U) >> 24U;
;;;1991       pStatus->CardType |= (uint16_t)tmp;
000134  887a              LDRH     r2,[r7,#2]
000136  9800              LDR      r0,[sp,#0]
000138  ea426010          ORR      r0,r2,r0,LSR #24
00013c  8078              STRH     r0,[r7,#2]
;;;1992       
;;;1993       /* Byte 4 */
;;;1994       tmp = (sd_status[1U] & 0xFFU);
;;;1995       pStatus->ProtectedAreaSize = (uint32_t)(tmp << 24U);
00013e  9801              LDR      r0,[sp,#4]
000140  0600              LSLS     r0,r0,#24
000142  6078              STR      r0,[r7,#4]
;;;1996       
;;;1997       /* Byte 5 */
;;;1998       tmp = (sd_status[1U] & 0xFF00U) >> 8U;
000144  9801              LDR      r0,[sp,#4]
;;;1999       pStatus->ProtectedAreaSize |= (uint32_t)(tmp << 16U);
000146  687a              LDR      r2,[r7,#4]
000148  f3c02007          UBFX     r0,r0,#8,#8           ;1998
00014c  ea424000          ORR      r0,r2,r0,LSL #16
000150  6078              STR      r0,[r7,#4]
;;;2000       
;;;2001       /* Byte 6 */
;;;2002       tmp = (sd_status[1U] & 0xFF0000U) >> 16U;
000152  9801              LDR      r0,[sp,#4]
;;;2003       pStatus->ProtectedAreaSize |= (uint32_t)(tmp << 8U);
000154  687a              LDR      r2,[r7,#4]
000156  f3c04007          UBFX     r0,r0,#16,#8          ;2002
00015a  ea422000          ORR      r0,r2,r0,LSL #8
00015e  6078              STR      r0,[r7,#4]
;;;2004       
;;;2005       /* Byte 7 */
;;;2006       tmp = (sd_status[1U] & 0xFF000000U) >> 24U;
;;;2007       pStatus->ProtectedAreaSize |= (uint32_t)tmp;
000160  9801              LDR      r0,[sp,#4]
000162  687a              LDR      r2,[r7,#4]
000164  ea426010          ORR      r0,r2,r0,LSR #24
000168  6078              STR      r0,[r7,#4]
;;;2008       
;;;2009       /* Byte 8 */
;;;2010       tmp = (sd_status[2U] & 0xFFU);
;;;2011       pStatus->SpeedClass = (uint8_t)tmp;
00016a  9802              LDR      r0,[sp,#8]
00016c  7238              STRB     r0,[r7,#8]
;;;2012       
;;;2013       /* Byte 9 */
;;;2014       tmp = (sd_status[2U] & 0xFF00U) >> 8U;
00016e  9802              LDR      r0,[sp,#8]
000170  0a00              LSRS     r0,r0,#8
;;;2015       pStatus->PerformanceMove = (uint8_t)tmp;
000172  7278              STRB     r0,[r7,#9]
;;;2016       
;;;2017       /* Byte 10 */
;;;2018       tmp = (sd_status[2U] & 0xF00000U) >> 20U;
000174  9802              LDR      r0,[sp,#8]
000176  f3c05003          UBFX     r0,r0,#20,#4
;;;2019       pStatus->AllocationUnitSize = (uint8_t)tmp;
00017a  72b8              STRB     r0,[r7,#0xa]
;;;2020       
;;;2021       /* Byte 11 */
;;;2022       tmp = (sd_status[2U] & 0xFF000000U) >> 24U;
00017c  9802              LDR      r0,[sp,#8]
00017e  0e00              LSRS     r0,r0,#24
;;;2023       pStatus->EraseSize = (uint16_t)(tmp << 8U);
000180  ea012000          AND      r0,r1,r0,LSL #8
000184  81b8              STRH     r0,[r7,#0xc]
;;;2024       
;;;2025       /* Byte 12 */
;;;2026       tmp = (sd_status[3U] & 0xFFU);
000186  9803              LDR      r0,[sp,#0xc]
;;;2027       pStatus->EraseSize |= (uint16_t)tmp;
000188  89b9              LDRH     r1,[r7,#0xc]
00018a  b2c0              UXTB     r0,r0                 ;2026
00018c  4308              ORRS     r0,r0,r1
00018e  81b8              STRH     r0,[r7,#0xc]
;;;2028       
;;;2029       /* Byte 13 */
;;;2030       tmp = (sd_status[3U] & 0xFC00U) >> 10U;
000190  9803              LDR      r0,[sp,#0xc]
000192  f3c02085          UBFX     r0,r0,#10,#6
;;;2031       pStatus->EraseTimeout = (uint8_t)tmp;
000196  73b8              STRB     r0,[r7,#0xe]
;;;2032       
;;;2033       /* Byte 13 */
;;;2034       tmp = (sd_status[3U] & 0x0300U) >> 8U;
000198  9803              LDR      r0,[sp,#0xc]
00019a  f3c02001          UBFX     r0,r0,#8,#2
;;;2035       pStatus->EraseOffset = (uint8_t)tmp;
00019e  73f8              STRB     r0,[r7,#0xf]
;;;2036     }
;;;2037     
;;;2038     return HAL_OK;
0001a0  2000              MOVS     r0,#0
                  |L12.418|
;;;2039   }
0001a2  b017              ADD      sp,sp,#0x5c
0001a4  e8bd8ff0          POP      {r4-r11,pc}
0001a8  e000              B        |L12.428|
0001aa  e001              B        |L12.432|
                  |L12.428|
0001ac  f04f4000          MOV      r0,#0x80000000
                  |L12.432|
0001b0  6821              LDR      r1,[r4,#0]            ;1970
0001b2  f8c1b038          STR      r11,[r1,#0x38]        ;1970
0001b6  6ba1              LDR      r1,[r4,#0x38]         ;1971
0001b8  4308              ORRS     r0,r0,r1              ;1971
0001ba  63a0              STR      r0,[r4,#0x38]         ;1971
0001bc  2001              MOVS     r0,#1                 ;1972
0001be  f8840034          STRB     r0,[r4,#0x34]         ;1972
0001c2  e7ee              B        |L12.418|
;;;2040   
                          ENDP


                          AREA ||i.HAL_SD_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetError PROC
;;;1638   */
;;;1639   uint32_t HAL_SD_GetError(SD_HandleTypeDef *hsd)
000000  6b80              LDR      r0,[r0,#0x38]
;;;1640   {
;;;1641     return hsd->ErrorCode;
;;;1642   }
000002  4770              BX       lr
;;;1643   
                          ENDP


                          AREA ||i.HAL_SD_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetState PROC
;;;1627     */
;;;1628   HAL_SD_StateTypeDef HAL_SD_GetState(SD_HandleTypeDef *hsd)
000000  f8900034          LDRB     r0,[r0,#0x34]
;;;1629   {
;;;1630     return hsd->State;
;;;1631   }
000004  4770              BX       lr
;;;1632   
                          ENDP


                          AREA ||i.HAL_SD_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SD_IRQHandler PROC
;;;1405     */
;;;1406   void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;1407   {
000002  4604              MOV      r4,r0
;;;1408     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;1409     
;;;1410     /* Check for SDIO interrupt flags */
;;;1411     if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DATAEND) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6b41              LDR      r1,[r0,#0x34]
;;;1412     {
;;;1413       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DATAEND); 
;;;1414       
;;;1415   #ifdef SDIO_STA_STBITERR
;;;1416       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1417                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
;;;1418   #else /* SDIO_STA_STBITERR not defined */
;;;1419       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1420                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;1421   #endif
;;;1422       
;;;1423       if((hsd->Context & SD_CONTEXT_IT) != RESET)
;;;1424       {
;;;1425         if(((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET))
;;;1426         {
;;;1427           errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;1428           if(errorstate != HAL_SD_ERROR_NONE)
;;;1429           {
;;;1430             hsd->ErrorCode |= errorstate;
;;;1431             HAL_SD_ErrorCallback(hsd);
;;;1432           }
;;;1433         }
;;;1434         
;;;1435         /* Clear all the static flags */
;;;1436         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1437         
;;;1438         hsd->State = HAL_SD_STATE_READY;
000008  f04f0501          MOV      r5,#1
00000c  f4117f80          TST      r1,#0x100             ;1411
000010  d058              BEQ      |L15.196|
000012  0229              LSLS     r1,r5,#8              ;1413
000014  6381              STR      r1,[r0,#0x38]         ;1413
000016  6820              LDR      r0,[r4,#0]            ;1416
000018  6bc1              LDR      r1,[r0,#0x3c]         ;1416
00001a  f421719d          BIC      r1,r1,#0x13a          ;1416
00001e  f4217100          BIC      r1,r1,#0x200          ;1416
000022  63c1              STR      r1,[r0,#0x3c]         ;1416
000024  6b20              LDR      r0,[r4,#0x30]         ;1423
000026  f0100f08          TST      r0,#8                 ;1423
;;;1439         if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET))
;;;1440         {
;;;1441           HAL_SD_RxCpltCallback(hsd);
;;;1442         }
;;;1443         else
;;;1444         {
;;;1445           HAL_SD_TxCpltCallback(hsd);
;;;1446         }
;;;1447       }
;;;1448       else if((hsd->Context & SD_CONTEXT_DMA) != RESET)
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  d025              BEQ      |L15.122|
00002e  f0100f02          TST      r0,#2                 ;1425
000032  bf04              ITT      EQ                    ;1425
000034  6b20              LDREQ    r0,[r4,#0x30]         ;1425
000036  f0100f20          TSTEQ    r0,#0x20              ;1425
00003a  d009              BEQ      |L15.80|
00003c  6820              LDR      r0,[r4,#0]            ;1427
00003e  f7fffffe          BL       SDMMC_CmdStopTransfer
000042  b128              CBZ      r0,|L15.80|
000044  6ba1              LDR      r1,[r4,#0x38]         ;1430
000046  4308              ORRS     r0,r0,r1              ;1430
000048  63a0              STR      r0,[r4,#0x38]         ;1430
00004a  4620              MOV      r0,r4                 ;1431
00004c  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L15.80|
000050  6821              LDR      r1,[r4,#0]            ;1436
000052  f24050ff          MOV      r0,#0x5ff             ;1436
000056  6388              STR      r0,[r1,#0x38]         ;1436
000058  f8845034          STRB     r5,[r4,#0x34]         ;1438
00005c  6b20              LDR      r0,[r4,#0x30]         ;1439
00005e  f0100f01          TST      r0,#1                 ;1439
000062  bf04              ITT      EQ                    ;1439
000064  6b20              LDREQ    r0,[r4,#0x30]         ;1439
000066  f0100f02          TSTEQ    r0,#2                 ;1439
00006a  4620              MOV      r0,r4                 ;1445
00006c  d002              BEQ      |L15.116|
00006e  f7fffffe          BL       HAL_SD_RxCpltCallback
;;;1449       {
;;;1450         if((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET)
;;;1451         {
;;;1452           errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;1453           if(errorstate != HAL_SD_ERROR_NONE)
;;;1454           {
;;;1455             hsd->ErrorCode |= errorstate;
;;;1456             HAL_SD_ErrorCallback(hsd);
;;;1457           }
;;;1458         }
;;;1459         if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) == RESET) && ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == RESET))
;;;1460         {
;;;1461           /* Disable the DMA transfer for transmit request by setting the DMAEN bit
;;;1462           in the SD DCTRL register */
;;;1463           hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
;;;1464           
;;;1465           hsd->State = HAL_SD_STATE_READY;
;;;1466           
;;;1467           HAL_SD_TxCpltCallback(hsd);
;;;1468         }
;;;1469       }
;;;1470     }
;;;1471     
;;;1472     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXFIFOHE) != RESET)
;;;1473     {
;;;1474       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_TXFIFOHE);
;;;1475       
;;;1476       SD_Write_IT(hsd);
;;;1477     }
;;;1478     
;;;1479     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXFIFOHF) != RESET)
;;;1480     {
;;;1481       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXFIFOHF);
;;;1482       
;;;1483       SD_Read_IT(hsd);
;;;1484     }
;;;1485     
;;;1486   #ifdef SDIO_STA_STBITERR
;;;1487     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR) != RESET)
;;;1488     {
;;;1489       /* Set Error code */
;;;1490       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL) != RESET)
;;;1491       {
;;;1492         hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL; 
;;;1493       }
;;;1494       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DTIMEOUT) != RESET)
;;;1495       {
;;;1496         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT; 
;;;1497       }
;;;1498       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXOVERR) != RESET)
;;;1499       {
;;;1500         hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN; 
;;;1501       }
;;;1502       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXUNDERR) != RESET)
;;;1503       {
;;;1504         hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN; 
;;;1505       }
;;;1506       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_STBITERR) != RESET)
;;;1507       {
;;;1508         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
;;;1509       }
;;;1510   
;;;1511       /* Clear All flags */
;;;1512       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS | SDIO_FLAG_STBITERR);
;;;1513       
;;;1514       /* Disable all interrupts */
;;;1515       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1516                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR |SDIO_IT_STBITERR);
;;;1517       
;;;1518       if((hsd->Context & SD_CONTEXT_DMA) != RESET)
;;;1519       {
;;;1520         /* Abort the SD DMA Streams */
;;;1521         if(hsd->hdmatx != NULL)
;;;1522         {
;;;1523           /* Set the DMA Tx abort callback */
;;;1524           hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
;;;1525           /* Abort DMA in IT mode */
;;;1526           if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
;;;1527           {
;;;1528             SD_DMATxAbort(hsd->hdmatx);
;;;1529           }
;;;1530         }
;;;1531         else if(hsd->hdmarx != NULL)
;;;1532         {
;;;1533           /* Set the DMA Rx abort callback */
;;;1534           hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
;;;1535           /* Abort DMA in IT mode */
;;;1536           if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
;;;1537           {
;;;1538             SD_DMARxAbort(hsd->hdmarx);
;;;1539           }
;;;1540         }
;;;1541         else
;;;1542         {
;;;1543           hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;1544           hsd->State = HAL_SD_STATE_READY;
;;;1545           HAL_SD_AbortCallback(hsd);
;;;1546         }
;;;1547       }
;;;1548       else if((hsd->Context & SD_CONTEXT_IT) != RESET)
;;;1549       {
;;;1550         /* Set the SD state to ready to be able to start again the process */
;;;1551         hsd->State = HAL_SD_STATE_READY;
;;;1552         HAL_SD_ErrorCallback(hsd);
;;;1553       }
;;;1554     }
;;;1555   #else /* SDIO_STA_STBITERR not defined */
;;;1556     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_TXUNDERR) != RESET)
;;;1557     {
;;;1558       /* Set Error code */
;;;1559       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL) != RESET)
;;;1560       {
;;;1561         hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL; 
;;;1562       }
;;;1563       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DTIMEOUT) != RESET)
;;;1564       {
;;;1565         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT; 
;;;1566       }
;;;1567       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXOVERR) != RESET)
;;;1568       {
;;;1569         hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN; 
;;;1570       }
;;;1571       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXUNDERR) != RESET)
;;;1572       {
;;;1573         hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN; 
;;;1574       }
;;;1575   
;;;1576       /* Clear All flags */
;;;1577       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1578       
;;;1579       /* Disable all interrupts */
;;;1580       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1581                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;1582       
;;;1583       if((hsd->Context & SD_CONTEXT_DMA) != RESET)
;;;1584       {
;;;1585         /* Abort the SD DMA Streams */
;;;1586         if(hsd->hdmatx != NULL)
;;;1587         {
;;;1588           /* Set the DMA Tx abort callback */
;;;1589           hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
;;;1590           /* Abort DMA in IT mode */
;;;1591           if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
;;;1592           {
;;;1593             SD_DMATxAbort(hsd->hdmatx);
;;;1594           }
;;;1595         }
;;;1596         else if(hsd->hdmarx != NULL)
;;;1597         {
;;;1598           /* Set the DMA Rx abort callback */
;;;1599           hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
;;;1600           /* Abort DMA in IT mode */
;;;1601           if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
;;;1602           {
;;;1603             SD_DMARxAbort(hsd->hdmarx);
;;;1604           }
;;;1605         }
;;;1606         else
;;;1607         {
;;;1608           hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;1609           hsd->State = HAL_SD_STATE_READY;
;;;1610           HAL_SD_AbortCallback(hsd);
;;;1611         }
;;;1612       }
;;;1613       else if((hsd->Context & SD_CONTEXT_IT) != RESET)
;;;1614       {
;;;1615         /* Set the SD state to ready to be able to start again the process */
;;;1616         hsd->State = HAL_SD_STATE_READY;
;;;1617         HAL_SD_ErrorCallback(hsd);
;;;1618       }
;;;1619     }
;;;1620   #endif
;;;1621   }
000072  bd70              POP      {r4-r6,pc}
                  |L15.116|
000074  f7fffffe          BL       HAL_SD_TxCpltCallback
000078  bd70              POP      {r4-r6,pc}
                  |L15.122|
00007a  f0100f80          TST      r0,#0x80              ;1448
00007e  bf08              IT       EQ
000080  bd70              POPEQ    {r4-r6,pc}
000082  6b20              LDR      r0,[r4,#0x30]         ;1450
000084  f0100f20          TST      r0,#0x20              ;1450
000088  d009              BEQ      |L15.158|
00008a  6820              LDR      r0,[r4,#0]            ;1452
00008c  f7fffffe          BL       SDMMC_CmdStopTransfer
000090  b128              CBZ      r0,|L15.158|
000092  6ba1              LDR      r1,[r4,#0x38]         ;1455
000094  4308              ORRS     r0,r0,r1              ;1455
000096  63a0              STR      r0,[r4,#0x38]         ;1455
000098  4620              MOV      r0,r4                 ;1456
00009a  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L15.158|
00009e  6b20              LDR      r0,[r4,#0x30]         ;1459
0000a0  f0100f01          TST      r0,#1                 ;1459
0000a4  bf06              ITTE     EQ                    ;1459
0000a6  6b20              LDREQ    r0,[r4,#0x30]         ;1459
0000a8  f0100f02          TSTEQ    r0,#2                 ;1459
0000ac  bd70              POPNE    {r4-r6,pc}
0000ae  6820              LDR      r0,[r4,#0]            ;1463
0000b0  6ac1              LDR      r1,[r0,#0x2c]         ;1463
0000b2  f0210108          BIC      r1,r1,#8              ;1463
0000b6  62c1              STR      r1,[r0,#0x2c]         ;1463
0000b8  f8845034          STRB     r5,[r4,#0x34]         ;1465
0000bc  4620              MOV      r0,r4                 ;1467
0000be  f7fffffe          BL       HAL_SD_TxCpltCallback
0000c2  bd70              POP      {r4-r6,pc}
                  |L15.196|
0000c4  6b41              LDR      r1,[r0,#0x34]         ;1472
0000c6  f4114f80          TST      r1,#0x4000            ;1472
0000ca  d011              BEQ      |L15.240|
0000cc  f44f4180          MOV      r1,#0x4000            ;1474
0000d0  6381              STR      r1,[r0,#0x38]         ;1474
0000d2  f8d46020          LDR.W    r6,[r4,#0x20]         ;1474
0000d6  2500              MOVS     r5,#0                 ;1474
                  |L15.216|
0000d8  eb060185          ADD      r1,r6,r5,LSL #2       ;1474
0000dc  6820              LDR      r0,[r4,#0]            ;1474
0000de  f7fffffe          BL       SDIO_WriteFIFO
0000e2  1c6d              ADDS     r5,r5,#1              ;1474
0000e4  2d08              CMP      r5,#8                 ;1474
0000e6  d3f7              BCC      |L15.216|
0000e8  6a20              LDR      r0,[r4,#0x20]         ;1474
0000ea  3020              ADDS     r0,r0,#0x20           ;1474
0000ec  6220              STR      r0,[r4,#0x20]         ;1476
0000ee  bd70              POP      {r4-r6,pc}
                  |L15.240|
0000f0  6b41              LDR      r1,[r0,#0x34]         ;1479
0000f2  f4114f00          TST      r1,#0x8000            ;1479
0000f6  d010              BEQ      |L15.282|
0000f8  f44f4100          MOV      r1,#0x8000            ;1481
0000fc  6381              STR      r1,[r0,#0x38]         ;1481
0000fe  6aa6              LDR      r6,[r4,#0x28]         ;1481
000100  2500              MOVS     r5,#0                 ;1481
                  |L15.258|
000102  6820              LDR      r0,[r4,#0]            ;1481
000104  f7fffffe          BL       SDIO_ReadFIFO
000108  f8460025          STR      r0,[r6,r5,LSL #2]     ;1481
00010c  1c6d              ADDS     r5,r5,#1              ;1481
00010e  2d08              CMP      r5,#8                 ;1481
000110  d3f7              BCC      |L15.258|
000112  6aa0              LDR      r0,[r4,#0x28]         ;1481
000114  3020              ADDS     r0,r0,#0x20           ;1481
000116  62a0              STR      r0,[r4,#0x28]         ;1483
000118  bd70              POP      {r4-r6,pc}
                  |L15.282|
00011a  6b41              LDR      r1,[r0,#0x34]         ;1487
00011c  f240223a          MOV      r2,#0x23a             ;1487
000120  4211              TST      r1,r2                 ;1487
000122  bf08              IT       EQ
000124  bd70              POPEQ    {r4-r6,pc}
000126  6b41              LDR      r1,[r0,#0x34]         ;1490
000128  f0110f02          TST      r1,#2                 ;1490
00012c  d003              BEQ      |L15.310|
00012e  6ba1              LDR      r1,[r4,#0x38]         ;1492
000130  f0410102          ORR      r1,r1,#2              ;1492
000134  63a1              STR      r1,[r4,#0x38]         ;1492
                  |L15.310|
000136  6b41              LDR      r1,[r0,#0x34]         ;1494
000138  f0110f08          TST      r1,#8                 ;1494
00013c  d003              BEQ      |L15.326|
00013e  6ba1              LDR      r1,[r4,#0x38]         ;1496
000140  f0410108          ORR      r1,r1,#8              ;1496
000144  63a1              STR      r1,[r4,#0x38]         ;1496
                  |L15.326|
000146  6b41              LDR      r1,[r0,#0x34]         ;1498
000148  f0110f20          TST      r1,#0x20              ;1498
00014c  d003              BEQ      |L15.342|
00014e  6ba1              LDR      r1,[r4,#0x38]         ;1500
000150  f0410120          ORR      r1,r1,#0x20           ;1500
000154  63a1              STR      r1,[r4,#0x38]         ;1500
                  |L15.342|
000156  6b41              LDR      r1,[r0,#0x34]         ;1502
000158  f0110f10          TST      r1,#0x10              ;1502
00015c  d003              BEQ      |L15.358|
00015e  6ba1              LDR      r1,[r4,#0x38]         ;1504
000160  f0410110          ORR      r1,r1,#0x10           ;1504
000164  63a1              STR      r1,[r4,#0x38]         ;1504
                  |L15.358|
000166  6b41              LDR      r1,[r0,#0x34]         ;1506
000168  f4117f00          TST      r1,#0x200             ;1506
00016c  d003              BEQ      |L15.374|
00016e  6ba1              LDR      r1,[r4,#0x38]         ;1508
000170  f0410108          ORR      r1,r1,#8              ;1508
000174  63a1              STR      r1,[r4,#0x38]         ;1508
                  |L15.374|
000176  f24071ff          MOV      r1,#0x7ff             ;1512
00017a  6381              STR      r1,[r0,#0x38]         ;1512
00017c  6820              LDR      r0,[r4,#0]            ;1515
00017e  6bc1              LDR      r1,[r0,#0x3c]         ;1515
000180  f421719d          BIC      r1,r1,#0x13a          ;1515
000184  f4217100          BIC      r1,r1,#0x200          ;1515
000188  63c1              STR      r1,[r0,#0x3c]         ;1515
00018a  6b20              LDR      r0,[r4,#0x30]         ;1518
00018c  f0100f80          TST      r0,#0x80              ;1518
000190  d05d              BEQ      |L15.590|
000192  6c20              LDR      r0,[r4,#0x40]         ;1521
000194  2600              MOVS     r6,#0                 ;1521
000196  b358              CBZ      r0,|L15.496|
000198  4932              LDR      r1,|L15.612|
00019a  6501              STR      r1,[r0,#0x50]         ;1526
00019c  6c20              LDR      r0,[r4,#0x40]         ;1526
00019e  f7fffffe          BL       HAL_DMA_Abort_IT
0001a2  2800              CMP      r0,#0                 ;1526
0001a4  bf08              IT       EQ
0001a6  bd70              POPEQ    {r4-r6,pc}
0001a8  6c20              LDR      r0,[r4,#0x40]
0001aa  6b84              LDR      r4,[r0,#0x38]
0001ac  6c20              LDR      r0,[r4,#0x40]
0001ae  2800              CMP      r0,#0
0001b0  bf18              IT       NE
0001b2  6426              STRNE    r6,[r4,#0x40]
0001b4  6be0              LDR      r0,[r4,#0x3c]
0001b6  2800              CMP      r0,#0
0001b8  bf18              IT       NE
0001ba  bd70              POPNE    {r4-r6,pc}
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       HAL_SD_GetCardState
0001c2  63a6              STR      r6,[r4,#0x38]
0001c4  f8845034          STRB     r5,[r4,#0x34]
0001c8  2806              CMP      r0,#6
0001ca  bf1c              ITT      NE
0001cc  2805              CMPNE    r0,#5
0001ce  bd70              POPNE    {r4-r6,pc}
0001d0  6820              LDR      r0,[r4,#0]
0001d2  f7fffffe          BL       SDMMC_CmdStopTransfer
0001d6  6ba1              LDR      r1,[r4,#0x38]
0001d8  4308              ORRS     r0,r0,r1
0001da  63a0              STR      r0,[r4,#0x38]
0001dc  6ba0              LDR      r0,[r4,#0x38]
0001de  b118              CBZ      r0,|L15.488|
                  |L15.480|
0001e0  4620              MOV      r0,r4
0001e2  f7fffffe          BL       HAL_SD_AbortCallback
0001e6  bd70              POP      {r4-r6,pc}
                  |L15.488|
0001e8  4620              MOV      r0,r4
0001ea  f7fffffe          BL       HAL_SD_ErrorCallback
0001ee  bd70              POP      {r4-r6,pc}
                  |L15.496|
0001f0  6be0              LDR      r0,[r4,#0x3c]         ;1531
0001f2  b328              CBZ      r0,|L15.576|
0001f4  491c              LDR      r1,|L15.616|
0001f6  6501              STR      r1,[r0,#0x50]         ;1536
0001f8  6be0              LDR      r0,[r4,#0x3c]         ;1536
0001fa  f7fffffe          BL       HAL_DMA_Abort_IT
0001fe  2800              CMP      r0,#0                 ;1536
000200  bf08              IT       EQ
000202  bd70              POPEQ    {r4-r6,pc}
000204  6be0              LDR      r0,[r4,#0x3c]
000206  6b84              LDR      r4,[r0,#0x38]
000208  6be0              LDR      r0,[r4,#0x3c]
00020a  2800              CMP      r0,#0
00020c  bf18              IT       NE
00020e  63e6              STRNE    r6,[r4,#0x3c]
000210  6c20              LDR      r0,[r4,#0x40]
000212  2800              CMP      r0,#0
000214  bf18              IT       NE
000216  bd70              POPNE    {r4-r6,pc}
000218  4620              MOV      r0,r4
00021a  f7fffffe          BL       HAL_SD_GetCardState
00021e  63a6              STR      r6,[r4,#0x38]
000220  f8845034          STRB     r5,[r4,#0x34]
000224  2806              CMP      r0,#6
000226  bf1c              ITT      NE
000228  2805              CMPNE    r0,#5
00022a  bd70              POPNE    {r4-r6,pc}
00022c  6820              LDR      r0,[r4,#0]
00022e  f7fffffe          BL       SDMMC_CmdStopTransfer
000232  6ba1              LDR      r1,[r4,#0x38]
000234  4308              ORRS     r0,r0,r1
000236  63a0              STR      r0,[r4,#0x38]
000238  6ba0              LDR      r0,[r4,#0x38]
00023a  2800              CMP      r0,#0
00023c  d0d4              BEQ      |L15.488|
00023e  e7cf              B        |L15.480|
                  |L15.576|
000240  63a6              STR      r6,[r4,#0x38]         ;1543
000242  f8845034          STRB     r5,[r4,#0x34]         ;1544
000246  4620              MOV      r0,r4                 ;1545
000248  f7fffffe          BL       HAL_SD_AbortCallback
00024c  bd70              POP      {r4-r6,pc}
                  |L15.590|
00024e  6b20              LDR      r0,[r4,#0x30]         ;1548
000250  f0100f08          TST      r0,#8                 ;1548
000254  bf08              IT       EQ
000256  bd70              POPEQ    {r4-r6,pc}
000258  f8845034          STRB     r5,[r4,#0x34]         ;1551
00025c  4620              MOV      r0,r4                 ;1552
00025e  f7fffffe          BL       HAL_SD_ErrorCallback
000262  bd70              POP      {r4-r6,pc}
;;;1622   
                          ENDP

                  |L15.612|
                          DCD      SD_DMATxAbort
                  |L15.616|
                          DCD      SD_DMARxAbort

                          AREA ||i.HAL_SD_Init||, CODE, READONLY, ALIGN=1

                  HAL_SD_Init PROC
;;;306      */
;;;307    HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
000000  2800              CMP      r0,#0
;;;308    {
;;;309      /* Check the SD handle allocation */
;;;310      if(hsd == NULL)
;;;311      {
;;;312        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;313      }
;;;314    
;;;315      /* Check the parameters */
;;;316      assert_param(IS_SDIO_ALL_INSTANCE(hsd->Instance));
;;;317      assert_param(IS_SDIO_CLOCK_EDGE(hsd->Init.ClockEdge));
;;;318      assert_param(IS_SDIO_CLOCK_BYPASS(hsd->Init.ClockBypass));
;;;319      assert_param(IS_SDIO_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
;;;320      assert_param(IS_SDIO_BUS_WIDE(hsd->Init.BusWide));
;;;321      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
;;;322      assert_param(IS_SDIO_CLKDIV(hsd->Init.ClockDiv));
;;;323    
;;;324      if(hsd->State == HAL_SD_STATE_RESET)
;;;325      {
;;;326        /* Allocate lock resource and initialize it */
;;;327        hsd->Lock = HAL_UNLOCKED;
;;;328        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;329        HAL_SD_MspInit(hsd);
;;;330      }
;;;331    
;;;332      hsd->State = HAL_SD_STATE_BUSY;
;;;333    
;;;334      /* Initialize the Card parameters */
;;;335      HAL_SD_InitCard(hsd);
;;;336    
;;;337      /* Initialize the error code */
;;;338      hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;339      
;;;340      /* Initialize the SD operation */
;;;341      hsd->Context = SD_CONTEXT_NONE;
;;;342                                                                                         
;;;343      /* Initialize the SD state */
;;;344      hsd->State = HAL_SD_STATE_READY;
;;;345    
;;;346      return HAL_OK;
;;;347    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;308
00000a  4604              MOV      r4,r0                 ;308
00000c  f8900034          LDRB     r0,[r0,#0x34]         ;324
000010  2500              MOVS     r5,#0                 ;324
000012  b918              CBNZ     r0,|L16.28|
000014  7725              STRB     r5,[r4,#0x1c]         ;327
000016  4620              MOV      r0,r4                 ;329
000018  f7fffffe          BL       HAL_SD_MspInit
                  |L16.28|
00001c  2003              MOVS     r0,#3                 ;332
00001e  f8840034          STRB     r0,[r4,#0x34]         ;332
000022  4620              MOV      r0,r4                 ;335
000024  f7fffffe          BL       HAL_SD_InitCard
000028  63a5              STR      r5,[r4,#0x38]         ;338
00002a  6325              STR      r5,[r4,#0x30]         ;341
00002c  2001              MOVS     r0,#1                 ;344
00002e  f8840034          STRB     r0,[r4,#0x34]         ;344
000032  2000              MOVS     r0,#0                 ;346
000034  bd70              POP      {r4-r6,pc}
;;;348    
                          ENDP


                          AREA ||i.HAL_SD_InitCard||, CODE, READONLY, ALIGN=2

                  HAL_SD_InitCard PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;357    {
;;;358      uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;359      SD_InitTypeDef Init;
;;;360      
;;;361      /* Default SDIO peripheral configuration for SD card initialization */
;;;362      Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
000004  2500              MOVS     r5,#0
000006  b091              SUB      sp,sp,#0x44           ;357
000008  4604              MOV      r4,r0                 ;357
;;;363      Init.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
;;;364      Init.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
;;;365      Init.BusWide             = SDIO_BUS_WIDE_1B;
;;;366      Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
;;;367      Init.ClockDiv            = SDIO_INIT_CLK_DIV;
00000a  2076              MOVS     r0,#0x76
;;;368    
;;;369      /* Initialize SDIO peripheral interface with default configuration */
;;;370      SDIO_Init(hsd->Instance, Init);
00000c  9500              STR      r5,[sp,#0]
00000e  e9cd5001          STRD     r5,r0,[sp,#4]
000012  462b              MOV      r3,r5
000014  462a              MOV      r2,r5
000016  4629              MOV      r1,r5
000018  6820              LDR      r0,[r4,#0]
00001a  f7fffffe          BL       SDIO_Init
;;;371    
;;;372      /* Disable SDIO Clock */
;;;373      __HAL_SD_DISABLE(hsd); 
00001e  4f68              LDR      r7,|L17.448|
000020  f8475fa0          STR      r5,[r7,#0xa0]!
;;;374      
;;;375      /* Set Power State to ON */
;;;376      SDIO_PowerState_ON(hsd->Instance);
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       SDIO_PowerState_ON
;;;377      
;;;378      /* Enable SDIO Clock */
;;;379      __HAL_SD_ENABLE(hsd);
00002a  2601              MOVS     r6,#1
00002c  603e              STR      r6,[r7,#0]
;;;380      
;;;381      /* Required power up waiting time before starting the SD initialization 
;;;382      sequence */
;;;383      HAL_Delay(2U);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       HAL_Delay
000034  9500              STR      r5,[sp,#0]
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       SDMMC_CmdGoIdleState
00003c  2800              CMP      r0,#0
00003e  d17d              BNE      |L17.316|
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       SDMMC_CmdOperCond
000046  f04f7880          MOV      r8,#0x1000000
00004a  f64f77ff          MOV      r7,#0xffff
00004e  2800              CMP      r0,#0
000050  bf1a              ITTE     NE
000052  64a5              STRNE    r5,[r4,#0x48]
000054  f04f5980          MOVNE    r9,#0x10000000
000058  64a6              STREQ    r6,[r4,#0x48]
00005a  d017              BEQ      |L17.140|
                  |L17.92|
00005c  9800              LDR      r0,[sp,#0]
00005e  1c41              ADDS     r1,r0,#1
000060  9100              STR      r1,[sp,#0]
000062  42b8              CMP      r0,r7
000064  d017              BEQ      |L17.150|
000066  2100              MOVS     r1,#0
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       SDMMC_CmdAppCommand
00006e  b920              CBNZ     r0,|L17.122|
000070  2100              MOVS     r1,#0
000072  6820              LDR      r0,[r4,#0]
000074  f7fffffe          BL       SDMMC_CmdAppOperCommand
000078  b108              CBZ      r0,|L17.126|
                  |L17.122|
00007a  4648              MOV      r0,r9
00007c  e088              B        |L17.400|
                  |L17.126|
00007e  2100              MOVS     r1,#0
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       SDIO_GetResponse
000086  0fc0              LSRS     r0,r0,#31
000088  d0e8              BEQ      |L17.92|
00008a  e01e              B        |L17.202|
                  |L17.140|
00008c  9800              LDR      r0,[sp,#0]
00008e  1c41              ADDS     r1,r0,#1
000090  9100              STR      r1,[sp,#0]
000092  42b8              CMP      r0,r7
000094  d101              BNE      |L17.154|
                  |L17.150|
000096  4640              MOV      r0,r8
000098  e07a              B        |L17.400|
                  |L17.154|
00009a  2100              MOVS     r1,#0
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       SDMMC_CmdAppCommand
0000a2  2800              CMP      r0,#0
0000a4  d174              BNE      |L17.400|
0000a6  f04f4180          MOV      r1,#0x40000000
0000aa  6820              LDR      r0,[r4,#0]
0000ac  f7fffffe          BL       SDMMC_CmdAppOperCommand
0000b0  2800              CMP      r0,#0
0000b2  d16d              BNE      |L17.400|
0000b4  2100              MOVS     r1,#0
0000b6  6820              LDR      r0,[r4,#0]
0000b8  f7fffffe          BL       SDIO_GetResponse
0000bc  0fc1              LSRS     r1,r0,#31
0000be  d0e5              BEQ      |L17.140|
0000c0  f0104f80          TST      r0,#0x40000000
0000c4  bf18              IT       NE
0000c6  6466              STRNE    r6,[r4,#0x44]
0000c8  d100              BNE      |L17.204|
                  |L17.202|
0000ca  6465              STR      r5,[r4,#0x44]
                  |L17.204|
0000cc  f8ad6010          STRH     r6,[sp,#0x10]
0000d0  6820              LDR      r0,[r4,#0]
0000d2  f7fffffe          BL       SDIO_GetPowerState
0000d6  2800              CMP      r0,#0
0000d8  bf08              IT       EQ
0000da  f04f6080          MOVEQ    r0,#0x4000000
0000de  d057              BEQ      |L17.400|
0000e0  6c60              LDR      r0,[r4,#0x44]
0000e2  2803              CMP      r0,#3
0000e4  d042              BEQ      |L17.364|
0000e6  6820              LDR      r0,[r4,#0]
0000e8  f7fffffe          BL       SDMMC_CmdSendCID
0000ec  2800              CMP      r0,#0
0000ee  d14f              BNE      |L17.400|
0000f0  2100              MOVS     r1,#0
0000f2  6820              LDR      r0,[r4,#0]
0000f4  f7fffffe          BL       SDIO_GetResponse
0000f8  6760              STR      r0,[r4,#0x74]
0000fa  2104              MOVS     r1,#4
0000fc  6820              LDR      r0,[r4,#0]
0000fe  f7fffffe          BL       SDIO_GetResponse
000102  67a0              STR      r0,[r4,#0x78]
000104  2108              MOVS     r1,#8
000106  6820              LDR      r0,[r4,#0]
000108  f7fffffe          BL       SDIO_GetResponse
00010c  67e0              STR      r0,[r4,#0x7c]
00010e  210c              MOVS     r1,#0xc
000110  6820              LDR      r0,[r4,#0]
000112  f7fffffe          BL       SDIO_GetResponse
000116  f8c40080          STR      r0,[r4,#0x80]
00011a  6c60              LDR      r0,[r4,#0x44]
00011c  2803              CMP      r0,#3
00011e  d025              BEQ      |L17.364|
000120  a904              ADD      r1,sp,#0x10
000122  6820              LDR      r0,[r4,#0]
000124  f7fffffe          BL       SDMMC_CmdSetRelAdd
000128  b940              CBNZ     r0,|L17.316|
00012a  6c60              LDR      r0,[r4,#0x44]
00012c  2803              CMP      r0,#3
00012e  d01d              BEQ      |L17.364|
000130  f8bd0010          LDRH     r0,[sp,#0x10]
000134  6520              STR      r0,[r4,#0x50]
000136  0401              LSLS     r1,r0,#16
000138  6820              LDR      r0,[r4,#0]
00013a  e000              B        |L17.318|
                  |L17.316|
00013c  e028              B        |L17.400|
                  |L17.318|
00013e  f7fffffe          BL       SDMMC_CmdSendCSD
000142  bb28              CBNZ     r0,|L17.400|
000144  2100              MOVS     r1,#0
000146  6820              LDR      r0,[r4,#0]
000148  f7fffffe          BL       SDIO_GetResponse
00014c  6660              STR      r0,[r4,#0x64]
00014e  2104              MOVS     r1,#4
000150  6820              LDR      r0,[r4,#0]
000152  f7fffffe          BL       SDIO_GetResponse
000156  66a0              STR      r0,[r4,#0x68]
000158  2108              MOVS     r1,#8
00015a  6820              LDR      r0,[r4,#0]
00015c  f7fffffe          BL       SDIO_GetResponse
000160  66e0              STR      r0,[r4,#0x6c]
000162  210c              MOVS     r1,#0xc
000164  6820              LDR      r0,[r4,#0]
000166  f7fffffe          BL       SDIO_GetResponse
00016a  6720              STR      r0,[r4,#0x70]
                  |L17.364|
00016c  2104              MOVS     r1,#4
00016e  6820              LDR      r0,[r4,#0]
000170  f7fffffe          BL       SDIO_GetResponse
000174  0d01              LSRS     r1,r0,#20
000176  64e1              STR      r1,[r4,#0x4c]
000178  4620              MOV      r0,r4
00017a  a905              ADD      r1,sp,#0x14
00017c  f7fffffe          BL       HAL_SD_GetCardCSD
000180  f8b40050          LDRH     r0,[r4,#0x50]
000184  2300              MOVS     r3,#0
000186  0402              LSLS     r2,r0,#16
000188  6820              LDR      r0,[r4,#0]
00018a  f7fffffe          BL       SDMMC_CmdSelDesel
00018e  b140              CBZ      r0,|L17.418|
                  |L17.400|
;;;384      
;;;385      /* Identify card operating voltage */
;;;386      errorstate = SD_PowerON(hsd);
;;;387      if(errorstate != HAL_SD_ERROR_NONE)
;;;388      {
;;;389        hsd->State = HAL_SD_STATE_READY;
;;;390        hsd->ErrorCode |= errorstate;
;;;391        return HAL_ERROR;
;;;392      }
;;;393    
;;;394      /* Card initialization */
;;;395      errorstate = SD_InitCard(hsd);
;;;396      if(errorstate != HAL_SD_ERROR_NONE)
;;;397      {
;;;398        hsd->State = HAL_SD_STATE_READY;
000190  f8846034          STRB     r6,[r4,#0x34]
;;;399        hsd->ErrorCode |= errorstate;
000194  6ba1              LDR      r1,[r4,#0x38]
000196  4308              ORRS     r0,r0,r1
000198  63a0              STR      r0,[r4,#0x38]
;;;400        return HAL_ERROR;
;;;401      }
;;;402    
;;;403      return HAL_OK;
;;;404    }
00019a  b011              ADD      sp,sp,#0x44
00019c  2001              MOVS     r0,#1                 ;400
00019e  e8bd83f0          POP      {r4-r9,pc}
                  |L17.418|
0001a2  e9d40104          LDRD     r0,r1,[r4,#0x10]
0001a6  69a2              LDR      r2,[r4,#0x18]
0001a8  9202              STR      r2,[sp,#8]
0001aa  e9cd0100          STRD     r0,r1,[sp,#0]
0001ae  e894000f          LDM      r4,{r0-r3}
0001b2  f7fffffe          BL       SDIO_Init
0001b6  b011              ADD      sp,sp,#0x44
0001b8  2000              MOVS     r0,#0                 ;403
0001ba  e8bd83f0          POP      {r4-r9,pc}
;;;405    
                          ENDP

0001be  0000              DCW      0x0000
                  |L17.448|
                          DCD      0x42258000

                          AREA ||i.HAL_SD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspDeInit PROC
;;;456      */
;;;457    __weak void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;458    {
;;;459      /* Prevent unused argument(s) compilation warning */
;;;460      UNUSED(hsd);
;;;461     
;;;462      /* NOTE : This function Should not be modified, when the callback is needed,
;;;463                the HAL_SD_MspDeInit could be implemented in the user file
;;;464       */
;;;465    }
;;;466    
                          ENDP


                          AREA ||i.HAL_SD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspInit PROC
;;;441      */
;;;442    __weak void HAL_SD_MspInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;443    {
;;;444      /* Prevent unused argument(s) compilation warning */
;;;445      UNUSED(hsd);
;;;446     
;;;447      /* NOTE : This function Should not be modified, when the callback is needed,
;;;448                the HAL_SD_MspInit could be implemented in the user file
;;;449       */
;;;450    }
;;;451    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks||, CODE, READONLY, ALIGN=1

                  HAL_SD_ReadBlocks PROC
;;;497      */
;;;498    HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;499    {
000004  b087              SUB      sp,sp,#0x1c
000006  4699              MOV      r9,r3
000008  4692              MOV      r10,r2
00000a  460d              MOV      r5,r1
00000c  4604              MOV      r4,r0
;;;500      SDIO_DataInitTypeDef config;
;;;501      uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;502      uint32_t tickstart = HAL_GetTick();
00000e  9e10              LDR      r6,[sp,#0x40]
000010  f7fffffe          BL       HAL_GetTick
000014  4683              MOV      r11,r0
;;;503      uint32_t count = 0U, *tempbuff = (uint32_t *)pData;
;;;504      
;;;505      if(NULL == pData)
000016  b14d              CBZ      r5,|L20.44|
;;;506      {
;;;507        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;508        return HAL_ERROR;
;;;509      }
;;;510     
;;;511      if(hsd->State == HAL_SD_STATE_READY)
000018  f8940034          LDRB     r0,[r4,#0x34]
00001c  2801              CMP      r0,#1
;;;512      {
;;;513        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;514        
;;;515        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;516        {
;;;517          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;518          return HAL_ERROR;
;;;519        }
;;;520        
;;;521        hsd->State = HAL_SD_STATE_BUSY;
;;;522        
;;;523        /* Initialize data control register */
;;;524        hsd->Instance->DCTRL = 0U;
;;;525        
;;;526        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;527        {
;;;528          BlockAdd *= 512U;
;;;529        }
;;;530          
;;;531        /* Set Block Size for Card */
;;;532        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;533        if(errorstate != HAL_SD_ERROR_NONE)
;;;534        {
;;;535          /* Clear all the static flags */
;;;536          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);      
;;;537          hsd->ErrorCode |= errorstate;
;;;538          hsd->State = HAL_SD_STATE_READY;
;;;539          return HAL_ERROR;
;;;540        }
;;;541        
;;;542        /* Configure the SD DPSM (Data Path State Machine) */
;;;543        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;544        config.DataLength    = NumberOfBlocks * BLOCKSIZE;
;;;545        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;546        config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;547        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;548        config.DPSM          = SDIO_DPSM_ENABLE;
;;;549        SDIO_ConfigData(hsd->Instance, &config);
;;;550        
;;;551        /* Read block(s) in polling mode */
;;;552        if(NumberOfBlocks > 1U)
;;;553        {
;;;554          hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
;;;555          
;;;556          /* Read Multi Block command */ 
;;;557          errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;558        }
;;;559        else
;;;560        {
;;;561          hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
;;;562          
;;;563          /* Read Single Block command */
;;;564          errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;565        }
;;;566        if(errorstate != HAL_SD_ERROR_NONE)
;;;567        {
;;;568          /* Clear all the static flags */
;;;569          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;570          hsd->ErrorCode |= errorstate;
;;;571          hsd->State = HAL_SD_STATE_READY;
;;;572          return HAL_ERROR;
;;;573        }
;;;574          
;;;575        /* Poll on SDIO flags */
;;;576    #ifdef SDIO_STA_STBITERR
;;;577        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_STA_STBITERR))
;;;578    #else /* SDIO_STA_STBITERR not defined */
;;;579        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;580    #endif /* SDIO_STA_STBITERR */
;;;581        {
;;;582          if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;583          {
;;;584            /* Read data from SDIO Rx FIFO */
;;;585            for(count = 0U; count < 8U; count++)
;;;586            {
;;;587              *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
;;;588            }
;;;589            tempbuff += 8U;
;;;590          }
;;;591          
;;;592          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;593          {
;;;594            /* Clear all the static flags */
;;;595            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;596            hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
;;;597            hsd->State= HAL_SD_STATE_READY;
;;;598            return HAL_TIMEOUT;
;;;599          }
;;;600        }
;;;601        
;;;602        /* Send stop transmission command in case of multiblock read */
;;;603        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
;;;604        {    
;;;605          if(hsd->SdCard.CardType != CARD_SECURED)
;;;606          {
;;;607            /* Send stop transmission command */
;;;608            errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;609            if(errorstate != HAL_SD_ERROR_NONE)
;;;610            {
;;;611              /* Clear all the static flags */
;;;612              __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;613              hsd->ErrorCode |= errorstate;
;;;614              hsd->State = HAL_SD_STATE_READY;
;;;615              return HAL_ERROR;
;;;616            }
;;;617          }
;;;618        }
;;;619        
;;;620        /* Get error state */
;;;621        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;622        {
;;;623          /* Clear all the static flags */
;;;624          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;625          hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
;;;626          hsd->State = HAL_SD_STATE_READY;
;;;627          return HAL_ERROR;
;;;628        }
;;;629        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;630        {
;;;631          /* Clear all the static flags */
;;;632          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;633          hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
;;;634          hsd->State = HAL_SD_STATE_READY;
;;;635          return HAL_ERROR;
;;;636        }
;;;637        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;638        {
;;;639          /* Clear all the static flags */
;;;640          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;641          hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
;;;642          hsd->State = HAL_SD_STATE_READY;
;;;643          return HAL_ERROR;
;;;644        }
;;;645        
;;;646        /* Empty FIFO if there is still any data */
;;;647        while ((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)))
;;;648        {
;;;649          *tempbuff = SDIO_ReadFIFO(hsd->Instance);
;;;650          tempbuff++;
;;;651          
;;;652          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;653          {
;;;654            /* Clear all the static flags */
;;;655            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);        
;;;656            hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
;;;657            hsd->State= HAL_SD_STATE_READY;
;;;658            return HAL_ERROR;
;;;659          }
;;;660        }
;;;661        
;;;662        /* Clear all the static flags */
;;;663        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;664        
;;;665        hsd->State = HAL_SD_STATE_READY;
;;;666        
;;;667        return HAL_OK;
;;;668      }
;;;669      else
;;;670      {
;;;671        hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
00001e  bf1c              ITT      NE
000020  6ba0              LDRNE    r0,[r4,#0x38]
000022  f0405000          ORRNE    r0,r0,#0x20000000
000026  d006              BEQ      |L20.54|
                  |L20.40|
000028  63a0              STR      r0,[r4,#0x38]         ;517
00002a  e0a8              B        |L20.382|
                  |L20.44|
00002c  6ba0              LDR      r0,[r4,#0x38]         ;507
00002e  f0406000          ORR      r0,r0,#0x8000000      ;507
000032  63a0              STR      r0,[r4,#0x38]         ;507
000034  e0a3              B        |L20.382|
                  |L20.54|
000036  2700              MOVS     r7,#0                 ;513
000038  63a7              STR      r7,[r4,#0x38]         ;513
00003a  6de1              LDR      r1,[r4,#0x5c]         ;515
00003c  eb0a0009          ADD      r0,r10,r9             ;515
000040  4288              CMP      r0,r1                 ;515
000042  bf84              ITT      HI                    ;517
000044  6ba0              LDRHI    r0,[r4,#0x38]         ;517
000046  f0407000          ORRHI    r0,r0,#0x2000000      ;517
00004a  d8ed              BHI      |L20.40|
00004c  2003              MOVS     r0,#3                 ;521
00004e  f8840034          STRB     r0,[r4,#0x34]         ;521
000052  6820              LDR      r0,[r4,#0]            ;524
000054  62c7              STR      r7,[r0,#0x2c]         ;524
000056  6c60              LDR      r0,[r4,#0x44]         ;526
000058  2801              CMP      r0,#1                 ;526
00005a  bf18              IT       NE                    ;528
00005c  ea4f2a4a          LSLNE    r10,r10,#9            ;528
000060  f44f7100          MOV      r1,#0x200             ;532
000064  6820              LDR      r0,[r4,#0]            ;532
000066  f7fffffe          BL       SDMMC_CmdBlockLength
00006a  f24058ff          MOV      r8,#0x5ff             ;536
00006e  2101              MOVS     r1,#1                 ;508
000070  b140              CBZ      r0,|L20.132|
000072  6822              LDR      r2,[r4,#0]            ;536
000074  f8c28038          STR      r8,[r2,#0x38]         ;536
000078  6ba2              LDR      r2,[r4,#0x38]         ;537
00007a  4310              ORRS     r0,r0,r2              ;537
00007c  63a0              STR      r0,[r4,#0x38]         ;537
00007e  f8841034          STRB     r1,[r4,#0x34]         ;538
000082  e07c              B        |L20.382|
                  |L20.132|
000084  f04f30ff          MOV      r0,#0xffffffff        ;543
000088  9000              STR      r0,[sp,#0]            ;544
00008a  ea4f2049          LSL      r0,r9,#9              ;544
00008e  9001              STR      r0,[sp,#4]            ;545
000090  2090              MOVS     r0,#0x90              ;545
000092  9002              STR      r0,[sp,#8]            ;546
000094  2002              MOVS     r0,#2                 ;546
000096  e9cd0703          STRD     r0,r7,[sp,#0xc]       ;546
00009a  9105              STR      r1,[sp,#0x14]         ;549
00009c  460f              MOV      r7,r1                 ;548
00009e  4669              MOV      r1,sp                 ;549
0000a0  6820              LDR      r0,[r4,#0]            ;549
0000a2  f7fffffe          BL       SDIO_ConfigData
0000a6  f1b90f01          CMP      r9,#1                 ;552
0000aa  d906              BLS      |L20.186|
0000ac  2002              MOVS     r0,#2                 ;554
0000ae  6320              STR      r0,[r4,#0x30]         ;554
0000b0  4651              MOV      r1,r10                ;557
0000b2  6820              LDR      r0,[r4,#0]            ;557
0000b4  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000b8  e004              B        |L20.196|
                  |L20.186|
0000ba  6327              STR      r7,[r4,#0x30]         ;561
0000bc  4651              MOV      r1,r10                ;564
0000be  6820              LDR      r0,[r4,#0]            ;564
0000c0  f7fffffe          BL       SDMMC_CmdReadSingleBlock
                  |L20.196|
0000c4  bbf0              CBNZ     r0,|L20.324|
0000c6  6820              LDR      r0,[r4,#0]            ;577
0000c8  6b41              LDR      r1,[r0,#0x34]         ;577
0000ca  f240302a          MOV      r0,#0x32a             ;577
0000ce  4201              TST      r1,r0                 ;577
0000d0  d12c              BNE      |L20.300|
                  |L20.210|
0000d2  6820              LDR      r0,[r4,#0]            ;582
0000d4  6b40              LDR      r0,[r0,#0x34]         ;582
0000d6  f4104f00          TST      r0,#0x8000            ;582
0000da  bf18              IT       NE                    ;585
0000dc  f04f0a00          MOVNE    r10,#0                ;585
0000e0  d00a              BEQ      |L20.248|
                  |L20.226|
0000e2  6820              LDR      r0,[r4,#0]            ;587
0000e4  f7fffffe          BL       SDIO_ReadFIFO
0000e8  f845002a          STR      r0,[r5,r10,LSL #2]    ;587
0000ec  f10a0a01          ADD      r10,r10,#1            ;587
0000f0  f1ba0f08          CMP      r10,#8                ;585
0000f4  d3f5              BCC      |L20.226|
0000f6  3520              ADDS     r5,r5,#0x20           ;585
                  |L20.248|
0000f8  b12e              CBZ      r6,|L20.262|
0000fa  f7fffffe          BL       HAL_GetTick
0000fe  eba0000b          SUB      r0,r0,r11             ;592
000102  42b0              CMP      r0,r6                 ;592
000104  d30c              BCC      |L20.288|
                  |L20.262|
000106  6820              LDR      r0,[r4,#0]            ;595
000108  f8c08038          STR      r8,[r0,#0x38]         ;595
00010c  6ba0              LDR      r0,[r4,#0x38]         ;596
00010e  f0404000          ORR      r0,r0,#0x80000000     ;596
000112  63a0              STR      r0,[r4,#0x38]         ;596
000114  f8847034          STRB     r7,[r4,#0x34]         ;597
;;;672        return HAL_ERROR;
;;;673      }
;;;674    }
000118  b007              ADD      sp,sp,#0x1c
00011a  2003              MOVS     r0,#3                 ;598
00011c  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.288|
000120  6820              LDR      r0,[r4,#0]            ;577
000122  6b41              LDR      r1,[r0,#0x34]         ;577
000124  f240302a          MOV      r0,#0x32a             ;577
000128  4201              TST      r1,r0                 ;577
00012a  d0d2              BEQ      |L20.210|
                  |L20.300|
00012c  6820              LDR      r0,[r4,#0]            ;603
00012e  6b41              LDR      r1,[r0,#0x34]         ;603
000130  f4117f80          TST      r1,#0x100             ;603
000134  bf18              IT       NE                    ;603
000136  f1b90f01          CMPNE    r9,#1                 ;603
00013a  d913              BLS      |L20.356|
00013c  6c61              LDR      r1,[r4,#0x44]         ;605
00013e  2903              CMP      r1,#3                 ;605
000140  d010              BEQ      |L20.356|
000142  e000              B        |L20.326|
                  |L20.324|
000144  e002              B        |L20.332|
                  |L20.326|
000146  f7fffffe          BL       SDMMC_CmdStopTransfer
00014a  b158              CBZ      r0,|L20.356|
                  |L20.332|
00014c  6821              LDR      r1,[r4,#0]            ;612
00014e  f8c18038          STR      r8,[r1,#0x38]         ;612
000152  6ba1              LDR      r1,[r4,#0x38]         ;613
000154  4308              ORRS     r0,r0,r1              ;613
000156  63a0              STR      r0,[r4,#0x38]         ;613
000158  f8847034          STRB     r7,[r4,#0x34]         ;614
00015c  b007              ADD      sp,sp,#0x1c
00015e  2001              MOVS     r0,#1                 ;615
000160  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.356|
000164  6820              LDR      r0,[r4,#0]            ;621
000166  6b41              LDR      r1,[r0,#0x34]         ;621
000168  f0110f08          TST      r1,#8                 ;621
00016c  d00b              BEQ      |L20.390|
00016e  f8c08038          STR      r8,[r0,#0x38]         ;624
000172  6ba0              LDR      r0,[r4,#0x38]         ;625
000174  f0400008          ORR      r0,r0,#8              ;625
000178  63a0              STR      r0,[r4,#0x38]         ;625
00017a  f8847034          STRB     r7,[r4,#0x34]         ;626
                  |L20.382|
00017e  b007              ADD      sp,sp,#0x1c
000180  2001              MOVS     r0,#1                 ;627
000182  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.390|
000186  6b41              LDR      r1,[r0,#0x34]         ;629
000188  f0110f02          TST      r1,#2                 ;629
00018c  d008              BEQ      |L20.416|
00018e  f8c08038          STR      r8,[r0,#0x38]         ;632
000192  6ba0              LDR      r0,[r4,#0x38]         ;633
000194  f0400002          ORR      r0,r0,#2              ;633
000198  63a0              STR      r0,[r4,#0x38]         ;633
00019a  f8847034          STRB     r7,[r4,#0x34]         ;634
00019e  e7ee              B        |L20.382|
                  |L20.416|
0001a0  6b41              LDR      r1,[r0,#0x34]         ;637
0001a2  f0110f20          TST      r1,#0x20              ;637
0001a6  d008              BEQ      |L20.442|
0001a8  f8c08038          STR      r8,[r0,#0x38]         ;640
0001ac  6ba0              LDR      r0,[r4,#0x38]         ;641
0001ae  f0400020          ORR      r0,r0,#0x20           ;641
0001b2  63a0              STR      r0,[r4,#0x38]         ;641
0001b4  f8847034          STRB     r7,[r4,#0x34]         ;642
0001b8  e7e1              B        |L20.382|
                  |L20.442|
0001ba  6b40              LDR      r0,[r0,#0x34]         ;647
0001bc  f4101f00          TST      r0,#0x200000          ;647
0001c0  d01a              BEQ      |L20.504|
                  |L20.450|
0001c2  6820              LDR      r0,[r4,#0]            ;649
0001c4  f7fffffe          BL       SDIO_ReadFIFO
0001c8  f8450b04          STR      r0,[r5],#4            ;649
0001cc  b12e              CBZ      r6,|L20.474|
0001ce  f7fffffe          BL       HAL_GetTick
0001d2  eba0000b          SUB      r0,r0,r11             ;652
0001d6  42b0              CMP      r0,r6                 ;652
0001d8  d309              BCC      |L20.494|
                  |L20.474|
0001da  6820              LDR      r0,[r4,#0]            ;655
0001dc  f8c08038          STR      r8,[r0,#0x38]         ;655
0001e0  6ba0              LDR      r0,[r4,#0x38]         ;656
0001e2  f0404000          ORR      r0,r0,#0x80000000     ;656
0001e6  63a0              STR      r0,[r4,#0x38]         ;656
0001e8  f8847034          STRB     r7,[r4,#0x34]         ;657
0001ec  e7c7              B        |L20.382|
                  |L20.494|
0001ee  6820              LDR      r0,[r4,#0]            ;647
0001f0  6b40              LDR      r0,[r0,#0x34]         ;647
0001f2  f4101f00          TST      r0,#0x200000          ;647
0001f6  d1e4              BNE      |L20.450|
                  |L20.504|
0001f8  6820              LDR      r0,[r4,#0]            ;663
0001fa  f8c08038          STR      r8,[r0,#0x38]         ;663
0001fe  f8847034          STRB     r7,[r4,#0x34]         ;665
000202  b007              ADD      sp,sp,#0x1c
000204  2000              MOVS     r0,#0                 ;667
000206  e8bd8ff0          POP      {r4-r11,pc}
;;;675    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_ReadBlocks_DMA PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1076   {
000004  b087              SUB      sp,sp,#0x1c
000006  4698              MOV      r8,r3
000008  4617              MOV      r7,r2
00000a  4604              MOV      r4,r0
00000c  b199              CBZ      r1,|L21.54|
;;;1077     SDIO_DataInitTypeDef config;
;;;1078     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;1079     
;;;1080     if(NULL == pData)
;;;1081     {
;;;1082       hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;1083       return HAL_ERROR;
;;;1084     }
;;;1085     
;;;1086     if(hsd->State == HAL_SD_STATE_READY)
00000e  f8940034          LDRB     r0,[r4,#0x34]
000012  2801              CMP      r0,#1
;;;1087     {
;;;1088       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;1089       
;;;1090       if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;1091       {
;;;1092         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1093         return HAL_ERROR;
;;;1094       }
;;;1095       
;;;1096       hsd->State = HAL_SD_STATE_BUSY;
;;;1097       
;;;1098       /* Initialize data control register */
;;;1099       hsd->Instance->DCTRL = 0U;
;;;1100       
;;;1101   #ifdef SDIO_STA_STBITER
;;;1102       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_IT_STBITERR));
;;;1103   #else /* SDIO_STA_STBITERR not defined */
;;;1104       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
;;;1105   #endif /* SDIO_STA_STBITERR */
;;;1106       
;;;1107       /* Set the DMA transfer complete callback */
;;;1108       hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
;;;1109       
;;;1110       /* Set the DMA error callback */
;;;1111       hsd->hdmarx->XferErrorCallback = SD_DMAError;
;;;1112       
;;;1113       /* Set the DMA Abort callback */
;;;1114       hsd->hdmarx->XferAbortCallback = NULL;
;;;1115       
;;;1116       /* Enable the DMA Channel */
;;;1117       HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
;;;1118       
;;;1119       /* Enable SD DMA transfer */
;;;1120       __HAL_SD_DMA_ENABLE(hsd);
;;;1121       
;;;1122       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1123       {
;;;1124         BlockAdd *= 512U;
;;;1125       }
;;;1126       
;;;1127       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1128       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1129       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1130       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1131       config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;1132       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1133       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1134       SDIO_ConfigData(hsd->Instance, &config);
;;;1135   
;;;1136       /* Set Block Size for Card */ 
;;;1137       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1138       if(errorstate != HAL_SD_ERROR_NONE)
;;;1139       {
;;;1140         /* Clear all the static flags */
;;;1141         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1142         hsd->ErrorCode |= errorstate;
;;;1143         hsd->State = HAL_SD_STATE_READY;
;;;1144         return HAL_ERROR;
;;;1145       }
;;;1146           
;;;1147       /* Read Blocks in DMA mode */
;;;1148       if(NumberOfBlocks > 1U)
;;;1149       {
;;;1150         hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
;;;1151         
;;;1152         /* Read Multi Block command */ 
;;;1153         errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157         hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
;;;1158         
;;;1159         /* Read Single Block command */ 
;;;1160         errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;1161       }
;;;1162       if(errorstate != HAL_SD_ERROR_NONE)
;;;1163       {
;;;1164         /* Clear all the static flags */
;;;1165         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1166         hsd->ErrorCode |= errorstate;
;;;1167         hsd->State = HAL_SD_STATE_READY;
;;;1168         return HAL_ERROR;
;;;1169       }
;;;1170   
;;;1171       return HAL_OK;
;;;1172     }
;;;1173     else
;;;1174     {
;;;1175       return HAL_BUSY;
000014  bf1e              ITTT     NE
000016  2002              MOVNE    r0,#2
;;;1176     }
;;;1177   }
000018  b007              ADDNE    sp,sp,#0x1c
00001a  e8bd83f0          POPNE    {r4-r9,pc}
00001e  2500              MOVS     r5,#0                 ;1088
000020  63a5              STR      r5,[r4,#0x38]         ;1088
000022  6de2              LDR      r2,[r4,#0x5c]         ;1090
000024  eb070008          ADD      r0,r7,r8              ;1090
000028  4290              CMP      r0,r2                 ;1090
00002a  d90c              BLS      |L21.70|
00002c  6ba0              LDR      r0,[r4,#0x38]         ;1092
00002e  f0407000          ORR      r0,r0,#0x2000000      ;1092
000032  63a0              STR      r0,[r4,#0x38]         ;1092
000034  e05e              B        |L21.244|
                  |L21.54|
000036  6ba0              LDR      r0,[r4,#0x38]         ;1082
000038  f0406000          ORR      r0,r0,#0x8000000      ;1082
00003c  63a0              STR      r0,[r4,#0x38]         ;1082
00003e  b007              ADD      sp,sp,#0x1c
000040  2001              MOVS     r0,#1                 ;1083
000042  e8bd83f0          POP      {r4-r9,pc}
                  |L21.70|
000046  2003              MOVS     r0,#3                 ;1096
000048  f8840034          STRB     r0,[r4,#0x34]         ;1096
00004c  6820              LDR      r0,[r4,#0]            ;1099
00004e  62c5              STR      r5,[r0,#0x2c]         ;1099
000050  6820              LDR      r0,[r4,#0]            ;1104
000052  6bc2              LDR      r2,[r0,#0x3c]         ;1104
000054  f4427295          ORR      r2,r2,#0x12a          ;1104
000058  63c2              STR      r2,[r0,#0x3c]         ;1104
00005a  6be2              LDR      r2,[r4,#0x3c]         ;1108
00005c  4827              LDR      r0,|L21.252|
00005e  ea4f2948          LSL      r9,r8,#9              ;1117
000062  63d0              STR      r0,[r2,#0x3c]         ;1111
000064  6be2              LDR      r2,[r4,#0x3c]         ;1111
000066  4826              LDR      r0,|L21.256|
000068  ea4f0399          LSR      r3,r9,#2              ;1117
00006c  64d0              STR      r0,[r2,#0x4c]         ;1114
00006e  6be0              LDR      r0,[r4,#0x3c]         ;1114
000070  460a              MOV      r2,r1                 ;1117
000072  6505              STR      r5,[r0,#0x50]         ;1117
000074  6820              LDR      r0,[r4,#0]            ;1117
000076  f1000c80          ADD      r12,r0,#0x80          ;1117
00007a  4661              MOV      r1,r12                ;1117
00007c  6be0              LDR      r0,[r4,#0x3c]         ;1117
00007e  f7fffffe          BL       HAL_DMA_Start_IT
000082  4820              LDR      r0,|L21.260|
000084  2601              MOVS     r6,#1                 ;1120
000086  6006              STR      r6,[r0,#0]            ;1120
000088  6c60              LDR      r0,[r4,#0x44]         ;1122
00008a  2801              CMP      r0,#1                 ;1122
00008c  bf18              IT       NE                    ;1124
00008e  027f              LSLNE    r7,r7,#9              ;1124
000090  f04f30ff          MOV      r0,#0xffffffff        ;1128
000094  e9cd0900          STRD     r0,r9,[sp,#0]         ;1128
000098  2090              MOVS     r0,#0x90              ;1130
00009a  9002              STR      r0,[sp,#8]            ;1131
00009c  2002              MOVS     r0,#2                 ;1131
00009e  9605              STR      r6,[sp,#0x14]         ;1133
0000a0  e9cd0503          STRD     r0,r5,[sp,#0xc]       ;1133
0000a4  4669              MOV      r1,sp                 ;1134
0000a6  6820              LDR      r0,[r4,#0]            ;1134
0000a8  f7fffffe          BL       SDIO_ConfigData
0000ac  f44f7100          MOV      r1,#0x200             ;1137
0000b0  6820              LDR      r0,[r4,#0]            ;1137
0000b2  f7fffffe          BL       SDMMC_CmdBlockLength
0000b6  f24055ff          MOV      r5,#0x5ff             ;1141
0000ba  b9a0              CBNZ     r0,|L21.230|
0000bc  f1b80f01          CMP      r8,#1                 ;1148
0000c0  d906              BLS      |L21.208|
0000c2  2082              MOVS     r0,#0x82              ;1150
0000c4  6320              STR      r0,[r4,#0x30]         ;1150
0000c6  4639              MOV      r1,r7                 ;1153
0000c8  6820              LDR      r0,[r4,#0]            ;1153
0000ca  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000ce  e005              B        |L21.220|
                  |L21.208|
0000d0  2081              MOVS     r0,#0x81              ;1157
0000d2  6320              STR      r0,[r4,#0x30]         ;1157
0000d4  4639              MOV      r1,r7                 ;1160
0000d6  6820              LDR      r0,[r4,#0]            ;1160
0000d8  f7fffffe          BL       SDMMC_CmdReadSingleBlock
                  |L21.220|
0000dc  2800              CMP      r0,#0                 ;1162
0000de  bf04              ITT      EQ
0000e0  b007              ADDEQ    sp,sp,#0x1c
0000e2  e8bd83f0          POPEQ    {r4-r9,pc}
                  |L21.230|
0000e6  6821              LDR      r1,[r4,#0]            ;1165
0000e8  638d              STR      r5,[r1,#0x38]         ;1165
0000ea  6ba1              LDR      r1,[r4,#0x38]         ;1166
0000ec  4308              ORRS     r0,r0,r1              ;1166
0000ee  63a0              STR      r0,[r4,#0x38]         ;1166
0000f0  f8846034          STRB     r6,[r4,#0x34]         ;1167
                  |L21.244|
0000f4  b007              ADD      sp,sp,#0x1c
0000f6  2001              MOVS     r0,#1                 ;1168
0000f8  e8bd83f0          POP      {r4-r9,pc}
;;;1178   
                          ENDP

                  |L21.252|
                          DCD      SD_DMAReceiveCplt
                  |L21.256|
                          DCD      SD_DMAError
                  |L21.260|
                          DCD      0x4225858c

                          AREA ||i.HAL_SD_ReadBlocks_IT||, CODE, READONLY, ALIGN=1

                  HAL_SD_ReadBlocks_IT PROC
;;;863      */
;;;864    HAL_StatusTypeDef HAL_SD_ReadBlocks_IT(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;865    {
000004  b086              SUB      sp,sp,#0x18
000006  461e              MOV      r6,r3
000008  4615              MOV      r5,r2
00000a  4604              MOV      r4,r0
00000c  b191              CBZ      r1,|L22.52|
;;;866      SDIO_DataInitTypeDef config;
;;;867      uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;868      
;;;869      if(NULL == pData)
;;;870      {
;;;871        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;872        return HAL_ERROR;
;;;873      }
;;;874      
;;;875      if(hsd->State == HAL_SD_STATE_READY)
00000e  f8940034          LDRB     r0,[r4,#0x34]
000012  2801              CMP      r0,#1
;;;876      {
;;;877        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;878        
;;;879        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;880        {
;;;881          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;882          return HAL_ERROR;
;;;883        }
;;;884        
;;;885        hsd->State = HAL_SD_STATE_BUSY;
;;;886        
;;;887        /* Initialize data control register */
;;;888        hsd->Instance->DCTRL = 0U;
;;;889        
;;;890        hsd->pRxBuffPtr = (uint32_t *)pData;
;;;891        hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
;;;892        
;;;893    #ifdef SDIO_STA_STBITER
;;;894        __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_FLAG_RXFIFOHF | SDIO_IT_STBITERR));
;;;895    #else /* SDIO_STA_STBITERR not defined */
;;;896        __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_FLAG_RXFIFOHF));
;;;897    #endif /* SDIO_STA_STBITERR */
;;;898        
;;;899        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;900        {
;;;901          BlockAdd *= 512U;
;;;902        }
;;;903        
;;;904        /* Configure the SD DPSM (Data Path State Machine) */ 
;;;905        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;906        config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;907        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;908        config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;909        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;910        config.DPSM          = SDIO_DPSM_ENABLE;
;;;911        SDIO_ConfigData(hsd->Instance, &config);
;;;912        
;;;913        /* Set Block Size for Card */ 
;;;914        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;915        if(errorstate != HAL_SD_ERROR_NONE)
;;;916        {
;;;917          /* Clear all the static flags */
;;;918          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;919          hsd->ErrorCode |= errorstate;
;;;920          hsd->State = HAL_SD_STATE_READY;
;;;921          return HAL_ERROR;
;;;922        }
;;;923    
;;;924        /* Read Blocks in IT mode */
;;;925        if(NumberOfBlocks > 1U)
;;;926        {
;;;927          hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_IT);
;;;928          
;;;929          /* Read Multi Block command */
;;;930          errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;931        }
;;;932        else
;;;933        {
;;;934          hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_IT);
;;;935          
;;;936          /* Read Single Block command */
;;;937          errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;938        }
;;;939        if(errorstate != HAL_SD_ERROR_NONE)
;;;940        {
;;;941          /* Clear all the static flags */
;;;942          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;943          hsd->ErrorCode |= errorstate;
;;;944          hsd->State = HAL_SD_STATE_READY;
;;;945          return HAL_ERROR;
;;;946        }
;;;947        
;;;948        return HAL_OK;
;;;949      }
;;;950      else
;;;951      {
;;;952        return HAL_BUSY;
000014  bf1e              ITTT     NE
000016  2002              MOVNE    r0,#2
;;;953      }
;;;954    }
000018  b006              ADDNE    sp,sp,#0x18
00001a  e8bd81f0          POPNE    {r4-r8,pc}
00001e  2000              MOVS     r0,#0                 ;877
000020  63a0              STR      r0,[r4,#0x38]         ;877
000022  6de3              LDR      r3,[r4,#0x5c]         ;879
000024  19aa              ADDS     r2,r5,r6              ;879
000026  429a              CMP      r2,r3                 ;879
000028  d90c              BLS      |L22.68|
00002a  6ba0              LDR      r0,[r4,#0x38]         ;881
00002c  f0407000          ORR      r0,r0,#0x2000000      ;881
000030  63a0              STR      r0,[r4,#0x38]         ;881
000032  e04c              B        |L22.206|
                  |L22.52|
000034  6ba0              LDR      r0,[r4,#0x38]         ;871
000036  f0406000          ORR      r0,r0,#0x8000000      ;871
00003a  63a0              STR      r0,[r4,#0x38]         ;871
00003c  b006              ADD      sp,sp,#0x18
00003e  2001              MOVS     r0,#1                 ;872
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L22.68|
000044  2203              MOVS     r2,#3                 ;885
000046  f8842034          STRB     r2,[r4,#0x34]         ;885
00004a  6822              LDR      r2,[r4,#0]            ;888
00004c  62d0              STR      r0,[r2,#0x2c]         ;888
00004e  62a1              STR      r1,[r4,#0x28]         ;891
000050  0271              LSLS     r1,r6,#9              ;891
000052  62e1              STR      r1,[r4,#0x2c]         ;896
000054  6822              LDR      r2,[r4,#0]            ;896
000056  6bd3              LDR      r3,[r2,#0x3c]         ;896
000058  f2481c2a          MOV      r12,#0x812a           ;896
00005c  ea43030c          ORR      r3,r3,r12             ;896
000060  63d3              STR      r3,[r2,#0x3c]         ;896
000062  6c62              LDR      r2,[r4,#0x44]         ;899
000064  2a01              CMP      r2,#1                 ;899
000066  bf18              IT       NE                    ;901
000068  026d              LSLNE    r5,r5,#9              ;901
00006a  f04f32ff          MOV      r2,#0xffffffff        ;905
00006e  e9cd2100          STRD     r2,r1,[sp,#0]         ;905
000072  2190              MOVS     r1,#0x90              ;907
000074  9102              STR      r1,[sp,#8]            ;908
000076  2701              MOVS     r7,#1                 ;910
000078  2102              MOVS     r1,#2                 ;908
00007a  9705              STR      r7,[sp,#0x14]         ;910
00007c  e9cd1003          STRD     r1,r0,[sp,#0xc]       ;910
000080  4669              MOV      r1,sp                 ;911
000082  6820              LDR      r0,[r4,#0]            ;911
000084  f7fffffe          BL       SDIO_ConfigData
000088  0279              LSLS     r1,r7,#9              ;914
00008a  6820              LDR      r0,[r4,#0]            ;914
00008c  f7fffffe          BL       SDMMC_CmdBlockLength
000090  f24058ff          MOV      r8,#0x5ff             ;918
000094  b998              CBNZ     r0,|L22.190|
000096  2e01              CMP      r6,#1                 ;925
000098  d906              BLS      |L22.168|
00009a  200a              MOVS     r0,#0xa               ;927
00009c  6320              STR      r0,[r4,#0x30]         ;927
00009e  4629              MOV      r1,r5                 ;930
0000a0  6820              LDR      r0,[r4,#0]            ;930
0000a2  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000a6  e005              B        |L22.180|
                  |L22.168|
0000a8  2009              MOVS     r0,#9                 ;934
0000aa  6320              STR      r0,[r4,#0x30]         ;934
0000ac  4629              MOV      r1,r5                 ;937
0000ae  6820              LDR      r0,[r4,#0]            ;937
0000b0  f7fffffe          BL       SDMMC_CmdReadSingleBlock
                  |L22.180|
0000b4  2800              CMP      r0,#0                 ;939
0000b6  bf04              ITT      EQ
0000b8  b006              ADDEQ    sp,sp,#0x18
0000ba  e8bd81f0          POPEQ    {r4-r8,pc}
                  |L22.190|
0000be  6821              LDR      r1,[r4,#0]            ;942
0000c0  f8c18038          STR      r8,[r1,#0x38]         ;942
0000c4  6ba1              LDR      r1,[r4,#0x38]         ;943
0000c6  4308              ORRS     r0,r0,r1              ;943
0000c8  63a0              STR      r0,[r4,#0x38]         ;943
0000ca  f8847034          STRB     r7,[r4,#0x34]         ;944
                  |L22.206|
0000ce  b006              ADD      sp,sp,#0x18
0000d0  2001              MOVS     r0,#1                 ;945
0000d2  e8bd81f0          POP      {r4-r8,pc}
;;;955    
                          ENDP


                          AREA ||i.HAL_SD_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_RxCpltCallback PROC
;;;1663     */
;;;1664   __weak void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1665   {
;;;1666     /* Prevent unused argument(s) compilation warning */
;;;1667     UNUSED(hsd);
;;;1668    
;;;1669     /* NOTE : This function should not be modified, when the callback is needed,
;;;1670               the HAL_SD_RxCpltCallback can be implemented in the user file
;;;1671      */
;;;1672   }
;;;1673   
                          ENDP


                          AREA ||i.HAL_SD_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_TxCpltCallback PROC
;;;1648     */
;;;1649    __weak void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1650   {
;;;1651     /* Prevent unused argument(s) compilation warning */
;;;1652     UNUSED(hsd);
;;;1653   
;;;1654     /* NOTE : This function should not be modified, when the callback is needed,
;;;1655               the HAL_SD_TxCpltCallback can be implemented in the user file
;;;1656      */
;;;1657   }
;;;1658   
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks||, CODE, READONLY, ALIGN=2

                  HAL_SD_WriteBlocks PROC
;;;687      */
;;;688    HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;689    {
000004  b089              SUB      sp,sp,#0x24
000006  4699              MOV      r9,r3
000008  4616              MOV      r6,r2
00000a  460d              MOV      r5,r1
00000c  4604              MOV      r4,r0
;;;690      SDIO_DataInitTypeDef config;
;;;691      uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;692      uint32_t tickstart = HAL_GetTick();
00000e  f8ddb048          LDR      r11,[sp,#0x48]
000012  f7fffffe          BL       HAL_GetTick
000016  4682              MOV      r10,r0
;;;693      uint32_t count = 0U;
;;;694      uint32_t *tempbuff = (uint32_t *)pData;
;;;695      
;;;696      if(NULL == pData)
000018  b14d              CBZ      r5,|L25.46|
;;;697      {
;;;698        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;699        return HAL_ERROR;
;;;700      }
;;;701    
;;;702      if(hsd->State == HAL_SD_STATE_READY)
00001a  f8940034          LDRB     r0,[r4,#0x34]
00001e  2801              CMP      r0,#1
;;;703      {
;;;704        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;705        
;;;706        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;707        {
;;;708          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;709          return HAL_ERROR;
;;;710        }
;;;711        
;;;712        hsd->State = HAL_SD_STATE_BUSY;
;;;713        
;;;714        /* Initialize data control register */
;;;715        hsd->Instance->DCTRL = 0U;
;;;716         
;;;717        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;718        {
;;;719          BlockAdd *= 512U;
;;;720        }
;;;721        
;;;722        /* Set Block Size for Card */ 
;;;723        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;724        if(errorstate != HAL_SD_ERROR_NONE)
;;;725        {
;;;726          /* Clear all the static flags */
;;;727          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;728          hsd->ErrorCode |= errorstate;
;;;729          hsd->State = HAL_SD_STATE_READY;
;;;730          return HAL_ERROR;
;;;731        }
;;;732        
;;;733        /* Write Blocks in Polling mode */
;;;734        if(NumberOfBlocks > 1U)
;;;735        {
;;;736          hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
;;;737          
;;;738          /* Write Multi Block command */ 
;;;739          errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;740        }
;;;741        else
;;;742        {
;;;743          hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
;;;744          
;;;745          /* Write Single Block command */
;;;746          errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;747        }
;;;748        if(errorstate != HAL_SD_ERROR_NONE)
;;;749        {
;;;750          /* Clear all the static flags */
;;;751          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;752          hsd->ErrorCode |= errorstate;
;;;753          hsd->State = HAL_SD_STATE_READY;
;;;754          return HAL_ERROR;
;;;755        }
;;;756        
;;;757        /* Configure the SD DPSM (Data Path State Machine) */ 
;;;758        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;759        config.DataLength    = NumberOfBlocks * BLOCKSIZE;
;;;760        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;761        config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;762        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;763        config.DPSM          = SDIO_DPSM_ENABLE;
;;;764        SDIO_ConfigData(hsd->Instance, &config);
;;;765        
;;;766        /* Write block(s) in polling mode */
;;;767    #ifdef SDIO_STA_STBITERR
;;;768        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
;;;769    #else /* SDIO_STA_STBITERR not defined */
;;;770        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;771    #endif /* SDIO_STA_STBITERR */
;;;772        {
;;;773          if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
;;;774          {
;;;775            /* Write data to SDIO Tx FIFO */
;;;776            for(count = 0U; count < 8U; count++)
;;;777            {
;;;778              SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
;;;779            }
;;;780            tempbuff += 8U;
;;;781          }
;;;782          
;;;783          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;784          {
;;;785            /* Clear all the static flags */
;;;786            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;787            hsd->ErrorCode |= errorstate;
;;;788            hsd->State = HAL_SD_STATE_READY;
;;;789            return HAL_TIMEOUT;
;;;790          }
;;;791        }
;;;792        
;;;793        /* Send stop transmission command in case of multiblock write */
;;;794        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
;;;795        { 
;;;796          if(hsd->SdCard.CardType != CARD_SECURED)
;;;797          {
;;;798            /* Send stop transmission command */
;;;799            errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;800            if(errorstate != HAL_SD_ERROR_NONE)
;;;801            {
;;;802              /* Clear all the static flags */
;;;803              __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;804              hsd->ErrorCode |= errorstate;
;;;805              hsd->State = HAL_SD_STATE_READY;
;;;806              return HAL_ERROR;
;;;807            }
;;;808          }
;;;809        }
;;;810        
;;;811        /* Get error state */
;;;812        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;813        {
;;;814          /* Clear all the static flags */
;;;815          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;816          hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
;;;817          hsd->State = HAL_SD_STATE_READY;
;;;818          return HAL_ERROR;
;;;819        }
;;;820        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;821        {
;;;822          /* Clear all the static flags */
;;;823          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;824          hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;      
;;;825          hsd->State = HAL_SD_STATE_READY;
;;;826          return HAL_ERROR;
;;;827        }
;;;828        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
;;;829        {
;;;830          /* Clear all the static flags */
;;;831          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;832          hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
;;;833          hsd->State = HAL_SD_STATE_READY;
;;;834          return HAL_ERROR;
;;;835        }
;;;836        
;;;837        /* Clear all the static flags */
;;;838        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;839        
;;;840        hsd->State = HAL_SD_STATE_READY;
;;;841        
;;;842        return HAL_OK;
;;;843      }
;;;844      else
;;;845      {
;;;846        hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
000020  bf1c              ITT      NE
000022  6ba0              LDRNE    r0,[r4,#0x38]
000024  f0405000          ORRNE    r0,r0,#0x20000000
000028  d006              BEQ      |L25.56|
                  |L25.42|
00002a  63a0              STR      r0,[r4,#0x38]         ;708
00002c  e0ac              B        |L25.392|
                  |L25.46|
00002e  6ba0              LDR      r0,[r4,#0x38]         ;698
000030  f0406000          ORR      r0,r0,#0x8000000      ;698
000034  63a0              STR      r0,[r4,#0x38]         ;698
000036  e0a7              B        |L25.392|
                  |L25.56|
000038  2100              MOVS     r1,#0                 ;704
00003a  63a1              STR      r1,[r4,#0x38]         ;704
00003c  6de2              LDR      r2,[r4,#0x5c]         ;706
00003e  eb060009          ADD      r0,r6,r9              ;706
000042  4290              CMP      r0,r2                 ;706
000044  bf84              ITT      HI                    ;708
000046  6ba0              LDRHI    r0,[r4,#0x38]         ;708
000048  f0407000          ORRHI    r0,r0,#0x2000000      ;708
00004c  d8ed              BHI      |L25.42|
00004e  2003              MOVS     r0,#3                 ;712
000050  f8840034          STRB     r0,[r4,#0x34]         ;712
000054  6821              LDR      r1,[r4,#0]            ;715
000056  2000              MOVS     r0,#0                 ;715
000058  62c8              STR      r0,[r1,#0x2c]         ;715
00005a  6c60              LDR      r0,[r4,#0x44]         ;717
00005c  2801              CMP      r0,#1                 ;717
00005e  bf18              IT       NE                    ;719
000060  0276              LSLNE    r6,r6,#9              ;719
000062  f44f7100          MOV      r1,#0x200             ;723
000066  6820              LDR      r0,[r4,#0]            ;723
000068  f7fffffe          BL       SDMMC_CmdBlockLength
00006c  2701              MOVS     r7,#1                 ;699
00006e  f24058ff          MOV      r8,#0x5ff             ;727
000072  2800              CMP      r0,#0                 ;724
000074  d16f              BNE      |L25.342|
000076  f1b90f01          CMP      r9,#1                 ;734
00007a  d906              BLS      |L25.138|
00007c  2020              MOVS     r0,#0x20              ;736
00007e  6320              STR      r0,[r4,#0x30]         ;736
000080  4631              MOV      r1,r6                 ;739
000082  6820              LDR      r0,[r4,#0]            ;739
000084  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
000088  e005              B        |L25.150|
                  |L25.138|
00008a  2010              MOVS     r0,#0x10              ;743
00008c  6320              STR      r0,[r4,#0x30]         ;743
00008e  4631              MOV      r1,r6                 ;746
000090  6820              LDR      r0,[r4,#0]            ;746
000092  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
                  |L25.150|
000096  9000              STR      r0,[sp,#0]            ;746
000098  b160              CBZ      r0,|L25.180|
00009a  6820              LDR      r0,[r4,#0]            ;751
00009c  f8c08038          STR      r8,[r0,#0x38]         ;751
0000a0  6ba1              LDR      r1,[r4,#0x38]         ;752
0000a2  9800              LDR      r0,[sp,#0]            ;752
0000a4  4308              ORRS     r0,r0,r1              ;752
0000a6  63a0              STR      r0,[r4,#0x38]         ;752
0000a8  f8847034          STRB     r7,[r4,#0x34]         ;753
;;;847        return HAL_ERROR;
;;;848      }
;;;849    }
0000ac  b009              ADD      sp,sp,#0x24
0000ae  2001              MOVS     r0,#1                 ;754
0000b0  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.180|
0000b4  f04f30ff          MOV      r0,#0xffffffff        ;758
0000b8  9002              STR      r0,[sp,#8]            ;759
0000ba  ea4f2049          LSL      r0,r9,#9              ;759
0000be  9003              STR      r0,[sp,#0xc]          ;760
0000c0  2090              MOVS     r0,#0x90              ;760
0000c2  9004              STR      r0,[sp,#0x10]         ;761
0000c4  2000              MOVS     r0,#0                 ;761
0000c6  e9cd0706          STRD     r0,r7,[sp,#0x18]      ;761
0000ca  9005              STR      r0,[sp,#0x14]         ;761
0000cc  a902              ADD      r1,sp,#8              ;764
0000ce  6820              LDR      r0,[r4,#0]            ;764
0000d0  f7fffffe          BL       SDIO_ConfigData
0000d4  6820              LDR      r0,[r4,#0]            ;768
0000d6  6b41              LDR      r1,[r0,#0x34]         ;768
0000d8  f240301a          MOV      r0,#0x31a             ;768
0000dc  4201              TST      r1,r0                 ;768
0000de  d12c              BNE      |L25.314|
                  |L25.224|
0000e0  6820              LDR      r0,[r4,#0]            ;773
0000e2  6b40              LDR      r0,[r0,#0x34]         ;773
0000e4  f4104f80          TST      r0,#0x4000            ;773
0000e8  bf18              IT       NE                    ;776
0000ea  2600              MOVNE    r6,#0                 ;776
0000ec  d009              BEQ      |L25.258|
0000ee  bf00              NOP                            ;778
                  |L25.240|
0000f0  eb050186          ADD      r1,r5,r6,LSL #2       ;778
0000f4  6820              LDR      r0,[r4,#0]            ;778
0000f6  f7fffffe          BL       SDIO_WriteFIFO
0000fa  1c76              ADDS     r6,r6,#1              ;778
0000fc  2e08              CMP      r6,#8                 ;776
0000fe  d3f7              BCC      |L25.240|
000100  3520              ADDS     r5,r5,#0x20           ;776
                  |L25.258|
000102  f1bb0f00          CMP      r11,#0                ;783
000106  d005              BEQ      |L25.276|
000108  f7fffffe          BL       HAL_GetTick
00010c  eba0000a          SUB      r0,r0,r10             ;783
000110  4558              CMP      r0,r11                ;783
000112  d30c              BCC      |L25.302|
                  |L25.276|
000114  6820              LDR      r0,[r4,#0]            ;786
000116  f8c08038          STR      r8,[r0,#0x38]         ;786
00011a  6ba1              LDR      r1,[r4,#0x38]         ;787
00011c  9800              LDR      r0,[sp,#0]            ;787
00011e  4308              ORRS     r0,r0,r1              ;787
000120  63a0              STR      r0,[r4,#0x38]         ;787
000122  f8847034          STRB     r7,[r4,#0x34]         ;788
000126  b009              ADD      sp,sp,#0x24
000128  2003              MOVS     r0,#3                 ;789
00012a  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.302|
00012e  6820              LDR      r0,[r4,#0]            ;768
000130  6b41              LDR      r1,[r0,#0x34]         ;768
000132  f240301a          MOV      r0,#0x31a             ;768
000136  4201              TST      r1,r0                 ;768
000138  d0d2              BEQ      |L25.224|
                  |L25.314|
00013a  6820              LDR      r0,[r4,#0]            ;794
00013c  6b41              LDR      r1,[r0,#0x34]         ;794
00013e  f4117f80          TST      r1,#0x100             ;794
000142  bf18              IT       NE                    ;794
000144  f1b90f01          CMPNE    r9,#1                 ;794
000148  d911              BLS      |L25.366|
00014a  6c61              LDR      r1,[r4,#0x44]         ;796
00014c  2903              CMP      r1,#3                 ;796
00014e  d00e              BEQ      |L25.366|
000150  f7fffffe          BL       SDMMC_CmdStopTransfer
000154  b158              CBZ      r0,|L25.366|
                  |L25.342|
000156  6821              LDR      r1,[r4,#0]            ;803
000158  f8c18038          STR      r8,[r1,#0x38]         ;803
00015c  6ba1              LDR      r1,[r4,#0x38]         ;804
00015e  4308              ORRS     r0,r0,r1              ;804
000160  63a0              STR      r0,[r4,#0x38]         ;804
000162  f8847034          STRB     r7,[r4,#0x34]         ;805
000166  b009              ADD      sp,sp,#0x24
000168  2001              MOVS     r0,#1                 ;806
00016a  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.366|
00016e  6820              LDR      r0,[r4,#0]            ;812
000170  6b41              LDR      r1,[r0,#0x34]         ;812
000172  f0110f08          TST      r1,#8                 ;812
000176  d00b              BEQ      |L25.400|
000178  f8c08038          STR      r8,[r0,#0x38]         ;815
00017c  6ba0              LDR      r0,[r4,#0x38]         ;816
00017e  f0400008          ORR      r0,r0,#8              ;816
000182  63a0              STR      r0,[r4,#0x38]         ;816
000184  f8847034          STRB     r7,[r4,#0x34]         ;817
                  |L25.392|
000188  b009              ADD      sp,sp,#0x24
00018a  2001              MOVS     r0,#1                 ;818
00018c  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.400|
000190  6b41              LDR      r1,[r0,#0x34]         ;820
000192  f0110f02          TST      r1,#2                 ;820
000196  d008              BEQ      |L25.426|
000198  f8c08038          STR      r8,[r0,#0x38]         ;823
00019c  6ba0              LDR      r0,[r4,#0x38]         ;824
00019e  f0400002          ORR      r0,r0,#2              ;824
0001a2  63a0              STR      r0,[r4,#0x38]         ;824
0001a4  f8847034          STRB     r7,[r4,#0x34]         ;825
0001a8  e7ee              B        |L25.392|
                  |L25.426|
0001aa  6b41              LDR      r1,[r0,#0x34]         ;828
0001ac  f8c08038          STR      r8,[r0,#0x38]         ;838
0001b0  f0110f10          TST      r1,#0x10              ;828
0001b4  bf01              ITTTT    EQ                    ;840
0001b6  f8847034          STRBEQ   r7,[r4,#0x34]         ;840
0001ba  2000              MOVEQ    r0,#0                 ;842
0001bc  b009              ADDEQ    sp,sp,#0x24
0001be  e8bd8ff0          POPEQ    {r4-r11,pc}
0001c2  6ba0              LDR      r0,[r4,#0x38]         ;832
0001c4  f0400010          ORR      r0,r0,#0x10           ;832
0001c8  63a0              STR      r0,[r4,#0x38]         ;832
0001ca  f8847034          STRB     r7,[r4,#0x34]         ;833
0001ce  e7db              B        |L25.392|
;;;850    
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_WriteBlocks_DMA PROC
;;;1191     */
;;;1192   HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1193   {
000004  b087              SUB      sp,sp,#0x1c
000006  4698              MOV      r8,r3
000008  ea5f0b01          MOVS     r11,r1
00000c  4604              MOV      r4,r0
00000e  4616              MOV      r6,r2
000010  d013              BEQ      |L26.58|
;;;1194     SDIO_DataInitTypeDef config;
;;;1195     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;1196     
;;;1197     if(NULL == pData)
;;;1198     {
;;;1199       hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;1200       return HAL_ERROR;
;;;1201     }
;;;1202     
;;;1203     if(hsd->State == HAL_SD_STATE_READY)
000012  f8940034          LDRB     r0,[r4,#0x34]
000016  2801              CMP      r0,#1
;;;1204     {
;;;1205       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;1206       
;;;1207       if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;1208       {
;;;1209         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1210         return HAL_ERROR;
;;;1211       }
;;;1212       
;;;1213       hsd->State = HAL_SD_STATE_BUSY;
;;;1214       
;;;1215       /* Initialize data control register */
;;;1216       hsd->Instance->DCTRL = 0U;
;;;1217       
;;;1218       /* Enable SD Error interrupts */  
;;;1219   #ifdef SDIO_STA_STBITER
;;;1220       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR));    
;;;1221   #else /* SDIO_STA_STBITERR not defined */
;;;1222       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR));    
;;;1223   #endif /* SDIO_STA_STBITERR */
;;;1224       
;;;1225       /* Set the DMA transfer complete callback */
;;;1226       hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
;;;1227       
;;;1228       /* Set the DMA error callback */
;;;1229       hsd->hdmatx->XferErrorCallback = SD_DMAError;
;;;1230       
;;;1231       /* Set the DMA Abort callback */
;;;1232       hsd->hdmatx->XferAbortCallback = NULL;
;;;1233       
;;;1234       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1235       {
;;;1236         BlockAdd *= 512U;
;;;1237       }
;;;1238       
;;;1239       /* Set Block Size for Card */ 
;;;1240       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1241       if(errorstate != HAL_SD_ERROR_NONE)
;;;1242       {
;;;1243         /* Clear all the static flags */
;;;1244         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1245         hsd->ErrorCode |= errorstate;
;;;1246         hsd->State = HAL_SD_STATE_READY;
;;;1247         return HAL_ERROR;
;;;1248       }
;;;1249       
;;;1250       /* Write Blocks in Polling mode */
;;;1251       if(NumberOfBlocks > 1U)
;;;1252       {
;;;1253         hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
;;;1254         
;;;1255         /* Write Multi Block command */ 
;;;1256         errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;1257       }
;;;1258       else
;;;1259       {
;;;1260         hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
;;;1261         
;;;1262         /* Write Single Block command */
;;;1263         errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;1264       }
;;;1265       if(errorstate != HAL_SD_ERROR_NONE)
;;;1266       {
;;;1267         /* Clear all the static flags */
;;;1268         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1269         hsd->ErrorCode |= errorstate;
;;;1270         hsd->State = HAL_SD_STATE_READY;
;;;1271         return HAL_ERROR;
;;;1272       }
;;;1273       
;;;1274       /* Enable SDIO DMA transfer */
;;;1275       __HAL_SD_DMA_ENABLE(hsd);
;;;1276       
;;;1277       /* Enable the DMA Channel */
;;;1278       HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
;;;1279       
;;;1280       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1281       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1282       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1283       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1284       config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;1285       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1286       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1287       SDIO_ConfigData(hsd->Instance, &config);
;;;1288       
;;;1289       return HAL_OK;
;;;1290     }
;;;1291     else
;;;1292     {
;;;1293       return HAL_BUSY;
000018  bf1e              ITTT     NE
00001a  2002              MOVNE    r0,#2
;;;1294     }
;;;1295   }
00001c  b007              ADDNE    sp,sp,#0x1c
00001e  e8bd8ff0          POPNE    {r4-r11,pc}
000022  2500              MOVS     r5,#0                 ;1205
000024  63a5              STR      r5,[r4,#0x38]         ;1205
000026  6de1              LDR      r1,[r4,#0x5c]         ;1207
000028  eb060008          ADD      r0,r6,r8              ;1207
00002c  4288              CMP      r0,r1                 ;1207
00002e  d90c              BLS      |L26.74|
000030  6ba0              LDR      r0,[r4,#0x38]         ;1209
000032  f0407000          ORR      r0,r0,#0x2000000      ;1209
000036  63a0              STR      r0,[r4,#0x38]         ;1209
000038  e041              B        |L26.190|
                  |L26.58|
00003a  6ba0              LDR      r0,[r4,#0x38]         ;1199
00003c  f0406000          ORR      r0,r0,#0x8000000      ;1199
000040  63a0              STR      r0,[r4,#0x38]         ;1199
000042  b007              ADD      sp,sp,#0x1c
000044  2001              MOVS     r0,#1                 ;1200
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.74|
00004a  2003              MOVS     r0,#3                 ;1213
00004c  f8840034          STRB     r0,[r4,#0x34]         ;1213
000050  6820              LDR      r0,[r4,#0]            ;1216
000052  62c5              STR      r5,[r0,#0x2c]         ;1216
000054  6820              LDR      r0,[r4,#0]            ;1222
000056  6bc1              LDR      r1,[r0,#0x3c]         ;1222
000058  f041011a          ORR      r1,r1,#0x1a           ;1222
00005c  63c1              STR      r1,[r0,#0x3c]         ;1222
00005e  6c21              LDR      r1,[r4,#0x40]         ;1226
000060  4827              LDR      r0,|L26.256|
000062  63c8              STR      r0,[r1,#0x3c]         ;1229
000064  6c21              LDR      r1,[r4,#0x40]         ;1229
000066  4827              LDR      r0,|L26.260|
000068  64c8              STR      r0,[r1,#0x4c]         ;1232
00006a  6c20              LDR      r0,[r4,#0x40]         ;1232
00006c  6505              STR      r5,[r0,#0x50]         ;1234
00006e  6c60              LDR      r0,[r4,#0x44]         ;1234
000070  2801              CMP      r0,#1                 ;1234
000072  bf18              IT       NE                    ;1236
000074  0256              LSLNE    r6,r2,#9              ;1236
000076  f44f7100          MOV      r1,#0x200             ;1240
00007a  6820              LDR      r0,[r4,#0]            ;1240
00007c  f7fffffe          BL       SDMMC_CmdBlockLength
000080  2701              MOVS     r7,#1                 ;1200
000082  f24059ff          MOV      r9,#0x5ff             ;1244
000086  b990              CBNZ     r0,|L26.174|
000088  f04f0a90          MOV      r10,#0x90             ;1260
00008c  f1b80f01          CMP      r8,#1                 ;1251
000090  d906              BLS      |L26.160|
000092  20a0              MOVS     r0,#0xa0              ;1253
000094  6320              STR      r0,[r4,#0x30]         ;1253
000096  4631              MOV      r1,r6                 ;1256
000098  6820              LDR      r0,[r4,#0]            ;1256
00009a  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
00009e  e005              B        |L26.172|
                  |L26.160|
0000a0  f8c4a030          STR      r10,[r4,#0x30]        ;1260
0000a4  4631              MOV      r1,r6                 ;1263
0000a6  6820              LDR      r0,[r4,#0]            ;1263
0000a8  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
                  |L26.172|
0000ac  b158              CBZ      r0,|L26.198|
                  |L26.174|
0000ae  6821              LDR      r1,[r4,#0]            ;1268
0000b0  f8c19038          STR      r9,[r1,#0x38]         ;1268
0000b4  6ba1              LDR      r1,[r4,#0x38]         ;1269
0000b6  4308              ORRS     r0,r0,r1              ;1269
0000b8  63a0              STR      r0,[r4,#0x38]         ;1269
0000ba  f8847034          STRB     r7,[r4,#0x34]         ;1270
                  |L26.190|
0000be  b007              ADD      sp,sp,#0x1c
0000c0  2001              MOVS     r0,#1                 ;1271
0000c2  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.198|
0000c6  4810              LDR      r0,|L26.264|
0000c8  6007              STR      r7,[r0,#0]            ;1275
0000ca  6820              LDR      r0,[r4,#0]            ;1278
0000cc  ea4f2648          LSL      r6,r8,#9              ;1278
0000d0  f1000280          ADD      r2,r0,#0x80           ;1278
0000d4  08b3              LSRS     r3,r6,#2              ;1278
0000d6  4659              MOV      r1,r11                ;1278
0000d8  6c20              LDR      r0,[r4,#0x40]         ;1278
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  f04f30ff          MOV      r0,#0xffffffff        ;1281
0000e2  e9cd0600          STRD     r0,r6,[sp,#0]         ;1281
0000e6  e9cda502          STRD     r10,r5,[sp,#8]        ;1281
0000ea  e9cd5704          STRD     r5,r7,[sp,#0x10]      ;1281
0000ee  4669              MOV      r1,sp                 ;1287
0000f0  6820              LDR      r0,[r4,#0]            ;1287
0000f2  f7fffffe          BL       SDIO_ConfigData
0000f6  b007              ADD      sp,sp,#0x1c
0000f8  2000              MOVS     r0,#0                 ;1289
0000fa  e8bd8ff0          POP      {r4-r11,pc}
;;;1296   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L26.256|
                          DCD      SD_DMATransmitCplt
                  |L26.260|
                          DCD      SD_DMAError
                  |L26.264|
                          DCD      0x4225858c

                          AREA ||i.HAL_SD_WriteBlocks_IT||, CODE, READONLY, ALIGN=1

                  HAL_SD_WriteBlocks_IT PROC
;;;968      */
;;;969    HAL_StatusTypeDef HAL_SD_WriteBlocks_IT(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;970    {
000004  b086              SUB      sp,sp,#0x18
000006  461f              MOV      r7,r3
000008  4616              MOV      r6,r2
00000a  4604              MOV      r4,r0
00000c  b191              CBZ      r1,|L27.52|
;;;971      SDIO_DataInitTypeDef config;
;;;972      uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;973      
;;;974      if(NULL == pData)
;;;975      {
;;;976        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
;;;977        return HAL_ERROR;
;;;978      }
;;;979      
;;;980      if(hsd->State == HAL_SD_STATE_READY)
00000e  f8940034          LDRB     r0,[r4,#0x34]
000012  2801              CMP      r0,#1
;;;981      {
;;;982        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;983        
;;;984        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;985        {
;;;986          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;987          return HAL_ERROR;
;;;988        }
;;;989        
;;;990        hsd->State = HAL_SD_STATE_BUSY;
;;;991        
;;;992        /* Initialize data control register */
;;;993        hsd->Instance->DCTRL = 0U;
;;;994        
;;;995        hsd->pTxBuffPtr = (uint32_t *)pData;
;;;996        hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
;;;997        
;;;998        /* Enable transfer interrupts */
;;;999    #ifdef SDIO_STA_STBITER
;;;1000       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_DATAEND | SDIO_FLAG_TXFIFOHE | SDIO_IT_STBITERR));    
;;;1001   #else /* SDIO_STA_STBITERR not defined */
;;;1002       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_DATAEND | SDIO_FLAG_TXFIFOHE));    
;;;1003   #endif /* SDIO_STA_STBITERR */
;;;1004       
;;;1005       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1006       {
;;;1007         BlockAdd *= 512U;
;;;1008       }
;;;1009       
;;;1010       /* Set Block Size for Card */ 
;;;1011       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1012       if(errorstate != HAL_SD_ERROR_NONE)
;;;1013       {
;;;1014         /* Clear all the static flags */
;;;1015         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1016         hsd->ErrorCode |= errorstate;
;;;1017         hsd->State = HAL_SD_STATE_READY;
;;;1018         return HAL_ERROR;
;;;1019       }
;;;1020       
;;;1021       /* Write Blocks in Polling mode */
;;;1022       if(NumberOfBlocks > 1U)
;;;1023       {
;;;1024         hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK| SD_CONTEXT_IT);
;;;1025         
;;;1026         /* Write Multi Block command */ 
;;;1027         errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;1028       }
;;;1029       else
;;;1030       {
;;;1031         hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_IT);
;;;1032         
;;;1033         /* Write Single Block command */ 
;;;1034         errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;1035       }
;;;1036       if(errorstate != HAL_SD_ERROR_NONE)
;;;1037       {
;;;1038         /* Clear all the static flags */
;;;1039         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1040         hsd->ErrorCode |= errorstate;
;;;1041         hsd->State = HAL_SD_STATE_READY;
;;;1042         return HAL_ERROR;
;;;1043       }
;;;1044       
;;;1045       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1046       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1047       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1048       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1049       config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;1050       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1051       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1052       SDIO_ConfigData(hsd->Instance, &config);
;;;1053       
;;;1054       return HAL_OK;
;;;1055     }
;;;1056     else
;;;1057     {
;;;1058       return HAL_BUSY;
000014  bf1e              ITTT     NE
000016  2002              MOVNE    r0,#2
;;;1059     }
;;;1060   }
000018  b006              ADDNE    sp,sp,#0x18
00001a  e8bd87f0          POPNE    {r4-r10,pc}
00001e  2500              MOVS     r5,#0                 ;982
000020  63a5              STR      r5,[r4,#0x38]         ;982
000022  6de2              LDR      r2,[r4,#0x5c]         ;984
000024  19f0              ADDS     r0,r6,r7              ;984
000026  4290              CMP      r0,r2                 ;984
000028  d90c              BLS      |L27.68|
00002a  6ba0              LDR      r0,[r4,#0x38]         ;986
00002c  f0407000          ORR      r0,r0,#0x2000000      ;986
000030  63a0              STR      r0,[r4,#0x38]         ;986
000032  e03c              B        |L27.174|
                  |L27.52|
000034  6ba0              LDR      r0,[r4,#0x38]         ;976
000036  f0406000          ORR      r0,r0,#0x8000000      ;976
00003a  63a0              STR      r0,[r4,#0x38]         ;976
00003c  b006              ADD      sp,sp,#0x18
00003e  2001              MOVS     r0,#1                 ;977
000040  e8bd87f0          POP      {r4-r10,pc}
                  |L27.68|
000044  2003              MOVS     r0,#3                 ;990
000046  f8840034          STRB     r0,[r4,#0x34]         ;990
00004a  6820              LDR      r0,[r4,#0]            ;993
00004c  62c5              STR      r5,[r0,#0x2c]         ;993
00004e  ea4f2947          LSL      r9,r7,#9              ;996
000052  e9c41908          STRD     r1,r9,[r4,#0x20]      ;996
000056  6820              LDR      r0,[r4,#0]            ;1002
000058  6bc1              LDR      r1,[r0,#0x3c]         ;1002
00005a  f244121a          MOV      r2,#0x411a            ;1002
00005e  4311              ORRS     r1,r1,r2              ;1002
000060  63c1              STR      r1,[r0,#0x3c]         ;1002
000062  6c60              LDR      r0,[r4,#0x44]         ;1005
000064  2801              CMP      r0,#1                 ;1005
000066  bf18              IT       NE                    ;1007
000068  0276              LSLNE    r6,r6,#9              ;1007
00006a  f44f7100          MOV      r1,#0x200             ;1011
00006e  6820              LDR      r0,[r4,#0]            ;1011
000070  f7fffffe          BL       SDMMC_CmdBlockLength
000074  f04f0801          MOV      r8,#1                 ;977
000078  f2405aff          MOV      r10,#0x5ff            ;1015
00007c  b978              CBNZ     r0,|L27.158|
00007e  2f01              CMP      r7,#1                 ;1022
000080  d906              BLS      |L27.144|
000082  2028              MOVS     r0,#0x28              ;1024
000084  6320              STR      r0,[r4,#0x30]         ;1024
000086  4631              MOV      r1,r6                 ;1027
000088  6820              LDR      r0,[r4,#0]            ;1027
00008a  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
00008e  e005              B        |L27.156|
                  |L27.144|
000090  2018              MOVS     r0,#0x18              ;1031
000092  6320              STR      r0,[r4,#0x30]         ;1031
000094  4631              MOV      r1,r6                 ;1034
000096  6820              LDR      r0,[r4,#0]            ;1034
000098  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
                  |L27.156|
00009c  b158              CBZ      r0,|L27.182|
                  |L27.158|
00009e  6821              LDR      r1,[r4,#0]            ;1039
0000a0  f8c1a038          STR      r10,[r1,#0x38]        ;1039
0000a4  6ba1              LDR      r1,[r4,#0x38]         ;1040
0000a6  4308              ORRS     r0,r0,r1              ;1040
0000a8  63a0              STR      r0,[r4,#0x38]         ;1040
0000aa  f8848034          STRB     r8,[r4,#0x34]         ;1041
                  |L27.174|
0000ae  b006              ADD      sp,sp,#0x18
0000b0  2001              MOVS     r0,#1                 ;1042
0000b2  e8bd87f0          POP      {r4-r10,pc}
                  |L27.182|
0000b6  f04f30ff          MOV      r0,#0xffffffff        ;1046
0000ba  e9cd0900          STRD     r0,r9,[sp,#0]         ;1046
0000be  2090              MOVS     r0,#0x90              ;1048
0000c0  e9cd0502          STRD     r0,r5,[sp,#8]         ;1048
0000c4  e9cd5804          STRD     r5,r8,[sp,#0x10]      ;1048
0000c8  4669              MOV      r1,sp                 ;1052
0000ca  6820              LDR      r0,[r4,#0]            ;1052
0000cc  f7fffffe          BL       SDIO_ConfigData
0000d0  b006              ADD      sp,sp,#0x18
0000d2  2000              MOVS     r0,#0                 ;1054
0000d4  e8bd87f0          POP      {r4-r10,pc}
;;;1061   
                          ENDP


                          AREA ||i.SD_DMAError||, CODE, READONLY, ALIGN=1

                  SD_DMAError PROC
;;;2336     */
;;;2337   static void SD_DMAError(DMA_HandleTypeDef *hdma)   
000000  b510              PUSH     {r4,lr}
;;;2338   {
;;;2339     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
;;;2340     HAL_SD_CardStateTypeDef CardState;
;;;2341     
;;;2342     if((hsd->hdmarx->ErrorCode == HAL_DMA_ERROR_TE) || (hsd->hdmatx->ErrorCode == HAL_DMA_ERROR_TE))
000002  6b84              LDR      r4,[r0,#0x38]
000004  6be0              LDR      r0,[r4,#0x3c]
000006  6d40              LDR      r0,[r0,#0x54]
000008  2801              CMP      r0,#1
00000a  d003              BEQ      |L28.20|
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  6d40              LDR      r0,[r0,#0x54]
000010  2801              CMP      r0,#1
000012  d11c              BNE      |L28.78|
                  |L28.20|
;;;2343     {
;;;2344       /* Clear All flags */
;;;2345       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000014  6821              LDR      r1,[r4,#0]
000016  f24050ff          MOV      r0,#0x5ff
00001a  6388              STR      r0,[r1,#0x38]
;;;2346       
;;;2347       /* Disable All interrupts */
;;;2348       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
00001c  6820              LDR      r0,[r4,#0]
00001e  6bc1              LDR      r1,[r0,#0x3c]
000020  f421719d          BIC      r1,r1,#0x13a
000024  63c1              STR      r1,[r0,#0x3c]
;;;2349         SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2350       
;;;2351       hsd->ErrorCode |= HAL_SD_ERROR_DMA;
000026  6ba0              LDR      r0,[r4,#0x38]
000028  f0404080          ORR      r0,r0,#0x40000000
00002c  63a0              STR      r0,[r4,#0x38]
;;;2352       CardState = HAL_SD_GetCardState(hsd);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_SD_GetCardState
;;;2353       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
000034  2806              CMP      r0,#6
000036  bf18              IT       NE
000038  2805              CMPNE    r0,#5
00003a  d105              BNE      |L28.72|
;;;2354       {
;;;2355         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       SDMMC_CmdStopTransfer
000042  6ba1              LDR      r1,[r4,#0x38]
000044  4308              ORRS     r0,r0,r1
000046  63a0              STR      r0,[r4,#0x38]
                  |L28.72|
;;;2356       }
;;;2357       
;;;2358       hsd->State= HAL_SD_STATE_READY;
000048  2001              MOVS     r0,#1
00004a  f8840034          STRB     r0,[r4,#0x34]
                  |L28.78|
;;;2359     }
;;;2360   
;;;2361     HAL_SD_ErrorCallback(hsd);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_SD_ErrorCallback
;;;2362   }
000054  bd10              POP      {r4,pc}
;;;2363   
                          ENDP


                          AREA ||i.SD_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SD_DMAReceiveCplt PROC
;;;2303     */
;;;2304   static void SD_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
000000  b510              PUSH     {r4,lr}
;;;2305   {
;;;2306     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
;;;2307     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;2308     
;;;2309     /* Send stop command in multiblock write */
;;;2310     if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
000002  6b84              LDR      r4,[r0,#0x38]
000004  6b20              LDR      r0,[r4,#0x30]
000006  2882              CMP      r0,#0x82
000008  d109              BNE      |L29.30|
;;;2311     {
;;;2312       errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       SDMMC_CmdStopTransfer
;;;2313       if(errorstate != HAL_SD_ERROR_NONE)
000010  b128              CBZ      r0,|L29.30|
;;;2314       {
;;;2315         hsd->ErrorCode |= errorstate;
000012  6ba1              LDR      r1,[r4,#0x38]
000014  4308              ORRS     r0,r0,r1
000016  63a0              STR      r0,[r4,#0x38]
;;;2316         HAL_SD_ErrorCallback(hsd);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L29.30|
;;;2317       }
;;;2318     }
;;;2319     
;;;2320     /* Disable the DMA transfer for transmit request by setting the DMAEN bit
;;;2321     in the SD DCTRL register */
;;;2322     hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
00001e  6820              LDR      r0,[r4,#0]
000020  6ac1              LDR      r1,[r0,#0x2c]
000022  f0210108          BIC      r1,r1,#8
000026  62c1              STR      r1,[r0,#0x2c]
;;;2323     
;;;2324     /* Clear all the static flags */
;;;2325     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000028  6821              LDR      r1,[r4,#0]
00002a  f24050ff          MOV      r0,#0x5ff
00002e  6388              STR      r0,[r1,#0x38]
;;;2326     
;;;2327     hsd->State = HAL_SD_STATE_READY;
000030  2001              MOVS     r0,#1
000032  f8840034          STRB     r0,[r4,#0x34]
;;;2328   
;;;2329     HAL_SD_RxCpltCallback(hsd);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_SD_RxCpltCallback
;;;2330   }
00003c  bd10              POP      {r4,pc}
;;;2331   
                          ENDP


                          AREA ||i.SD_DMARxAbort||, CODE, READONLY, ALIGN=1

                  SD_DMARxAbort PROC
;;;2405     */
;;;2406   static void SD_DMARxAbort(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2407   {
;;;2408     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
;;;2409     HAL_SD_CardStateTypeDef CardState;
;;;2410     
;;;2411     if(hsd->hdmarx != NULL)
000002  6b84              LDR      r4,[r0,#0x38]
000004  2500              MOVS     r5,#0
000006  6be0              LDR      r0,[r4,#0x3c]
000008  2800              CMP      r0,#0
;;;2412     {
;;;2413       hsd->hdmarx = NULL;
00000a  bf18              IT       NE
00000c  63e5              STRNE    r5,[r4,#0x3c]
00000e  6c20              LDR      r0,[r4,#0x40]         ;2407
000010  2800              CMP      r0,#0                 ;2407
;;;2414     }
;;;2415     
;;;2416     /* All DMA channels are aborted */
;;;2417     if(hsd->hdmatx == NULL)
;;;2418     {
;;;2419       CardState = HAL_SD_GetCardState(hsd);
;;;2420       hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;2421       hsd->State = HAL_SD_STATE_READY;
;;;2422       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
;;;2423       {
;;;2424         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
;;;2425         
;;;2426         if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
;;;2427         {
;;;2428           HAL_SD_AbortCallback(hsd);
;;;2429         }
;;;2430         else
;;;2431         {
;;;2432           HAL_SD_ErrorCallback(hsd);
;;;2433         }
;;;2434       }
;;;2435     }
;;;2436   }
000012  bf18              IT       NE
000014  bd70              POPNE    {r4-r6,pc}
000016  4620              MOV      r0,r4                 ;2419
000018  f7fffffe          BL       HAL_SD_GetCardState
00001c  63a5              STR      r5,[r4,#0x38]         ;2420
00001e  2101              MOVS     r1,#1                 ;2421
000020  f8841034          STRB     r1,[r4,#0x34]         ;2421
000024  2806              CMP      r0,#6                 ;2422
000026  bf1c              ITT      NE                    ;2422
000028  2805              CMPNE    r0,#5                 ;2422
00002a  bd70              POPNE    {r4-r6,pc}
00002c  6820              LDR      r0,[r4,#0]            ;2424
00002e  f7fffffe          BL       SDMMC_CmdStopTransfer
000032  6ba1              LDR      r1,[r4,#0x38]         ;2424
000034  4308              ORRS     r0,r0,r1              ;2424
000036  63a0              STR      r0,[r4,#0x38]         ;2424
000038  6ba0              LDR      r0,[r4,#0x38]         ;2426
00003a  2800              CMP      r0,#0                 ;2426
00003c  4620              MOV      r0,r4                 ;2432
00003e  d002              BEQ      |L30.70|
000040  f7fffffe          BL       HAL_SD_AbortCallback
000044  bd70              POP      {r4-r6,pc}
                  |L30.70|
000046  f7fffffe          BL       HAL_SD_ErrorCallback
00004a  bd70              POP      {r4-r6,pc}
;;;2437   
                          ENDP


                          AREA ||i.SD_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SD_DMATransmitCplt PROC
;;;2290     */
;;;2291   static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
000000  6b80              LDR      r0,[r0,#0x38]
;;;2292   {
;;;2293     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
;;;2294     
;;;2295     /* Enable DATAEND Interrupt */
;;;2296     __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DATAEND));
000002  6800              LDR      r0,[r0,#0]
000004  6bc1              LDR      r1,[r0,#0x3c]
000006  f4417180          ORR      r1,r1,#0x100
00000a  63c1              STR      r1,[r0,#0x3c]
;;;2297   }
00000c  4770              BX       lr
;;;2298   
                          ENDP


                          AREA ||i.SD_DMATxAbort||, CODE, READONLY, ALIGN=1

                  SD_DMATxAbort PROC
;;;2368     */
;;;2369   static void SD_DMATxAbort(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2370   {
;;;2371     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
;;;2372     HAL_SD_CardStateTypeDef CardState;
;;;2373     
;;;2374     if(hsd->hdmatx != NULL)
000002  6b84              LDR      r4,[r0,#0x38]
000004  2500              MOVS     r5,#0
000006  6c20              LDR      r0,[r4,#0x40]
000008  2800              CMP      r0,#0
;;;2375     {
;;;2376       hsd->hdmatx = NULL;
00000a  bf18              IT       NE
00000c  6425              STRNE    r5,[r4,#0x40]
00000e  6be0              LDR      r0,[r4,#0x3c]         ;2370
000010  2800              CMP      r0,#0                 ;2370
;;;2377     }
;;;2378     
;;;2379     /* All DMA channels are aborted */
;;;2380     if(hsd->hdmarx == NULL)
;;;2381     {
;;;2382       CardState = HAL_SD_GetCardState(hsd);
;;;2383       hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;2384       hsd->State = HAL_SD_STATE_READY;
;;;2385       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
;;;2386       {
;;;2387         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
;;;2388         
;;;2389         if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
;;;2390         {
;;;2391           HAL_SD_AbortCallback(hsd);
;;;2392         }
;;;2393         else
;;;2394         {
;;;2395           HAL_SD_ErrorCallback(hsd);
;;;2396         }
;;;2397       }
;;;2398     }
;;;2399   }
000012  bf18              IT       NE
000014  bd70              POPNE    {r4-r6,pc}
000016  4620              MOV      r0,r4                 ;2382
000018  f7fffffe          BL       HAL_SD_GetCardState
00001c  63a5              STR      r5,[r4,#0x38]         ;2383
00001e  2101              MOVS     r1,#1                 ;2384
000020  f8841034          STRB     r1,[r4,#0x34]         ;2384
000024  2806              CMP      r0,#6                 ;2385
000026  bf1c              ITT      NE                    ;2385
000028  2805              CMPNE    r0,#5                 ;2385
00002a  bd70              POPNE    {r4-r6,pc}
00002c  6820              LDR      r0,[r4,#0]            ;2387
00002e  f7fffffe          BL       SDMMC_CmdStopTransfer
000032  6ba1              LDR      r1,[r4,#0x38]         ;2387
000034  4308              ORRS     r0,r0,r1              ;2387
000036  63a0              STR      r0,[r4,#0x38]         ;2387
000038  6ba0              LDR      r0,[r4,#0x38]         ;2389
00003a  2800              CMP      r0,#0                 ;2389
00003c  4620              MOV      r0,r4                 ;2395
00003e  d002              BEQ      |L32.70|
000040  f7fffffe          BL       HAL_SD_AbortCallback
000044  bd70              POP      {r4-r6,pc}
                  |L32.70|
000046  f7fffffe          BL       HAL_SD_ErrorCallback
00004a  bd70              POP      {r4-r6,pc}
;;;2400   
                          ENDP


                          AREA ||i.SD_FindSCR||, CODE, READONLY, ALIGN=1

                  SD_FindSCR PROC
;;;2873     */
;;;2874   static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2875   {
000004  b089              SUB      sp,sp,#0x24
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;2876     SDIO_DataInitTypeDef config;
;;;2877     uint32_t errorstate = HAL_SD_ERROR_NONE;
;;;2878     uint32_t tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
;;;2879     uint32_t index = 0U;
00000e  2500              MOVS     r5,#0
000010  4607              MOV      r7,r0                 ;2878
;;;2880     uint32_t tempscr[2U] = {0U, 0U};
000012  9500              STR      r5,[sp,#0]
;;;2881     
;;;2882     /* Set Block Size To 8 Bytes */
;;;2883     errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
000014  9501              STR      r5,[sp,#4]
000016  46a8              MOV      r8,r5                 ;2880
000018  2108              MOVS     r1,#8
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       SDMMC_CmdBlockLength
;;;2884     if(errorstate != HAL_OK)
000020  2800              CMP      r0,#0
;;;2885     {
;;;2886       return errorstate;
;;;2887     }
;;;2888   
;;;2889     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;2890     errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
;;;2891     if(errorstate != HAL_OK)
;;;2892     {
;;;2893       return errorstate;
;;;2894     }
;;;2895   
;;;2896     config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;2897     config.DataLength    = 8U;
;;;2898     config.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
;;;2899     config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;2900     config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;2901     config.DPSM          = SDIO_DPSM_ENABLE;
;;;2902     SDIO_ConfigData(hsd->Instance, &config);
;;;2903     
;;;2904     /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
;;;2905     errorstate = SDMMC_CmdSendSCR(hsd->Instance);
;;;2906     if(errorstate != HAL_OK)
;;;2907     {
;;;2908       return errorstate;
;;;2909     }
;;;2910     
;;;2911     while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
;;;2912     {
;;;2913       if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
;;;2914       {
;;;2915         *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
;;;2916         index++;
;;;2917       }
;;;2918       
;;;2919       if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
;;;2920       {
;;;2921         return HAL_SD_ERROR_TIMEOUT;
;;;2922       }
;;;2923     }
;;;2924     
;;;2925     if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;2926     {
;;;2927       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;2928       
;;;2929       return HAL_SD_ERROR_DATA_TIMEOUT;
;;;2930     }
;;;2931     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;2932     {
;;;2933       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;2934       
;;;2935       return HAL_SD_ERROR_DATA_CRC_FAIL;
;;;2936     }
;;;2937     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;2938     {
;;;2939       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;2940       
;;;2941       return HAL_SD_ERROR_RX_OVERRUN;
;;;2942     }
;;;2943     else
;;;2944     {
;;;2945       /* No error flag set */
;;;2946       /* Clear all the static flags */
;;;2947       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2948       
;;;2949       *(pSCR + 1U) = ((tempscr[0U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0U] & SDMMC_8TO15BITS) << 8U) |\
;;;2950         ((tempscr[0U] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0U] & SDMMC_24TO31BITS) >> 24U);
;;;2951       
;;;2952       *(pSCR) = ((tempscr[1U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1U] & SDMMC_8TO15BITS) << 8U) |\
;;;2953         ((tempscr[1U] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1U] & SDMMC_24TO31BITS) >> 24U);
;;;2954     }
;;;2955   
;;;2956     return HAL_SD_ERROR_NONE;
;;;2957   }
000022  bf1c              ITT      NE
000024  b009              ADDNE    sp,sp,#0x24
000026  e8bd8ff0          POPNE    {r4-r11,pc}
00002a  f8b40050          LDRH     r0,[r4,#0x50]         ;2890
00002e  0401              LSLS     r1,r0,#16             ;2890
000030  6820              LDR      r0,[r4,#0]            ;2890
000032  f7fffffe          BL       SDMMC_CmdAppCommand
000036  2800              CMP      r0,#0                 ;2891
000038  bf1c              ITT      NE
00003a  b009              ADDNE    sp,sp,#0x24
00003c  e8bd8ff0          POPNE    {r4-r11,pc}
000040  f04f30ff          MOV      r0,#0xffffffff        ;2896
000044  f04f0908          MOV      r9,#8                 ;2897
000048  e9cd0902          STRD     r0,r9,[sp,#8]         ;2897
00004c  2030              MOVS     r0,#0x30              ;2898
00004e  f04f0a02          MOV      r10,#2                ;2899
000052  e9cd0a04          STRD     r0,r10,[sp,#0x10]     ;2899
000056  2001              MOVS     r0,#1                 ;2901
000058  e9cd8006          STRD     r8,r0,[sp,#0x18]      ;2901
00005c  a902              ADD      r1,sp,#8              ;2902
00005e  6820              LDR      r0,[r4,#0]            ;2902
000060  f7fffffe          BL       SDIO_ConfigData
000064  6820              LDR      r0,[r4,#0]            ;2905
000066  f7fffffe          BL       SDMMC_CmdSendSCR
00006a  2800              CMP      r0,#0                 ;2906
00006c  bf1c              ITT      NE
00006e  b009              ADDNE    sp,sp,#0x24
000070  e8bd8ff0          POPNE    {r4-r11,pc}
000074  6820              LDR      r0,[r4,#0]            ;2911
000076  6b40              LDR      r0,[r0,#0x34]         ;2911
000078  f240482a          MOV      r8,#0x42a             ;2911
00007c  ea100f08          TST      r0,r8                 ;2911
000080  bf08              IT       EQ                    ;2880
000082  46eb              MOVEQ    r11,sp                ;2880
000084  d114              BNE      |L33.176|
                  |L33.134|
000086  6820              LDR      r0,[r4,#0]            ;2913
000088  6b41              LDR      r1,[r0,#0x34]         ;2913
00008a  f4111f00          TST      r1,#0x200000          ;2913
00008e  d004              BEQ      |L33.154|
000090  f7fffffe          BL       SDIO_ReadFIFO
000094  f84b0025          STR      r0,[r11,r5,LSL #2]    ;2915
000098  1c6d              ADDS     r5,r5,#1              ;2915
                  |L33.154|
00009a  f7fffffe          BL       HAL_GetTick
00009e  1bc0              SUBS     r0,r0,r7              ;2919
0000a0  f1b03fff          CMP      r0,#0xffffffff        ;2919
0000a4  d023              BEQ      |L33.238|
0000a6  6820              LDR      r0,[r4,#0]            ;2911
0000a8  6b40              LDR      r0,[r0,#0x34]         ;2911
0000aa  ea100f08          TST      r0,r8                 ;2911
0000ae  d0ea              BEQ      |L33.134|
                  |L33.176|
0000b0  6820              LDR      r0,[r4,#0]            ;2925
0000b2  6b41              LDR      r1,[r0,#0x34]         ;2925
0000b4  f0110f08          TST      r1,#8                 ;2925
0000b8  bf1f              ITTTT    NE                    ;2927
0000ba  f8c09038          STRNE    r9,[r0,#0x38]         ;2927
0000be  2008              MOVNE    r0,#8                 ;2929
0000c0  b009              ADDNE    sp,sp,#0x24
0000c2  e8bd8ff0          POPNE    {r4-r11,pc}
0000c6  6b41              LDR      r1,[r0,#0x34]         ;2931
0000c8  f0110f02          TST      r1,#2                 ;2931
0000cc  bf1f              ITTTT    NE                    ;2933
0000ce  f8c0a038          STRNE    r10,[r0,#0x38]        ;2933
0000d2  2002              MOVNE    r0,#2                 ;2935
0000d4  b009              ADDNE    sp,sp,#0x24
0000d6  e8bd8ff0          POPNE    {r4-r11,pc}
0000da  6b41              LDR      r1,[r0,#0x34]         ;2937
0000dc  f0110f20          TST      r1,#0x20              ;2937
0000e0  d00a              BEQ      |L33.248|
0000e2  2120              MOVS     r1,#0x20              ;2939
0000e4  6381              STR      r1,[r0,#0x38]         ;2939
0000e6  b009              ADD      sp,sp,#0x24
0000e8  4608              MOV      r0,r1                 ;2941
0000ea  e8bd8ff0          POP      {r4-r11,pc}
                  |L33.238|
0000ee  b009              ADD      sp,sp,#0x24
0000f0  f04f4000          MOV      r0,#0x80000000        ;2921
0000f4  e8bd8ff0          POP      {r4-r11,pc}
                  |L33.248|
0000f8  f24051ff          MOV      r1,#0x5ff             ;2947
0000fc  6381              STR      r1,[r0,#0x38]         ;2947
0000fe  9800              LDR      r0,[sp,#0]            ;2949
000100  ba00              REV      r0,r0                 ;2949
000102  6070              STR      r0,[r6,#4]            ;2952
000104  9801              LDR      r0,[sp,#4]            ;2952
000106  ba00              REV      r0,r0                 ;2952
000108  6030              STR      r0,[r6,#0]            ;2956
00010a  b009              ADD      sp,sp,#0x24
00010c  2000              MOVS     r0,#0                 ;2956
00010e  e8bd8ff0          POP      {r4-r11,pc}
;;;2958   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH|
#line 402
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX|
#line 587
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
