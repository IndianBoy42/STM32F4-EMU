; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_rcc.o --depend=stm32nes\stm32f4xx_ll_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_rcc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_rcc.c]
                          THUMB

                          AREA ||i.LL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  LL_RCC_DeInit PROC
;;;201      */
;;;202    ErrorStatus LL_RCC_DeInit(void)
000000  481c              LDR      r0,|L1.116|
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
                  |L1.10|
00000a  6801              LDR      r1,[r0,#0]
00000c  f0110f02          TST      r1,#2
000010  d0fb              BEQ      |L1.10|
;;;203    {
;;;204      uint32_t vl_mask = 0U;
;;;205    
;;;206      /* Set HSION bit */
;;;207      LL_RCC_HSI_Enable();
;;;208    
;;;209      /* Wait for HSI READY bit */
;;;210      while(LL_RCC_HSI_IsReady() != 1U)
;;;211      {}
;;;212    
;;;213      /* Reset CFGR register */
;;;214      LL_RCC_WriteReg(CFGR, 0x00000000U);
000012  4a19              LDR      r2,|L1.120|
000014  2100              MOVS     r1,#0
000016  6011              STR      r1,[r2,#0]
;;;215    
;;;216      vl_mask = 0xFFFFFFFFU;
;;;217    
;;;218      /* Reset HSEON, PLLSYSON bits */
;;;219      CLEAR_BIT(vl_mask, (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_PLLON | RCC_CR_CSSON));
;;;220    
;;;221    #if defined(RCC_PLLSAI_SUPPORT)
;;;222      /* Reset PLLSAION bit */
;;;223      CLEAR_BIT(vl_mask, RCC_CR_PLLSAION);
;;;224    #endif /* RCC_PLLSAI_SUPPORT */
;;;225    
;;;226    #if defined(RCC_PLLI2S_SUPPORT)
;;;227      /* Reset PLLI2SON bit */
;;;228      CLEAR_BIT(vl_mask, RCC_CR_PLLI2SON);
;;;229    #endif /* RCC_PLLI2S_SUPPORT */
;;;230    
;;;231      /* Write new mask in CR register */
;;;232      LL_RCC_WriteReg(CR, vl_mask);
;;;233    
;;;234      /* Set HSITRIM bits to the reset value*/
;;;235      LL_RCC_HSI_SetCalibTrimming(0x10U);
;;;236    
;;;237      /* Wait for PLL READY bit to be reset */
;;;238      while(LL_RCC_PLL_IsReady() != 0U)
;;;239      {}
;;;240    
;;;241      /* Reset PLLCFGR register */
;;;242      LL_RCC_WriteReg(PLLCFGR, RCC_PLLCFGR_RST_VALUE);
;;;243    
;;;244    #if defined(RCC_PLLI2S_SUPPORT)
;;;245      /* Reset PLLI2SCFGR register */
;;;246      LL_RCC_WriteReg(PLLI2SCFGR, RCC_PLLI2SCFGR_RST_VALUE);
;;;247    #endif /* RCC_PLLI2S_SUPPORT */
;;;248    
;;;249    #if defined(RCC_PLLSAI_SUPPORT)
;;;250      /* Reset PLLSAICFGR register */
;;;251      LL_RCC_WriteReg(PLLSAICFGR, RCC_PLLSAICFGR_RST_VALUE);
;;;252    #endif /* RCC_PLLSAI_SUPPORT */
;;;253    
;;;254      /* Disable all interrupts */
;;;255      CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);
;;;256    
;;;257    #if defined(RCC_CIR_PLLI2SRDYIE)
;;;258      CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);
;;;259    #endif /* RCC_CIR_PLLI2SRDYIE */
;;;260    
;;;261    #if defined(RCC_CIR_PLLSAIRDYIE)
;;;262      CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);
;;;263    #endif /* RCC_CIR_PLLSAIRDYIE */
;;;264    
;;;265      /* Clear all interrupt flags */
;;;266      SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);
;;;267    
;;;268    #if defined(RCC_CIR_PLLI2SRDYC)
;;;269      SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);
;;;270    #endif /* RCC_CIR_PLLI2SRDYC */
;;;271    
;;;272    #if defined(RCC_CIR_PLLSAIRDYC)
;;;273      SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);
;;;274    #endif /* RCC_CIR_PLLSAIRDYC */
;;;275    
;;;276      /* Clear LSION bit */
;;;277      CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
;;;278    
;;;279      /* Reset all CSR flags */
;;;280      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;281    
;;;282      return SUCCESS;
;;;283    }
000018  4918              LDR      r1,|L1.124|
00001a  6001              STR      r1,[r0,#0]            ;232
00001c  6801              LDR      r1,[r0,#0]            ;232
00001e  f02101f8          BIC      r1,r1,#0xf8           ;232
000022  f0410180          ORR      r1,r1,#0x80           ;232
000026  6001              STR      r1,[r0,#0]            ;232
                  |L1.40|
000028  6801              LDR      r1,[r0,#0]            ;232
00002a  f0117f00          TST      r1,#0x2000000         ;232
00002e  d1fb              BNE      |L1.40|
000030  4914              LDR      r1,|L1.132|
000032  4813              LDR      r0,|L1.128|
000034  6008              STR      r0,[r1,#0]            ;242
000036  4915              LDR      r1,|L1.140|
000038  4813              LDR      r0,|L1.136|
00003a  6008              STR      r0,[r1,#0]            ;246
00003c  4814              LDR      r0,|L1.144|
00003e  6801              LDR      r1,[r0,#0]            ;255
000040  f42151f8          BIC      r1,r1,#0x1f00         ;255
000044  6001              STR      r1,[r0,#0]            ;255
000046  6801              LDR      r1,[r0,#0]            ;258
000048  f4215100          BIC      r1,r1,#0x2000         ;258
00004c  6001              STR      r1,[r0,#0]            ;258
00004e  6801              LDR      r1,[r0,#0]            ;266
000050  f441011f          ORR      r1,r1,#0x9f0000       ;266
000054  6001              STR      r1,[r0,#0]            ;266
000056  6801              LDR      r1,[r0,#0]            ;269
000058  f4411100          ORR      r1,r1,#0x200000       ;269
00005c  6001              STR      r1,[r0,#0]            ;269
00005e  480d              LDR      r0,|L1.148|
000060  6801              LDR      r1,[r0,#0]            ;277
000062  f0210101          BIC      r1,r1,#1              ;277
000066  6001              STR      r1,[r0,#0]            ;277
000068  6801              LDR      r1,[r0,#0]            ;280
00006a  f0417180          ORR      r1,r1,#0x1000000      ;280
00006e  6001              STR      r1,[r0,#0]            ;280
000070  2001              MOVS     r0,#1                 ;282
000072  4770              BX       lr
;;;284    
                          ENDP

                  |L1.116|
                          DCD      0x40023800
                  |L1.120|
                          DCD      0x40023808
                  |L1.124|
                          DCD      0xfaf2ffff
                  |L1.128|
                          DCD      0x24003010
                  |L1.132|
                          DCD      0x40023804
                  |L1.136|
                          DCD      0x20003000
                  |L1.140|
                          DCD      0x40023884
                  |L1.144|
                          DCD      0x4002380c
                  |L1.148|
                          DCD      0x40023874

                          AREA ||i.LL_RCC_GetI2SClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetI2SClockFreq PROC
;;;384      */
;;;385    uint32_t LL_RCC_GetI2SClockFreq(uint32_t I2SxSource)
000000  4601              MOV      r1,r0
;;;386    {
;;;387      uint32_t i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000002  2000              MOVS     r0,#0
;;;388    
;;;389      /* Check parameter */
;;;390      assert_param(IS_LL_RCC_I2S_CLKSOURCE(I2SxSource));
;;;391    
;;;392      if (I2SxSource == LL_RCC_I2S1_CLKSOURCE)
000004  f5b10f00          CMP      r1,#0x800000
;;;393      {
;;;394        /* I2S1 CLK clock frequency */
;;;395        switch (LL_RCC_GetI2SClockSource(I2SxSource))
;;;396        {
;;;397    #if defined(RCC_PLLI2S_SUPPORT)
;;;398          case LL_RCC_I2S1_CLKSOURCE_PLLI2S:       /* I2S1 Clock is PLLI2S */
;;;399            if (LL_RCC_PLLI2S_IsReady())
;;;400            {
;;;401              i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();
;;;402            }
;;;403            break;
;;;404    #endif /* RCC_PLLI2S_SUPPORT */
;;;405    
;;;406    #if defined(RCC_DCKCFGR_I2SSRC) || defined(RCC_DCKCFGR_I2S1SRC)
;;;407          case LL_RCC_I2S1_CLKSOURCE_PLL:          /* I2S1 Clock is PLL */
;;;408            if (LL_RCC_PLL_IsReady())
;;;409            {
;;;410              i2s_frequency = RCC_PLL_GetFreqDomain_I2S();
;;;411            }
;;;412            break;
;;;413    
;;;414          case LL_RCC_I2S1_CLKSOURCE_PLLSRC:       /* I2S1 Clock is PLL Main source */
;;;415            switch (LL_RCC_PLL_GetMainSource())
;;;416            {
;;;417               case LL_RCC_PLLSOURCE_HSE:          /* I2S1 Clock is HSE Osc. */
;;;418                 if (LL_RCC_HSE_IsReady())
;;;419                 {
;;;420                   i2s_frequency = HSE_VALUE;
;;;421                 }
;;;422                 break;
;;;423    
;;;424               case LL_RCC_PLLSOURCE_HSI:          /* I2S1 Clock is HSI Osc. */
;;;425               default:
;;;426                 if (LL_RCC_HSI_IsReady())
;;;427                 {
;;;428                   i2s_frequency = HSI_VALUE;
;;;429                 }
;;;430                 break;
;;;431            }
;;;432            break;
;;;433    #endif /* RCC_DCKCFGR_I2SSRC || RCC_DCKCFGR_I2S1SRC */
;;;434    
;;;435          case LL_RCC_I2S1_CLKSOURCE_PIN:          /* I2S1 Clock is External clock */
;;;436          default:
;;;437            i2s_frequency = EXTERNAL_CLOCK_VALUE;
;;;438            break;
;;;439        }
;;;440      }
;;;441    #if defined(RCC_DCKCFGR_I2S2SRC)
;;;442      else
;;;443      {
;;;444        /* I2S2 CLK clock frequency */
;;;445        switch (LL_RCC_GetI2SClockSource(I2SxSource))
;;;446        {
;;;447          case LL_RCC_I2S2_CLKSOURCE_PLLI2S:       /* I2S2 Clock is PLLI2S */
;;;448            if (LL_RCC_PLLI2S_IsReady())
;;;449            {
;;;450              i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();
;;;451            }
;;;452            break;
;;;453    
;;;454          case LL_RCC_I2S2_CLKSOURCE_PLL:          /* I2S2 Clock is PLL */
;;;455            if (LL_RCC_PLL_IsReady())
;;;456            {
;;;457              i2s_frequency = RCC_PLL_GetFreqDomain_I2S();
;;;458            }
;;;459            break;
;;;460    
;;;461          case LL_RCC_I2S2_CLKSOURCE_PLLSRC:       /* I2S2 Clock is PLL Main source */
;;;462            switch (LL_RCC_PLL_GetMainSource())
;;;463            {
;;;464               case LL_RCC_PLLSOURCE_HSE:          /* I2S2 Clock is HSE Osc. */
;;;465                 if (LL_RCC_HSE_IsReady())
;;;466                 {
;;;467                   i2s_frequency = HSE_VALUE;
;;;468                 }
;;;469                 break;
;;;470    
;;;471               case LL_RCC_PLLSOURCE_HSI:          /* I2S2 Clock is HSI Osc. */
;;;472               default:
;;;473                 if (LL_RCC_HSI_IsReady())
;;;474                 {
;;;475                   i2s_frequency = HSI_VALUE;
;;;476                 }
;;;477                 break;
;;;478            }
;;;479            break;
;;;480    
;;;481          case LL_RCC_I2S2_CLKSOURCE_PIN:          /* I2S2 Clock is External clock */
;;;482          default:
;;;483            i2s_frequency = EXTERNAL_CLOCK_VALUE;
;;;484            break;
;;;485        } 
;;;486      }
;;;487    #endif /* RCC_DCKCFGR_I2S2SRC */
;;;488    
;;;489      return i2s_frequency;
;;;490    }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  4912              LDR      r1,|L2.88|
00000e  6809              LDR      r1,[r1,#0]
000010  f4110f00          TST      r1,#0x800000
000014  bf1c              ITT      NE                    ;437
000016  4811              LDRNE    r0,|L2.92|
000018  4770              BXNE     lr
00001a  4911              LDR      r1,|L2.96|
00001c  6809              LDR      r1,[r1,#0]            ;399
00001e  f0116f00          TST      r1,#0x8000000         ;399
000022  bf08              IT       EQ
000024  4770              BXEQ     lr
000026  490f              LDR      r1,|L2.100|
000028  6808              LDR      r0,[r1,#0]
00002a  f4000080          AND      r0,r0,#0x400000
00002e  f5b00f80          CMP      r0,#0x400000
000032  bf0c              ITE      EQ
000034  480c              LDREQ    r0,|L2.104|
000036  480d              LDRNE    r0,|L2.108|
000038  6809              LDR      r1,[r1,#0]
00003a  f001013f          AND      r1,r1,#0x3f
00003e  fbb0f2f1          UDIV     r2,r0,r1
000042  480b              LDR      r0,|L2.112|
000044  6801              LDR      r1,[r0,#0]
000046  6800              LDR      r0,[r0,#0]
000048  f3c11188          UBFX     r1,r1,#6,#9
00004c  4351              MULS     r1,r2,r1
00004e  f3c07002          UBFX     r0,r0,#28,#3
000052  fbb1f0f0          UDIV     r0,r1,r0
000056  4770              BX       lr
;;;491    
                          ENDP

                  |L2.88|
                          DCD      0x40023808
                  |L2.92|
                          DCD      0x00bb8000
                  |L2.96|
                          DCD      0x40023800
                  |L2.100|
                          DCD      0x40023804
                  |L2.104|
                          DCD      0x007a1200
                  |L2.108|
                          DCD      0x00f42400
                  |L2.112|
                          DCD      0x40023884

                          AREA ||i.LL_RCC_GetRNGClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetRNGClockFreq PROC
;;;767      */
;;;768    uint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)
000000  490f              LDR      r1,|L3.64|
;;;769    {
;;;770      uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000002  2000              MOVS     r0,#0
;;;771    
;;;772      /* Check parameter */
;;;773      assert_param(IS_LL_RCC_RNG_CLKSOURCE(RNGxSource));
;;;774    
;;;775    #if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)
;;;776      /* RNGCLK clock frequency */
;;;777      switch (LL_RCC_GetRNGClockSource(RNGxSource))
;;;778      {
;;;779    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;780        case LL_RCC_RNG_CLKSOURCE_PLLI2S:        /* PLLI2S clock used as RNG clock source */
;;;781          if (LL_RCC_PLLI2S_IsReady())
;;;782          {
;;;783            rng_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;784          }
;;;785          break;
;;;786    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;787    
;;;788    #if defined(RCC_PLLSAI_SUPPORT)
;;;789        case LL_RCC_RNG_CLKSOURCE_PLLSAI:        /* PLLSAI clock used as RNG clock source */
;;;790          if (LL_RCC_PLLSAI_IsReady())
;;;791          {
;;;792            rng_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;793          }
;;;794          break;
;;;795    #endif /* RCC_PLLSAI_SUPPORT */
;;;796    
;;;797        case LL_RCC_RNG_CLKSOURCE_PLL:           /* PLL clock used as RNG clock source */
;;;798        default:
;;;799          if (LL_RCC_PLL_IsReady())
;;;800          {
;;;801            rng_frequency = RCC_PLL_GetFreqDomain_48M();
;;;802          }
;;;803          break;
;;;804      }
;;;805    #else
;;;806      /* PLL clock used as RNG clock source */
;;;807      if (LL_RCC_PLL_IsReady())
000004  6809              LDR      r1,[r1,#0]
000006  f0117f00          TST      r1,#0x2000000
;;;808      {
;;;809        rng_frequency = RCC_PLL_GetFreqDomain_48M();
;;;810      }
;;;811    #endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */
;;;812    
;;;813      return rng_frequency;
;;;814    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  490d              LDR      r1,|L3.68|
000010  6808              LDR      r0,[r1,#0]
000012  f4100280          ANDS     r2,r0,#0x400000
000016  480c              LDR      r0,|L3.72|
000018  d003              BEQ      |L3.34|
00001a  f5b20f80          CMP      r2,#0x400000
00001e  bf08              IT       EQ
000020  480a              LDREQ    r0,|L3.76|
                  |L3.34|
000022  680a              LDR      r2,[r1,#0]
000024  f002023f          AND      r2,r2,#0x3f
000028  fbb0f2f2          UDIV     r2,r0,r2
00002c  6808              LDR      r0,[r1,#0]
00002e  6809              LDR      r1,[r1,#0]
000030  f3c01088          UBFX     r0,r0,#6,#9
000034  4350              MULS     r0,r2,r0
000036  f3c16103          UBFX     r1,r1,#24,#4
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  4770              BX       lr
;;;815    #endif /* RNG */
                          ENDP

                  |L3.64|
                          DCD      0x40023800
                  |L3.68|
                          DCD      0x40023804
                  |L3.72|
                          DCD      0x00f42400
                  |L3.76|
                          DCD      0x007a1200

                          AREA ||i.LL_RCC_GetSDIOClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetSDIOClockFreq PROC
;;;696      */
;;;697    uint32_t LL_RCC_GetSDIOClockFreq(uint32_t SDIOxSource)
000000  4601              MOV      r1,r0
;;;698    {
;;;699      uint32_t SDIO_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000002  2000              MOVS     r0,#0
;;;700    
;;;701      /* Check parameter */
;;;702      assert_param(IS_LL_RCC_SDIO_CLKSOURCE(SDIOxSource));
;;;703    
;;;704      if (SDIOxSource == LL_RCC_SDIO_CLKSOURCE)
000004  f1b16f70          CMP      r1,#0xf000000
;;;705      {
;;;706    #if defined(RCC_DCKCFGR_SDIOSEL) || defined(RCC_DCKCFGR2_SDIOSEL)
;;;707        /* SDIOCLK clock frequency */
;;;708        switch (LL_RCC_GetSDIOClockSource(SDIOxSource))
;;;709        {
;;;710          case LL_RCC_SDIO_CLKSOURCE_PLL48CLK:         /* PLL48M clock used as SDIO clock source */
;;;711            switch (LL_RCC_GetCK48MClockSource(LL_RCC_CK48M_CLKSOURCE))
;;;712            {
;;;713              case LL_RCC_CK48M_CLKSOURCE_PLL:         /* PLL clock used as 48Mhz domain clock */
;;;714                if (LL_RCC_PLL_IsReady())
;;;715                {
;;;716                  SDIO_frequency = RCC_PLL_GetFreqDomain_48M();
;;;717                }
;;;718              break;
;;;719    
;;;720    #if defined(RCC_PLLSAI_SUPPORT)
;;;721              case LL_RCC_CK48M_CLKSOURCE_PLLSAI:      /* PLLSAI clock used as 48Mhz domain clock */
;;;722              default:
;;;723                if (LL_RCC_PLLSAI_IsReady())
;;;724                {
;;;725                  SDIO_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;726                }
;;;727                break;
;;;728    #endif /* RCC_PLLSAI_SUPPORT */
;;;729    
;;;730    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;731              case LL_RCC_CK48M_CLKSOURCE_PLLI2S:      /* PLLI2S clock used as 48Mhz domain clock */
;;;732              default:
;;;733                if (LL_RCC_PLLI2S_IsReady())
;;;734                {
;;;735                  SDIO_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;736                }
;;;737                break;
;;;738    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;739            }
;;;740            break;
;;;741    
;;;742          case LL_RCC_SDIO_CLKSOURCE_SYSCLK:           /* PLL clock used as SDIO clock source */
;;;743          default:
;;;744          SDIO_frequency = RCC_GetSystemClockFreq();
;;;745          break;
;;;746        }
;;;747    #else
;;;748        /* PLL clock used as 48Mhz domain clock */
;;;749        if (LL_RCC_PLL_IsReady())
;;;750        {
;;;751          SDIO_frequency = RCC_PLL_GetFreqDomain_48M();
;;;752        }
;;;753    #endif /* RCC_DCKCFGR_SDIOSEL || RCC_DCKCFGR2_SDIOSEL */
;;;754      }
;;;755    
;;;756      return SDIO_frequency;
;;;757    }
000008  bf18              IT       NE
00000a  4770              BXNE     lr
00000c  490f              LDR      r1,|L4.76|
00000e  6809              LDR      r1,[r1,#0]            ;749
000010  f0117f00          TST      r1,#0x2000000         ;749
000014  bf08              IT       EQ
000016  4770              BXEQ     lr
000018  490d              LDR      r1,|L4.80|
00001a  6808              LDR      r0,[r1,#0]
00001c  f4100280          ANDS     r2,r0,#0x400000
000020  480c              LDR      r0,|L4.84|
000022  d003              BEQ      |L4.44|
000024  f5b20f80          CMP      r2,#0x400000
000028  bf08              IT       EQ
00002a  480b              LDREQ    r0,|L4.88|
                  |L4.44|
00002c  680a              LDR      r2,[r1,#0]
00002e  f002023f          AND      r2,r2,#0x3f
000032  fbb0f2f2          UDIV     r2,r0,r2
000036  6808              LDR      r0,[r1,#0]
000038  6809              LDR      r1,[r1,#0]
00003a  f3c01088          UBFX     r0,r0,#6,#9
00003e  4350              MULS     r0,r2,r0
000040  f3c16103          UBFX     r1,r1,#24,#4
000044  fbb0f0f1          UDIV     r0,r0,r1
000048  4770              BX       lr
;;;758    #endif /* SDIO */
                          ENDP

00004a  0000              DCW      0x0000
                  |L4.76|
                          DCD      0x40023800
                  |L4.80|
                          DCD      0x40023804
                  |L4.84|
                          DCD      0x00f42400
                  |L4.88|
                          DCD      0x007a1200

                          AREA ||i.LL_RCC_GetSystemClocksFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetSystemClocksFreq PROC
;;;317      */
;;;318    void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
000000  4a23              LDR      r2,|L5.144|
;;;319    {
000002  b410              PUSH     {r4}
000004  6811              LDR      r1,[r2,#0]
000006  f011030c          ANDS     r3,r1,#0xc
00000a  4922              LDR      r1,|L5.148|
00000c  d022              BEQ      |L5.84|
00000e  ea4f0c61          ASR      r12,r1,#1
000012  2b04              CMP      r3,#4
000014  bf08              IT       EQ
000016  4661              MOVEQ    r1,r12
000018  d01c              BEQ      |L5.84|
00001a  2b08              CMP      r3,#8
00001c  d11a              BNE      |L5.84|
00001e  4b1e              LDR      r3,|L5.152|
000020  681c              LDR      r4,[r3,#0]
000022  f4140480          ANDS     r4,r4,#0x400000
000026  d003              BEQ      |L5.48|
000028  f5b40f80          CMP      r4,#0x400000
00002c  bf08              IT       EQ
00002e  4661              MOVEQ    r1,r12
                  |L5.48|
000030  f8d3c000          LDR      r12,[r3,#0]
000034  f00c0c3f          AND      r12,r12,#0x3f
000038  fbb1fcfc          UDIV     r12,r1,r12
00003c  6819              LDR      r1,[r3,#0]
00003e  681b              LDR      r3,[r3,#0]
000040  f3c11188          UBFX     r1,r1,#6,#9
000044  fb0cf101          MUL      r1,r12,r1
000048  f3c34301          UBFX     r3,r3,#16,#2
00004c  1c5b              ADDS     r3,r3,#1
00004e  005b              LSLS     r3,r3,#1
000050  fbb1f1f3          UDIV     r1,r1,r3
                  |L5.84|
000054  6001              STR      r1,[r0,#0]
000056  6813              LDR      r3,[r2,#0]
000058  f8dfc040          LDR      r12,|L5.156|
00005c  f00303f0          AND      r3,r3,#0xf0
000060  091b              LSRS     r3,r3,#4
000062  f81c3003          LDRB     r3,[r12,r3]
000066  40d9              LSRS     r1,r1,r3
000068  6041              STR      r1,[r0,#4]
00006a  6813              LDR      r3,[r2,#0]
00006c  f3c32c82          UBFX     r12,r3,#10,#3
000070  4b0b              LDR      r3,|L5.160|
000072  f813c00c          LDRB     r12,[r3,r12]
000076  fa21fc0c          LSR      r12,r1,r12
00007a  f8c0c008          STR      r12,[r0,#8]
00007e  6812              LDR      r2,[r2,#0]
000080  f3c23242          UBFX     r2,r2,#13,#3
000084  5c9a              LDRB     r2,[r3,r2]
000086  40d1              LSRS     r1,r1,r2
;;;320      /* Get SYSCLK frequency */
;;;321      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
;;;322    
;;;323      /* HCLK clock frequency */
;;;324      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
;;;325    
;;;326      /* PCLK1 clock frequency */
;;;327      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
;;;328    
;;;329      /* PCLK2 clock frequency */
;;;330      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
000088  60c1              STR      r1,[r0,#0xc]
;;;331    }
00008a  bc10              POP      {r4}
00008c  4770              BX       lr
;;;332    
                          ENDP

00008e  0000              DCW      0x0000
                  |L5.144|
                          DCD      0x40023808
                  |L5.148|
                          DCD      0x00f42400
                  |L5.152|
                          DCD      0x40023804
                  |L5.156|
                          DCD      AHBPrescTable
                  |L5.160|
                          DCD      APBPrescTable

                          AREA ||i.LL_RCC_GetUSBClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetUSBClockFreq PROC
;;;862      */
;;;863    uint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)
000000  490f              LDR      r1,|L6.64|
;;;864    {
;;;865      uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000002  2000              MOVS     r0,#0
;;;866    
;;;867      /* Check parameter */
;;;868      assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));
;;;869    
;;;870    #if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)
;;;871      /* USBCLK clock frequency */
;;;872      switch (LL_RCC_GetUSBClockSource(USBxSource))
;;;873      {
;;;874    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;875        case LL_RCC_USB_CLKSOURCE_PLLI2S:       /* PLLI2S clock used as USB clock source */
;;;876          if (LL_RCC_PLLI2S_IsReady())
;;;877          {
;;;878            usb_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;879          }
;;;880          break;
;;;881    
;;;882    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;883    
;;;884    #if defined(RCC_PLLSAI_SUPPORT)
;;;885        case LL_RCC_USB_CLKSOURCE_PLLSAI:       /* PLLSAI clock used as USB clock source */
;;;886          if (LL_RCC_PLLSAI_IsReady())
;;;887          {
;;;888            usb_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;889          }
;;;890          break;
;;;891    #endif /* RCC_PLLSAI_SUPPORT */
;;;892    
;;;893        case LL_RCC_USB_CLKSOURCE_PLL:          /* PLL clock used as USB clock source */
;;;894        default:
;;;895          if (LL_RCC_PLL_IsReady())
;;;896          {
;;;897            usb_frequency = RCC_PLL_GetFreqDomain_48M();
;;;898          }
;;;899          break;
;;;900      }
;;;901    #else
;;;902      /* PLL clock used as USB clock source */
;;;903      if (LL_RCC_PLL_IsReady())
000004  6809              LDR      r1,[r1,#0]
000006  f0117f00          TST      r1,#0x2000000
;;;904      {
;;;905        usb_frequency = RCC_PLL_GetFreqDomain_48M();
;;;906      }
;;;907    #endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */
;;;908    
;;;909      return usb_frequency;
;;;910    }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  490d              LDR      r1,|L6.68|
000010  6808              LDR      r0,[r1,#0]
000012  f4100280          ANDS     r2,r0,#0x400000
000016  480c              LDR      r0,|L6.72|
000018  d003              BEQ      |L6.34|
00001a  f5b20f80          CMP      r2,#0x400000
00001e  bf08              IT       EQ
000020  480a              LDREQ    r0,|L6.76|
                  |L6.34|
000022  680a              LDR      r2,[r1,#0]
000024  f002023f          AND      r2,r2,#0x3f
000028  fbb0f2f2          UDIV     r2,r0,r2
00002c  6808              LDR      r0,[r1,#0]
00002e  6809              LDR      r1,[r1,#0]
000030  f3c01088          UBFX     r0,r0,#6,#9
000034  4350              MULS     r0,r2,r0
000036  f3c16103          UBFX     r1,r1,#24,#4
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  4770              BX       lr
;;;911    #endif /* USB_OTG_FS || USB_OTG_HS */
                          ENDP

                  |L6.64|
                          DCD      0x40023800
                  |L6.68|
                          DCD      0x40023804
                  |L6.72|
                          DCD      0x00f42400
                  |L6.76|
                          DCD      0x007a1200

                          AREA ||i.RCC_GetHCLKClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetHCLKClockFreq PROC
;;;1171     */
;;;1172   uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
000000  4904              LDR      r1,|L7.20|
000002  6809              LDR      r1,[r1,#0]
;;;1173   {
;;;1174     /* HCLK clock frequency */
;;;1175     return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
000004  4a04              LDR      r2,|L7.24|
000006  f00101f0          AND      r1,r1,#0xf0
00000a  0909              LSRS     r1,r1,#4
00000c  5c51              LDRB     r1,[r2,r1]
00000e  40c8              LSRS     r0,r0,r1
;;;1176   }
000010  4770              BX       lr
;;;1177   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023808
                  |L7.24|
                          DCD      AHBPrescTable

                          AREA ||i.RCC_GetPCLK1ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK1ClockFreq PROC
;;;1182     */
;;;1183   uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
000000  4903              LDR      r1,|L8.16|
;;;1184   {
;;;1185     /* PCLK1 clock frequency */
;;;1186     return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
000002  6809              LDR      r1,[r1,#0]
000004  4a03              LDR      r2,|L8.20|
000006  f3c12182          UBFX     r1,r1,#10,#3
00000a  5c51              LDRB     r1,[r2,r1]
00000c  40c8              LSRS     r0,r0,r1
;;;1187   }
00000e  4770              BX       lr
;;;1188   
                          ENDP

                  |L8.16|
                          DCD      0x40023808
                  |L8.20|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetPCLK2ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK2ClockFreq PROC
;;;1193     */
;;;1194   uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
000000  4903              LDR      r1,|L9.16|
;;;1195   {
;;;1196     /* PCLK2 clock frequency */
;;;1197     return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
000002  6809              LDR      r1,[r1,#0]
000004  4a03              LDR      r2,|L9.20|
000006  f3c13142          UBFX     r1,r1,#13,#3
00000a  5c51              LDRB     r1,[r2,r1]
00000c  40c8              LSRS     r0,r0,r1
;;;1198   }
00000e  4770              BX       lr
;;;1199   
                          ENDP

                  |L9.16|
                          DCD      0x40023808
                  |L9.20|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetSystemClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetSystemClockFreq PROC
;;;1133     */
;;;1134   uint32_t RCC_GetSystemClockFreq(void)
000000  4814              LDR      r0,|L10.84|
000002  6800              LDR      r0,[r0,#0]
000004  f010020c          ANDS     r2,r0,#0xc
;;;1135   {
;;;1136     uint32_t frequency = 0U;
;;;1137   
;;;1138     /* Get SYSCLK source -------------------------------------------------------*/
;;;1139     switch (LL_RCC_GetSysClkSource())
;;;1140     {
;;;1141       case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
;;;1142         frequency = HSI_VALUE;
000008  4813              LDR      r0,|L10.88|
;;;1143         break;
;;;1144   
;;;1145       case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;1146         frequency = HSE_VALUE;
;;;1147         break;
;;;1148   
;;;1149       case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;1150         frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
;;;1151         break;
;;;1152   
;;;1153   #if defined(RCC_PLLR_SYSCLK_SUPPORT)
;;;1154       case LL_RCC_SYS_CLKSOURCE_STATUS_PLLR: /* PLLR used as system clock  source */
;;;1155         frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLLR);
;;;1156         break;
;;;1157   #endif /* RCC_PLLR_SYSCLK_SUPPORT */
;;;1158   
;;;1159       default:
;;;1160         frequency = HSI_VALUE;
;;;1161         break;
;;;1162     }
;;;1163   
;;;1164     return frequency;
;;;1165   }
00000a  bf08              IT       EQ
00000c  4770              BXEQ     lr
00000e  4913              LDR      r1,|L10.92|
000010  2a04              CMP      r2,#4                 ;1139
000012  bf04              ITT      EQ                    ;1146
000014  4608              MOVEQ    r0,r1                 ;1146
000016  4770              BXEQ     lr
000018  2a08              CMP      r2,#8                 ;1139
00001a  bf18              IT       NE
00001c  4770              BXNE     lr
00001e  4a10              LDR      r2,|L10.96|
000020  6813              LDR      r3,[r2,#0]
000022  f4130380          ANDS     r3,r3,#0x400000
000026  d003              BEQ      |L10.48|
000028  f5b30f80          CMP      r3,#0x400000
00002c  bf08              IT       EQ
00002e  4608              MOVEQ    r0,r1
                  |L10.48|
000030  6811              LDR      r1,[r2,#0]
000032  f001013f          AND      r1,r1,#0x3f
000036  fbb0f1f1          UDIV     r1,r0,r1
00003a  6810              LDR      r0,[r2,#0]
00003c  f3c01088          UBFX     r0,r0,#6,#9
000040  4348              MULS     r0,r1,r0
000042  6811              LDR      r1,[r2,#0]
000044  f3c14101          UBFX     r1,r1,#16,#2
000048  1c49              ADDS     r1,r1,#1
00004a  0049              LSLS     r1,r1,#1
00004c  fbb0f0f1          UDIV     r0,r0,r1
000050  4770              BX       lr
;;;1166   
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x40023808
                  |L10.88|
                          DCD      0x00f42400
                  |L10.92|
                          DCD      0x007a1200
                  |L10.96|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2S_GetFreqDomain_I2S||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2S_GetFreqDomain_I2S PROC
;;;1588     */
;;;1589   uint32_t RCC_PLLI2S_GetFreqDomain_I2S(void)
000000  490c              LDR      r1,|L11.52|
;;;1590   {
;;;1591     uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;
;;;1592   
;;;1593     /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN
;;;1594        I2S Domain clock  = PLLI2S_VCO / PLLI2SR
;;;1595     */
;;;1596     plli2ssource = LL_RCC_PLLI2S_GetMainSource();
000002  6808              LDR      r0,[r1,#0]
000004  f4000080          AND      r0,r0,#0x400000
;;;1597   
;;;1598     switch (plli2ssource)
000008  f5b00f80          CMP      r0,#0x400000
;;;1599     {
;;;1600       case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */
;;;1601         plli2sinputfreq = HSE_VALUE;
;;;1602         break;
;;;1603   
;;;1604   #if defined(RCC_PLLI2SCFGR_PLLI2SSRC)
;;;1605       case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */
;;;1606         plli2sinputfreq = EXTERNAL_CLOCK_VALUE;
;;;1607         break;
;;;1608   #endif /* RCC_PLLI2SCFGR_PLLI2SSRC */
;;;1609   
;;;1610       case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */
;;;1611       default:
;;;1612         plli2sinputfreq = HSI_VALUE;
00000c  bf14              ITE      NE
00000e  480a              LDRNE    r0,|L11.56|
000010  480a              LDREQ    r0,|L11.60|
000012  6809              LDR      r1,[r1,#0]            ;1601
000014  f001013f          AND      r1,r1,#0x3f           ;1601
;;;1613         break;
;;;1614     }
;;;1615   
;;;1616     plli2soutputfreq = __LL_RCC_CALC_PLLI2S_I2S_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),
000018  fbb0f2f1          UDIV     r2,r0,r1
00001c  4808              LDR      r0,|L11.64|
00001e  6801              LDR      r1,[r0,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f3c11188          UBFX     r1,r1,#6,#9
000026  4351              MULS     r1,r2,r1
000028  f3c07002          UBFX     r0,r0,#28,#3
00002c  fbb1f0f0          UDIV     r0,r1,r0
;;;1617                                                      LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR());
;;;1618   
;;;1619     return plli2soutputfreq;
;;;1620   }
000030  4770              BX       lr
;;;1621   
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40023804
                  |L11.56|
                          DCD      0x00f42400
                  |L11.60|
                          DCD      0x007a1200
                  |L11.64|
                          DCD      0x40023884

                          AREA ||i.RCC_PLL_GetFreqDomain_48M||, CODE, READONLY, ALIGN=2

                  RCC_PLL_GetFreqDomain_48M PROC
;;;1248     */
;;;1249   uint32_t RCC_PLL_GetFreqDomain_48M(void)
000000  480c              LDR      r0,|L12.52|
;;;1250   {
;;;1251     uint32_t pllinputfreq = 0U, pllsource = 0U;
;;;1252   
;;;1253     /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM ) * PLLN
;;;1254        48M Domain clock = PLL_VCO / PLLQ
;;;1255     */
;;;1256     pllsource = LL_RCC_PLL_GetMainSource();
000002  6801              LDR      r1,[r0,#0]
000004  f4110280          ANDS     r2,r1,#0x400000
;;;1257   
;;;1258     switch (pllsource)
;;;1259     {
;;;1260       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1261         pllinputfreq = HSI_VALUE;
000008  490b              LDR      r1,|L12.56|
00000a  d003              BEQ      |L12.20|
00000c  f5b20f80          CMP      r2,#0x400000          ;1258
;;;1262         break;
;;;1263   
;;;1264       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1265         pllinputfreq = HSE_VALUE;
000010  bf08              IT       EQ
000012  490a              LDREQ    r1,|L12.60|
                  |L12.20|
000014  6802              LDR      r2,[r0,#0]
000016  f002023f          AND      r2,r2,#0x3f
;;;1266         break;
;;;1267   
;;;1268       default:
;;;1269         pllinputfreq = HSI_VALUE;
;;;1270         break;
;;;1271     }
;;;1272     return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
00001a  fbb1f2f2          UDIV     r2,r1,r2
00001e  6801              LDR      r1,[r0,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f3c11188          UBFX     r1,r1,#6,#9
000026  4351              MULS     r1,r2,r1
000028  f3c06003          UBFX     r0,r0,#24,#4
00002c  fbb1f0f0          UDIV     r0,r1,r0
;;;1273                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());
;;;1274   }
000030  4770              BX       lr
;;;1275   
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40023804
                  |L12.56|
                          DCD      0x00f42400
                  |L12.60|
                          DCD      0x007a1200

                          AREA ||i.RCC_PLL_GetFreqDomain_SYS||, CODE, READONLY, ALIGN=2

                  RCC_PLL_GetFreqDomain_SYS PROC
;;;1204     */
;;;1205   uint32_t RCC_PLL_GetFreqDomain_SYS(uint32_t SYSCLK_Source)
000000  4a0f              LDR      r2,|L13.64|
;;;1206   {
000002  4603              MOV      r3,r0
;;;1207     uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;
000004  2000              MOVS     r0,#0
;;;1208   
;;;1209     /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1210        SYSCLK = PLL_VCO / (PLLP or PLLR)
;;;1211     */
;;;1212     pllsource = LL_RCC_PLL_GetMainSource();
000006  6811              LDR      r1,[r2,#0]
000008  f4110c80          ANDS     r12,r1,#0x400000
;;;1213   
;;;1214     switch (pllsource)
;;;1215     {
;;;1216       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1217         pllinputfreq = HSI_VALUE;
00000c  490d              LDR      r1,|L13.68|
00000e  d003              BEQ      |L13.24|
000010  f5bc0f80          CMP      r12,#0x400000         ;1214
;;;1218         break;
;;;1219   
;;;1220       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1221         pllinputfreq = HSE_VALUE;
000014  bf08              IT       EQ
000016  490c              LDREQ    r1,|L13.72|
                  |L13.24|
;;;1222         break;
;;;1223   
;;;1224       default:
;;;1225         pllinputfreq = HSI_VALUE;
;;;1226         break;
;;;1227     }
;;;1228   
;;;1229     if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
000018  2b08              CMP      r3,#8
;;;1230     {
;;;1231       plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
;;;1232                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());
;;;1233     }
;;;1234   #if defined(RCC_PLLR_SYSCLK_SUPPORT)
;;;1235     else
;;;1236     {
;;;1237       plloutputfreq = __LL_RCC_CALC_PLLRCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
;;;1238                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
;;;1239     }
;;;1240   #endif /* RCC_PLLR_SYSCLK_SUPPORT */
;;;1241   
;;;1242     return plloutputfreq;
;;;1243   }
00001a  bf18              IT       NE
00001c  4770              BXNE     lr
00001e  6810              LDR      r0,[r2,#0]
000020  f000003f          AND      r0,r0,#0x3f
000024  fbb1f1f0          UDIV     r1,r1,r0              ;1231
000028  6810              LDR      r0,[r2,#0]            ;1231
00002a  f3c01088          UBFX     r0,r0,#6,#9           ;1231
00002e  4348              MULS     r0,r1,r0              ;1231
000030  6811              LDR      r1,[r2,#0]            ;1231
000032  f3c14101          UBFX     r1,r1,#16,#2          ;1231
000036  1c49              ADDS     r1,r1,#1              ;1231
000038  0049              LSLS     r1,r1,#1              ;1231
00003a  fbb0f0f1          UDIV     r0,r0,r1              ;1231
00003e  4770              BX       lr
;;;1244   
                          ENDP

                  |L13.64|
                          DCD      0x40023804
                  |L13.68|
                          DCD      0x00f42400
                  |L13.72|
                          DCD      0x007a1200

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____RRX|
#line 587
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
