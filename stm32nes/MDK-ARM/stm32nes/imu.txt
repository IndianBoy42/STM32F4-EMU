; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\imu.o --depend=stm32nes\imu.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\FieryDragon\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_FULL_LL_DRIVER -DSTM32F407xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\imu.crf ..\Src\imu.c]
                          THUMB

                          AREA ||i.IMU_dataAvailable||, CODE, READONLY, ALIGN=2

                  IMU_dataAvailable PROC
;;;120    
;;;121    uint8_t IMU_dataAvailable(void){
000000  4813              LDR      r0,|L1.80|
;;;122    	//If we have an interrupt pin connection available, check if data is available.
;;;123    	//If int pin is NULL, then we'll rely on receivePacket() to timeout
;;;124    	//See issue 13: https://github.com/sparkfun/SparkFun_BNO080_Arduino_Library/issues/13
;;;125    	if (gpio_read(APU_IRQ)) return 2;
000002  6800              LDR      r0,[r0,#0]
000004  f4107f00          TST      r0,#0x200
000008  bf1c              ITT      NE
00000a  2002              MOVNE    r0,#2
;;;126    
;;;127    	if (IMU_receivePacket()){
;;;128    		//Check to see if this packet is a sensor reporting its data to us
;;;129    		if (shtpHeader[2] == CHANNEL_REPORTS && shtpData[0] == SHTP_REPORT_BASE_TIMESTAMP)
;;;130    		{
;;;131    			IMU_parseInputReport(); //This will update the rawAccelX, etc variables depending on which feature report is found
;;;132    			return 1;
;;;133    		}
;;;134    		else if (shtpHeader[2] == CHANNEL_CONTROL)
;;;135    		{
;;;136    			IMU_parseCommandReport(); //This will update responses to commands, calibrationStatus, etc.
;;;137    			return 1;
;;;138    		}
;;;139    	}
;;;140    	return 0;
;;;141    }
00000c  4770              BXNE     lr
00000e  b510              PUSH     {r4,lr}               ;121
000010  f7fffffe          BL       IMU_receivePacket
000014  b150              CBZ      r0,|L1.44|
000016  480f              LDR      r0,|L1.84|
000018  7881              LDRB     r1,[r0,#2]            ;129  ; shtpHeader
00001a  480f              LDR      r0,|L1.88|
00001c  2903              CMP      r1,#3                 ;129
00001e  d002              BEQ      |L1.38|
000020  2902              CMP      r1,#2                 ;134
000022  d009              BEQ      |L1.56|
000024  e002              B        |L1.44|
                  |L1.38|
000026  7800              LDRB     r0,[r0,#0]            ;129  ; shtpData
000028  28fb              CMP      r0,#0xfb              ;129
00002a  d001              BEQ      |L1.48|
                  |L1.44|
00002c  2000              MOVS     r0,#0                 ;140
00002e  bd10              POP      {r4,pc}
                  |L1.48|
000030  f7fffffe          BL       IMU_parseInputReport
000034  2001              MOVS     r0,#1                 ;132
000036  bd10              POP      {r4,pc}
                  |L1.56|
000038  7801              LDRB     r1,[r0,#0]  ; shtpData
00003a  29f1              CMP      r1,#0xf1
00003c  bf04              ITT      EQ
00003e  7881              LDRBEQ   r1,[r0,#2]  ; shtpData
000040  2907              CMPEQ    r1,#7
000042  d102              BNE      |L1.74|
000044  4905              LDR      r1,|L1.92|
000046  7940              LDRB     r0,[r0,#5]  ; shtpData
000048  70c8              STRB     r0,[r1,#3]
                  |L1.74|
00004a  f04f0001          MOV      r0,#1                 ;137
00004e  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L1.80|
                          DCD      0x40020c10
                  |L1.84|
                          DCD      ||.data||+0x38
                  |L1.88|
                          DCD      ||.bss||
                  |L1.92|
                          DCD      ||.data||

                          AREA ||i.IMU_enableAccel||, CODE, READONLY, ALIGN=1

                  IMU_enableAccel PROC
;;;366    
;;;367    void IMU_enableAccel(uint16_t freq)
000000  2200              MOVS     r2,#0
;;;368    {
;;;369    	IMU_setFeatureCommand(SENSOR_REPORTID_ACCELEROMETER, freq,0);
000002  4601              MOV      r1,r0
000004  2001              MOVS     r0,#1
000006  f7ffbffe          B.W      IMU_setFeatureCommand
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.IMU_enableGyro||, CODE, READONLY, ALIGN=1

                  IMU_enableGyro PROC
;;;356    
;;;357    void IMU_enableGyro(uint16_t freq)
000000  2200              MOVS     r2,#0
;;;358    {
;;;359    	IMU_setFeatureCommand(SENSOR_REPORTID_GYROSCOPE, freq,0);
000002  4601              MOV      r1,r0
000004  2002              MOVS     r0,#2
000006  f7ffbffe          B.W      IMU_setFeatureCommand
;;;360    }
;;;361    
                          ENDP


                          AREA ||i.IMU_enableRotation||, CODE, READONLY, ALIGN=1

                  IMU_enableRotation PROC
;;;361    
;;;362    void IMU_enableRotation(uint16_t freq)
000000  2200              MOVS     r2,#0
;;;363    {
;;;364    	IMU_setFeatureCommand(SENSOR_REPORTID_ROTATION_VECTOR, freq,0);
000002  4601              MOV      r1,r0
000004  2005              MOVS     r0,#5
000006  f7ffbffe          B.W      IMU_setFeatureCommand
;;;365    }
;;;366    
                          ENDP


                          AREA ||i.IMU_init||, CODE, READONLY, ALIGN=2

                  IMU_init PROC
;;;142    
;;;143    uint8_t IMU_init(void) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4837              LDR      r0,|L5.224|
000004  6801              LDR      r1,[r0,#0]
000006  f0410140          ORR      r1,r1,#0x40
00000a  6001              STR      r1,[r0,#0]
;;;144    	LL_SPI_Enable(IMU_SPI);
;;;145    
;;;146    	gpio_set(APU_NSS);
00000c  1581              ASRS     r1,r0,#22
00000e  4835              LDR      r0,|L5.228|
000010  6181              STR      r1,[r0,#0x18]
;;;147    	gpio_set(APU_IO1);
000012  14c1              ASRS     r1,r0,#19
000014  6181              STR      r1,[r0,#0x18]
;;;148    	gpio_set(APU_IO2);
000016  1481              ASRS     r1,r0,#18
000018  6181              STR      r1,[r0,#0x18]
;;;149    
;;;150    	gpio_reset(APU_RST);
00001a  4a33              LDR      r2,|L5.232|
00001c  0389              LSLS     r1,r1,#14
00001e  6011              STR      r1,[r2,#0]
000020  4c32              LDR      r4,|L5.236|
;;;151    	delay(2);
000022  2102              MOVS     r1,#2
000024  6021              STR      r1,[r4,#0]  ; __delay
                  |L5.38|
000026  6821              LDR      r1,[r4,#0]  ; __delay
000028  2900              CMP      r1,#0
00002a  d1fc              BNE      |L5.38|
;;;152    	gpio_set(APU_RST);
00002c  f44f6180          MOV      r1,#0x400
000030  6181              STR      r1,[r0,#0x18]
000032  2100              MOVS     r1,#0
000034  4d2e              LDR      r5,|L5.240|
000036  460e              MOV      r6,r1
                  |L5.56|
000038  6828              LDR      r0,[r5,#0]
00003a  f4107f00          TST      r0,#0x200
00003e  bf1c              ITT      NE
000040  2001              MOVNE    r0,#1
000042  6020              STRNE    r0,[r4,#0]  ; __delay
000044  d008              BEQ      |L5.88|
                  |L5.70|
000046  6820              LDR      r0,[r4,#0]  ; __delay
000048  2800              CMP      r0,#0
00004a  d1fc              BNE      |L5.70|
00004c  1c48              ADDS     r0,r1,#1
00004e  b2c1              UXTB     r1,r0
000050  297d              CMP      r1,#0x7d
000052  d3f1              BCC      |L5.56|
                  |L5.84|
;;;153    
;;;154    	if (!IMU_waitForSPI()) return 0;
000054  2000              MOVS     r0,#0
;;;155    	// shtpData[0] = 1; //Reset
;;;156    
;;;157    	// //Attempt to start communication with sensor
;;;158    	// IMU_sendPacket(CHANNEL_EXECUTABLE, 1); //Transmit packet on channel 1, 1 byte
;;;159    
;;;160    	// //Read all incoming data and flush it
;;;161    	// delay(50);
;;;162    	// while (IMU_receivePacket());
;;;163    	// delay(50);
;;;164    	// while (IMU_receivePacket());
;;;165    	
;;;166    	IMU_waitForSPI();
;;;167    	IMU_receivePacket();
;;;168    
;;;169    	IMU_waitForSPI();
;;;170    	IMU_receivePacket();
;;;171    
;;;172    	shtpData[0] = SHTP_REPORT_PRODUCT_ID_REQUEST; //Request the product ID and reset info
;;;173    	shtpData[1] = 0;							  //Reserved
;;;174    
;;;175    	IMU_sendPacket(CHANNEL_CONTROL, 2);
;;;176    	IMU_waitForSPI();
;;;177    	if (IMU_receivePacket())
;;;178    	{
;;;179    		if (shtpData[0] == SHTP_REPORT_PRODUCT_ID_RESPONSE)
;;;180    			return 1;
;;;181    	}
;;;182    	return 0;
;;;183    }
000056  bdf0              POP      {r4-r7,pc}
                  |L5.88|
000058  2100              MOVS     r1,#0
                  |L5.90|
00005a  6828              LDR      r0,[r5,#0]
00005c  f4107f00          TST      r0,#0x200
000060  bf1c              ITT      NE
000062  2001              MOVNE    r0,#1
000064  6020              STRNE    r0,[r4,#0]  ; __delay
000066  d006              BEQ      |L5.118|
                  |L5.104|
000068  6820              LDR      r0,[r4,#0]  ; __delay
00006a  2800              CMP      r0,#0
00006c  d1fc              BNE      |L5.104|
00006e  1c48              ADDS     r0,r1,#1
000070  b2c1              UXTB     r1,r0
000072  297d              CMP      r1,#0x7d
000074  d3f1              BCC      |L5.90|
                  |L5.118|
000076  f7fffffe          BL       IMU_receivePacket
00007a  2100              MOVS     r1,#0                 ;167
                  |L5.124|
00007c  6828              LDR      r0,[r5,#0]            ;167
00007e  f4107f00          TST      r0,#0x200             ;167
000082  bf1c              ITT      NE                    ;167
000084  2001              MOVNE    r0,#1                 ;167
000086  6020              STRNE    r0,[r4,#0]            ;167  ; __delay
000088  d006              BEQ      |L5.152|
                  |L5.138|
00008a  6820              LDR      r0,[r4,#0]            ;167  ; __delay
00008c  2800              CMP      r0,#0                 ;167
00008e  d1fc              BNE      |L5.138|
000090  1c48              ADDS     r0,r1,#1              ;167
000092  b2c1              UXTB     r1,r0                 ;167
000094  297d              CMP      r1,#0x7d              ;167
000096  d3f1              BCC      |L5.124|
                  |L5.152|
000098  f7fffffe          BL       IMU_receivePacket
00009c  4f15              LDR      r7,|L5.244|
00009e  20f9              MOVS     r0,#0xf9              ;172
0000a0  2102              MOVS     r1,#2                 ;175
0000a2  7038              STRB     r0,[r7,#0]            ;172
0000a4  707e              STRB     r6,[r7,#1]            ;173
0000a6  4608              MOV      r0,r1                 ;175
0000a8  f7fffffe          BL       IMU_sendPacket
0000ac  2100              MOVS     r1,#0                 ;175
                  |L5.174|
0000ae  6828              LDR      r0,[r5,#0]            ;175
0000b0  f4107f00          TST      r0,#0x200             ;175
0000b4  bf1c              ITT      NE                    ;175
0000b6  2001              MOVNE    r0,#1                 ;175
0000b8  6020              STRNE    r0,[r4,#0]            ;175  ; __delay
0000ba  d006              BEQ      |L5.202|
                  |L5.188|
0000bc  6820              LDR      r0,[r4,#0]            ;175  ; __delay
0000be  2800              CMP      r0,#0                 ;175
0000c0  d1fc              BNE      |L5.188|
0000c2  1c48              ADDS     r0,r1,#1              ;175
0000c4  b2c1              UXTB     r1,r0                 ;175
0000c6  297d              CMP      r1,#0x7d              ;175
0000c8  d3f1              BCC      |L5.174|
                  |L5.202|
0000ca  f7fffffe          BL       IMU_receivePacket
0000ce  2800              CMP      r0,#0                 ;177
0000d0  d0c0              BEQ      |L5.84|
0000d2  7838              LDRB     r0,[r7,#0]            ;179  ; shtpData
0000d4  28f8              CMP      r0,#0xf8              ;179
0000d6  bf08              IT       EQ                    ;180
0000d8  2001              MOVEQ    r0,#1                 ;180
0000da  d1bb              BNE      |L5.84|
0000dc  bdf0              POP      {r4-r7,pc}
;;;184    
                          ENDP

0000de  0000              DCW      0x0000
                  |L5.224|
                          DCD      0x40003800
                  |L5.228|
                          DCD      0x40020c00
                  |L5.232|
                          DCD      0x40020c18
                  |L5.236|
                          DCD      __delay
                  |L5.240|
                          DCD      0x40020c10
                  |L5.244|
                          DCD      ||.bss||

                          AREA ||i.IMU_parseCommandReport||, CODE, READONLY, ALIGN=2

                  IMU_parseCommandReport PROC
;;;184    
;;;185    void IMU_parseCommandReport(void) {
000000  4805              LDR      r0,|L6.24|
;;;186    	if (shtpData[0] == SHTP_REPORT_COMMAND_RESPONSE)
000002  7801              LDRB     r1,[r0,#0]  ; shtpData
000004  29f1              CMP      r1,#0xf1
;;;187    	{
;;;188    		//The BNO080 responds with this report to command requests. It's up to use to remember which command we issued.
;;;189    		uint8_t command = shtpData[2]; //This is the Command byte of the response
000006  bf06              ITTE     EQ
000008  7881              LDRBEQ   r1,[r0,#2]  ; shtpData
;;;190    
;;;191    		if (command == COMMAND_ME_CALIBRATE)
00000a  2907              CMPEQ    r1,#7
;;;192    		{
;;;193    			calibrationStatus = shtpData[5 + 0]; //R0 - Status (0 = success, non-zero = fail)
;;;194    		}
;;;195    	}
;;;196    }
00000c  4770              BXNE     lr
00000e  7940              LDRB     r0,[r0,#5]            ;193  ; shtpData
000010  4902              LDR      r1,|L6.28|
000012  70c8              STRB     r0,[r1,#3]            ;193
000014  4770              BX       lr
;;;197    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      ||.bss||
                  |L6.28|
                          DCD      ||.data||

                          AREA ||i.IMU_parseInputReport||, CODE, READONLY, ALIGN=2

                  IMU_parseInputReport PROC
;;;198    
;;;199    void IMU_parseInputReport(void) {
000000  e92d03f0          PUSH     {r4-r9}
;;;200    	//Calculate the number of data bytes in this packet
;;;201    	int16_t dataLength = ((uint16_t)shtpHeader[1] << 8 | shtpHeader[0]);
000004  4844              LDR      r0,|L7.280|
;;;202    	dataLength &= ~(1 << 15); //Clear the MSbit. This bit indicates if this package is a continuation of the last.
;;;203    	//Ignore it for now. TODO catch this as an error and exit
;;;204    
;;;205    	dataLength -= 4; //Remove the header bytes from the data count
;;;206    
;;;207    	timeStamp = ((uint32_t)shtpData[4] << (8 * 3)) | (shtpData[3] << (8 * 2)) | (shtpData[2] << (8 * 1)) | (shtpData[1] << (8 * 0));
000006  4b45              LDR      r3,|L7.284|
;;;208    
;;;209    	uint8_t status = shtpData[5 + 2] & 0x03; //Get status bits
;;;210    	uint16_t data1 = (uint16_t)shtpData[5 + 5] << 8 | shtpData[5 + 4];
;;;211    	uint16_t data2 = (uint16_t)shtpData[5 + 7] << 8 | shtpData[5 + 6];
;;;212    	uint16_t data3 = (uint16_t)shtpData[5 + 9] << 8 | shtpData[5 + 8];
;;;213    	uint16_t data4 = 0;
000008  2700              MOVS     r7,#0
00000a  8800              LDRH     r0,[r0,#0]            ;201  ; shtpHeader
00000c  f8d32002          LDR      r2,[r3,#2]            ;207  ; shtpData
000010  f4204000          BIC      r0,r0,#0x8000         ;202
000014  1f00              SUBS     r0,r0,#4              ;202
000016  b201              SXTH     r1,r0                 ;205
000018  7858              LDRB     r0,[r3,#1]            ;207  ; shtpData
;;;214    	uint16_t data5 = 0;
00001a  1f49              SUBS     r1,r1,#5
00001c  ea402202          ORR      r2,r0,r2,LSL #8       ;207
000020  483f              LDR      r0,|L7.288|
000022  46b8              MOV      r8,r7
;;;215    
;;;216    	if (dataLength - 5 > 9)
000024  2909              CMP      r1,#9
000026  63c2              STR      r2,[r0,#0x3c]         ;209  ; timeStamp
000028  f893c007          LDRB     r12,[r3,#7]           ;209  ; shtpData
00002c  f8b36009          LDRH     r6,[r3,#9]            ;210  ; shtpData
000030  f8b3400b          LDRH     r4,[r3,#0xb]          ;211  ; shtpData
000034  f8b3200d          LDRH     r2,[r3,#0xd]          ;212  ; shtpData
000038  f00c0503          AND      r5,r12,#3             ;209
;;;217    	{
;;;218    		data4 = (uint16_t)shtpData[5 + 11] << 8 | shtpData[5 + 10];
00003c  bfc8              IT       GT
00003e  f8b3700f          LDRHGT   r7,[r3,#0xf]  ; shtpData
;;;219    	}
;;;220    	if (dataLength - 5 > 11)
000042  290b              CMP      r1,#0xb
;;;221    	{
;;;222    		data5 = (uint16_t)shtpData[5 + 13] << 8 | shtpData[5 + 12];
000044  bfc8              IT       GT
000046  f8b38011          LDRHGT   r8,[r3,#0x11]  ; shtpData
;;;223    	}
;;;224    
;;;225    	//Store these generic values to their proper global variable
;;;226    	if (shtpData[5] == SENSOR_REPORTID_ACCELEROMETER)
00004a  7959              LDRB     r1,[r3,#5]  ; shtpData
00004c  2901              CMP      r1,#1
00004e  d022              BEQ      |L7.150|
;;;227    	{
;;;228    		accelAccuracy = status;
;;;229    		rawAccelX = data1;
;;;230    		rawAccelY = data2;
;;;231    		rawAccelZ = data3;
;;;232    	}
;;;233    	else if (shtpData[5] == SENSOR_REPORTID_LINEAR_ACCELERATION)
000050  2904              CMP      r1,#4
000052  d027              BEQ      |L7.164|
;;;234    	{
;;;235    		accelLinAccuracy = status;
;;;236    		rawLinAccelX = data1;
;;;237    		rawLinAccelY = data2;
;;;238    		rawLinAccelZ = data3;
;;;239    	}
;;;240    	else if (shtpData[5] == SENSOR_REPORTID_GYROSCOPE)
000054  2902              CMP      r1,#2
000056  d02c              BEQ      |L7.178|
;;;241    	{
;;;242    		gyroAccuracy = status;
;;;243    		rawGyroX = data1;
;;;244    		rawGyroY = data2;
;;;245    		rawGyroZ = data3;
;;;246    	}
;;;247    	else if (shtpData[5] == SENSOR_REPORTID_MAGNETIC_FIELD)
000058  2903              CMP      r1,#3
00005a  d031              BEQ      |L7.192|
;;;248    	{
;;;249    		magAccuracy = status;
;;;250    		rawMagX = data1;
;;;251    		rawMagY = data2;
;;;252    		rawMagZ = data3;
;;;253    	}
;;;254    	else if (shtpData[5] == SENSOR_REPORTID_ROTATION_VECTOR || shtpData[5] == SENSOR_REPORTID_GAME_ROTATION_VECTOR)
00005c  2905              CMP      r1,#5
00005e  bf18              IT       NE
000060  2908              CMPNE    r1,#8
000062  d034              BEQ      |L7.206|
;;;255    	{
;;;256    		quatAccuracy = status;
;;;257    		rawQuatI = data1;
;;;258    		rawQuatJ = data2;
;;;259    		rawQuatK = data3;
;;;260    		rawQuatReal = data4;
;;;261    		rawQuatRadianAccuracy = data5; //Only available on rotation vector, not game rot vector
;;;262    	}
;;;263    	else if (shtpData[5] == SENSOR_REPORTID_STEP_COUNTER)
000064  2911              CMP      r1,#0x11
;;;264    	{
;;;265    		stepCount = data3; //Bytes 8/9
000066  bf02              ITTT     EQ
000068  86c2              STRHEQ   r2,[r0,#0x36]
;;;266    	}
;;;267    	else if (shtpData[5] == SENSOR_REPORTID_STABILITY_CLASSIFIER)
;;;268    	{
;;;269    		stabilityClassifier = shtpData[5 + 4]; //Byte 4 only
;;;270    	}
;;;271    	else if (shtpData[5] == SENSOR_REPORTID_PERSONAL_ACTIVITY_CLASSIFIER)
;;;272    	{
;;;273    		activityClassifier = shtpData[5 + 5]; //Most likely state
;;;274    
;;;275    		//Load activity classification confidences into the array
;;;276    		for (uint8_t x = 0; x < 9; x++)					   //Hardcoded to max of 9. TODO - bring in array size
;;;277    			_activityConfidences[x] = shtpData[5 + 6 + x]; //5 bytes of timestamp, byte 6 is first confidence byte
;;;278    	}
;;;279    	else if (shtpData[5] == SHTP_REPORT_COMMAND_RESPONSE)
;;;280    	{
;;;281    		// Serial.println("!");
;;;282    		//The BNO080 responds with this report to command requests. It's up to use to remember which command we issued.
;;;283    		uint8_t command = shtpData[5 + 2]; //This is the Command byte of the response
;;;284    
;;;285    		if (command == COMMAND_ME_CALIBRATE)
;;;286    		{
;;;287    			// Serial.println("ME Cal report found!");
;;;288    			calibrationStatus = shtpData[5 + 5]; //R0 - Status (0 = success, non-zero = fail)
;;;289    		}
;;;290    	}
;;;291    	else
;;;292    	{
;;;293    		//This sensor report ID is unhandled.
;;;294    		//See reference manual to add additional feature reports as needed
;;;295    	}
;;;296    }
00006a  e8bd03f0          POPEQ    {r4-r9}
00006e  4770              BXEQ     lr
000070  2913              CMP      r1,#0x13              ;267
000072  bf01              ITTTT    EQ                    ;269
000074  7a59              LDRBEQ   r1,[r3,#9]            ;269  ; shtpData
000076  7041              STRBEQ   r1,[r0,#1]            ;269
000078  e8bd03f0          POPEQ    {r4-r9}
00007c  4770              BXEQ     lr
00007e  4a27              LDR      r2,|L7.284|
000080  291e              CMP      r1,#0x1e              ;271
000082  7a92              LDRB     r2,[r2,#0xa]          ;273
000084  d02d              BEQ      |L7.226|
000086  29f1              CMP      r1,#0xf1              ;279
000088  bf04              ITT      EQ                    ;285
00008a  f1bc0f07          CMPEQ    r12,#7                ;285
00008e  70c2              STRBEQ   r2,[r0,#3]            ;288
000090  e8bd03f0          POP      {r4-r9}
000094  4770              BX       lr
                  |L7.150|
000096  8205              STRH     r5,[r0,#0x10]         ;228
000098  8146              STRH     r6,[r0,#0xa]          ;229
00009a  8184              STRH     r4,[r0,#0xc]          ;230
00009c  81c2              STRH     r2,[r0,#0xe]          ;231
00009e  e8bd03f0          POP      {r4-r9}
0000a2  4770              BX       lr
                  |L7.164|
0000a4  8305              STRH     r5,[r0,#0x18]         ;235
0000a6  8246              STRH     r6,[r0,#0x12]         ;236
0000a8  8284              STRH     r4,[r0,#0x14]         ;237
0000aa  82c2              STRH     r2,[r0,#0x16]         ;238
0000ac  e8bd03f0          POP      {r4-r9}
0000b0  4770              BX       lr
                  |L7.178|
0000b2  8405              STRH     r5,[r0,#0x20]         ;242
0000b4  8346              STRH     r6,[r0,#0x1a]         ;243
0000b6  8384              STRH     r4,[r0,#0x1c]         ;244
0000b8  83c2              STRH     r2,[r0,#0x1e]         ;245
0000ba  e8bd03f0          POP      {r4-r9}
0000be  4770              BX       lr
                  |L7.192|
0000c0  8505              STRH     r5,[r0,#0x28]         ;249
0000c2  8446              STRH     r6,[r0,#0x22]         ;250
0000c4  8484              STRH     r4,[r0,#0x24]         ;251
0000c6  84c2              STRH     r2,[r0,#0x26]         ;252
0000c8  e8bd03f0          POP      {r4-r9}
0000cc  4770              BX       lr
                  |L7.206|
0000ce  8685              STRH     r5,[r0,#0x34]         ;256
0000d0  8546              STRH     r6,[r0,#0x2a]         ;257
0000d2  8584              STRH     r4,[r0,#0x2c]         ;258
0000d4  85c2              STRH     r2,[r0,#0x2e]         ;259
0000d6  8607              STRH     r7,[r0,#0x30]         ;260
0000d8  f8a08032          STRH     r8,[r0,#0x32]         ;261
0000dc  e8bd03f0          POP      {r4-r9}
0000e0  4770              BX       lr
                  |L7.226|
0000e2  7082              STRB     r2,[r0,#2]            ;273
0000e4  6c00              LDR      r0,[r0,#0x40]         ;276  ; _activityConfidences
0000e6  eba00103          SUB      r1,r0,r3              ;276
0000ea  290b              CMP      r1,#0xb               ;276
0000ec  dd03              BLE      |L7.246|
0000ee  2914              CMP      r1,#0x14              ;276
0000f0  bfb8              IT       LT                    ;276
0000f2  2100              MOVLT    r1,#0                 ;276
0000f4  db06              BLT      |L7.260|
                  |L7.246|
0000f6  e8bd03f0          POP      {r4-r9}               ;276
0000fa  2209              MOVS     r2,#9                 ;276
0000fc  f103010b          ADD      r1,r3,#0xb            ;276
000100  f7ffbffe          B.W      __aeabi_memmove
                  |L7.260|
000104  185a              ADDS     r2,r3,r1              ;277
000106  7ad2              LDRB     r2,[r2,#0xb]          ;277
000108  5442              STRB     r2,[r0,r1]            ;277
00010a  1c49              ADDS     r1,r1,#1              ;277
00010c  b2c9              UXTB     r1,r1                 ;277
00010e  2909              CMP      r1,#9                 ;277
000110  d3f8              BCC      |L7.260|
000112  e8bd03f0          POP      {r4-r9}
000116  4770              BX       lr
;;;297    
                          ENDP

                  |L7.280|
                          DCD      ||.data||+0x38
                  |L7.284|
                          DCD      ||.bss||
                  |L7.288|
                          DCD      ||.data||

                          AREA ||i.IMU_receivePacket||, CODE, READONLY, ALIGN=2

                  IMU_receivePacket PROC
;;;49     
;;;50     uint8_t IMU_receivePacket(void) {
000000  4839              LDR      r0,|L8.232|
;;;51     	if (gpio_read(APU_IRQ)) return 0; //Data is not available
000002  6800              LDR      r0,[r0,#0]
000004  f4107f00          TST      r0,#0x200
000008  bf1c              ITT      NE
00000a  2000              MOVNE    r0,#0
;;;52     
;;;53     	//Old way: if (waitForSPI() == false) return (false); //Something went wrong
;;;54     
;;;55     	//Get first four bytes to find out how much data we need to read
;;;56     	gpio_reset(APU_NSS);
;;;57     
;;;58     	//Get the first four bytes, aka the packet header
;;;59     	uint8_t packetLSB = IMU_transfer(0);
;;;60     	uint8_t packetMSB = IMU_transfer(0);
;;;61     	uint8_t channelNumber = IMU_transfer(0);
;;;62     	uint8_t sequenceNumber = IMU_transfer(0); //Not sure if we need to store this or not
;;;63     
;;;64     	//Store the header info
;;;65     	shtpHeader[0] = packetLSB;
;;;66     	shtpHeader[1] = packetMSB;
;;;67     	shtpHeader[2] = channelNumber;
;;;68     	shtpHeader[3] = sequenceNumber;
;;;69     
;;;70     	//Calculate the number of data bytes in this packet
;;;71     	int16_t dataLength = ((uint16_t)packetMSB << 8 | packetLSB);
;;;72     	dataLength &= ~(1 << 15); //Clear the MSbit.
;;;73     	//This bit indicates if this package is a continuation of the last. Ignore it for now.
;;;74     	//TODO catch this as an error and exit
;;;75     	if (dataLength == 0) return 0; //Packet is empty
;;;76     	dataLength -= 4; //Remove the header bytes from the data count
;;;77     
;;;78     	//Read incoming data into the shtpData array
;;;79     	for (uint16_t dataSpot = 0; dataSpot < dataLength; dataSpot++)
;;;80     	{
;;;81     		uint8_t incoming = IMU_transfer(0xFF);
;;;82     		if (dataSpot < MAX_PACKET_SIZE)	//BNO080 can respond with upto 270 bytes, avoid overflow
;;;83     			shtpData[dataSpot] = incoming; //Store data into the shtpData array
;;;84     	}
;;;85     	gpio_set(APU_NSS);
;;;86     
;;;87     	return 1;
;;;88     }
00000c  4770              BXNE     lr
00000e  f04f7080          MOV      r0,#0x1000000         ;56
000012  4936              LDR      r1,|L8.236|
000014  6008              STR      r0,[r1,#0]            ;56
000016  4836              LDR      r0,|L8.240|
000018  2200              MOVS     r2,#0                 ;59
                  |L8.26|
00001a  6801              LDR      r1,[r0,#0]            ;59
00001c  f0110f02          TST      r1,#2                 ;59
000020  d0fb              BEQ      |L8.26|
000022  4b34              LDR      r3,|L8.244|
000024  601a              STR      r2,[r3,#0]            ;59
                  |L8.38|
000026  6801              LDR      r1,[r0,#0]            ;59
000028  f0110f01          TST      r1,#1                 ;59
00002c  d0fb              BEQ      |L8.38|
00002e  6819              LDR      r1,[r3,#0]            ;59
000030  f04f0c00          MOV      r12,#0                ;60
000034  b2c9              UXTB     r1,r1                 ;60
                  |L8.54|
000036  6802              LDR      r2,[r0,#0]            ;60
000038  f0120f02          TST      r2,#2                 ;60
00003c  d0fb              BEQ      |L8.54|
00003e  f8c3c000          STR      r12,[r3,#0]           ;60
                  |L8.66|
000042  6802              LDR      r2,[r0,#0]            ;60
000044  f0120f01          TST      r2,#1                 ;60
000048  d0fb              BEQ      |L8.66|
00004a  b430              PUSH     {r4,r5}               ;50
00004c  681a              LDR      r2,[r3,#0]            ;50
00004e  2400              MOVS     r4,#0                 ;61
000050  f0020cff          AND      r12,r2,#0xff          ;61
                  |L8.84|
000054  6802              LDR      r2,[r0,#0]            ;61
000056  f0120f02          TST      r2,#2                 ;61
00005a  d0fb              BEQ      |L8.84|
00005c  601c              STR      r4,[r3,#0]            ;61
                  |L8.94|
00005e  6802              LDR      r2,[r0,#0]            ;61
000060  f0120f01          TST      r2,#1                 ;61
000064  d0fb              BEQ      |L8.94|
000066  681a              LDR      r2,[r3,#0]            ;61
000068  2500              MOVS     r5,#0                 ;62
00006a  b2d4              UXTB     r4,r2                 ;62
                  |L8.108|
00006c  6802              LDR      r2,[r0,#0]            ;62
00006e  f0120f02          TST      r2,#2                 ;62
000072  d0fb              BEQ      |L8.108|
000074  601d              STR      r5,[r3,#0]            ;62
                  |L8.118|
000076  6802              LDR      r2,[r0,#0]            ;62
000078  f0120f01          TST      r2,#1                 ;62
00007c  d0fb              BEQ      |L8.118|
00007e  681d              LDR      r5,[r3,#0]            ;62
000080  4a1d              LDR      r2,|L8.248|
000082  7011              STRB     r1,[r2,#0]            ;65
000084  ea41210c          ORR      r1,r1,r12,LSL #8      ;71
000088  f882c001          STRB     r12,[r2,#1]           ;66
00008c  f4214100          BIC      r1,r1,#0x8000         ;72
000090  7094              STRB     r4,[r2,#2]            ;67
000092  b209              SXTH     r1,r1                 ;72
000094  70d5              STRB     r5,[r2,#3]            ;68
000096  2900              CMP      r1,#0                 ;75
000098  bf02              ITTT     EQ                    ;75
00009a  2000              MOVEQ    r0,#0                 ;75
00009c  bc30              POPEQ    {r4,r5}
00009e  4770              BXEQ     lr
0000a0  1f09              SUBS     r1,r1,#4
0000a2  fa0ffc81          SXTH     r12,r1                ;76
0000a6  2200              MOVS     r2,#0                 ;79
0000a8  f1bc0f00          CMP      r12,#0                ;79
0000ac  bfc8              IT       GT                    ;83
0000ae  4d13              LDRGT    r5,|L8.252|
0000b0  dd12              BLE      |L8.216|
                  |L8.178|
0000b2  24ff              MOVS     r4,#0xff              ;81
                  |L8.180|
0000b4  6801              LDR      r1,[r0,#0]            ;81
0000b6  f0110f02          TST      r1,#2                 ;81
0000ba  d0fb              BEQ      |L8.180|
0000bc  601c              STR      r4,[r3,#0]            ;81
                  |L8.190|
0000be  6801              LDR      r1,[r0,#0]            ;81
0000c0  f0110f01          TST      r1,#1                 ;81
0000c4  d0fb              BEQ      |L8.190|
0000c6  6819              LDR      r1,[r3,#0]            ;81
0000c8  2a80              CMP      r2,#0x80              ;82
0000ca  b2c9              UXTB     r1,r1                 ;82
0000cc  bf38              IT       CC                    ;83
0000ce  54a9              STRBCC   r1,[r5,r2]            ;83
0000d0  1c51              ADDS     r1,r2,#1              ;79
0000d2  b28a              UXTH     r2,r1                 ;79
0000d4  4562              CMP      r2,r12                ;79
0000d6  dbec              BLT      |L8.178|
                  |L8.216|
0000d8  4909              LDR      r1,|L8.256|
0000da  f44f7080          MOV      r0,#0x100             ;85
0000de  6188              STR      r0,[r1,#0x18]         ;85
0000e0  bc30              POP      {r4,r5}
0000e2  2001              MOVS     r0,#1                 ;87
0000e4  4770              BX       lr
;;;89     
                          ENDP

0000e6  0000              DCW      0x0000
                  |L8.232|
                          DCD      0x40020c10
                  |L8.236|
                          DCD      0x40020c18
                  |L8.240|
                          DCD      0x40003808
                  |L8.244|
                          DCD      0x4000380c
                  |L8.248|
                          DCD      ||.data||+0x38
                  |L8.252|
                          DCD      ||.bss||
                  |L8.256|
                          DCD      0x40020c00

                          AREA ||i.IMU_sendPacket||, CODE, READONLY, ALIGN=2

                  IMU_sendPacket PROC
;;;97     
;;;98     uint8_t IMU_sendPacket(uint8_t channelNumber, uint8_t dataLength)
000000  b430              PUSH     {r4,r5}
;;;99     {
;;;100    	uint8_t packetLength = dataLength + 4; //Add four bytes for the header
000002  1d0a              ADDS     r2,r1,#4
000004  b2d4              UXTB     r4,r2
000006  4d3a              LDR      r5,|L9.240|
000008  4a3a              LDR      r2,|L9.244|
00000a  f04f0c00          MOV      r12,#0
                  |L9.14|
00000e  682b              LDR      r3,[r5,#0]
000010  f4137f00          TST      r3,#0x200
000014  bf1c              ITT      NE
000016  2301              MOVNE    r3,#1
000018  6013              STRNE    r3,[r2,#0]  ; __delay
00001a  d00c              BEQ      |L9.54|
                  |L9.28|
00001c  6813              LDR      r3,[r2,#0]  ; __delay
00001e  2b00              CMP      r3,#0
000020  d1fc              BNE      |L9.28|
000022  f10c0301          ADD      r3,r12,#1
000026  f0030cff          AND      r12,r3,#0xff
00002a  f1bc0f7d          CMP      r12,#0x7d
00002e  d3ee              BCC      |L9.14|
;;;101    	//Wait for BNO080 to indicate it is available for communication
;;;102    	if (IMU_waitForSPI() == 0) return 0; //Something went wrong
;;;103    
;;;104    	gpio_reset(APU_NSS);
;;;105    
;;;106    	//Send the 4 byte packet header
;;;107    	IMU_transfer(packetLength & 0xFF);			 //Packet length LSB
;;;108    	IMU_transfer(packetLength >> 8);				 //Packet length MSB
;;;109    	IMU_transfer(channelNumber);					 //Channel number
;;;110    	IMU_transfer(sequenceNumber[channelNumber]++); //Send the sequence number, increments with each packet sent, different counter for each channel
;;;111    
;;;112    	//Send the user's data packet
;;;113    	for (uint8_t i = 0; i < dataLength; i++)
;;;114    	{
;;;115    		IMU_transfer(shtpData[i]);
;;;116    	}
;;;117    	gpio_set(APU_NSS);
;;;118     	return 1;
;;;119    }
000030  bc30              POP      {r4,r5}
000032  2000              MOVS     r0,#0                 ;102
000034  4770              BX       lr
                  |L9.54|
000036  4b30              LDR      r3,|L9.248|
000038  f04f7280          MOV      r2,#0x1000000         ;104
00003c  601a              STR      r2,[r3,#0]            ;104
00003e  4a2f              LDR      r2,|L9.252|
                  |L9.64|
000040  6813              LDR      r3,[r2,#0]            ;104
000042  f0130f02          TST      r3,#2                 ;104
000046  d0fb              BEQ      |L9.64|
000048  4b2d              LDR      r3,|L9.256|
00004a  601c              STR      r4,[r3,#0]            ;104
                  |L9.76|
00004c  f8d2c000          LDR      r12,[r2,#0]           ;104
000050  f01c0f01          TST      r12,#1                ;104
000054  d0fa              BEQ      |L9.76|
000056  f8d3c000          LDR      r12,[r3,#0]           ;104
00005a  2400              MOVS     r4,#0                 ;108
                  |L9.92|
00005c  f8d2c000          LDR      r12,[r2,#0]           ;108
000060  f01c0f02          TST      r12,#2                ;108
000064  d0fa              BEQ      |L9.92|
000066  601c              STR      r4,[r3,#0]            ;108
                  |L9.104|
000068  f8d2c000          LDR      r12,[r2,#0]           ;108
00006c  f01c0f01          TST      r12,#1                ;108
000070  d0fa              BEQ      |L9.104|
000072  f8d3c000          LDR      r12,[r3,#0]           ;108
000076  bf00              NOP                            ;108
                  |L9.120|
000078  f8d2c000          LDR      r12,[r2,#0]           ;108
00007c  f01c0f02          TST      r12,#2                ;108
000080  d0fa              BEQ      |L9.120|
000082  6018              STR      r0,[r3,#0]            ;108
                  |L9.132|
000084  f8d2c000          LDR      r12,[r2,#0]           ;108
000088  f01c0f01          TST      r12,#1                ;108
00008c  d0fa              BEQ      |L9.132|
00008e  f8d3c000          LDR      r12,[r3,#0]           ;108
000092  4c1c              LDR      r4,|L9.260|
000094  f814c000          LDRB     r12,[r4,r0]           ;110
000098  f10c0501          ADD      r5,r12,#1             ;110
00009c  5425              STRB     r5,[r4,r0]            ;110
                  |L9.158|
00009e  6810              LDR      r0,[r2,#0]            ;110
0000a0  f0100f02          TST      r0,#2                 ;110
0000a4  d0fb              BEQ      |L9.158|
0000a6  f8c3c000          STR      r12,[r3,#0]           ;110
                  |L9.170|
0000aa  6810              LDR      r0,[r2,#0]            ;110
0000ac  f0100f01          TST      r0,#1                 ;110
0000b0  d0fb              BEQ      |L9.170|
0000b2  6818              LDR      r0,[r3,#0]            ;110
0000b4  2000              MOVS     r0,#0                 ;113
0000b6  2900              CMP      r1,#0                 ;113
0000b8  bf88              IT       HI                    ;115
0000ba  4c13              LDRHI    r4,|L9.264|
0000bc  d911              BLS      |L9.226|
                  |L9.190|
0000be  5c25              LDRB     r5,[r4,r0]            ;115
                  |L9.192|
0000c0  f8d2c000          LDR      r12,[r2,#0]           ;115
0000c4  f01c0f02          TST      r12,#2                ;115
0000c8  d0fa              BEQ      |L9.192|
0000ca  601d              STR      r5,[r3,#0]            ;115
                  |L9.204|
0000cc  f8d2c000          LDR      r12,[r2,#0]           ;115
0000d0  f01c0f01          TST      r12,#1                ;115
0000d4  d0fa              BEQ      |L9.204|
0000d6  f8d3c000          LDR      r12,[r3,#0]           ;115
0000da  1c40              ADDS     r0,r0,#1              ;115
0000dc  b2c0              UXTB     r0,r0                 ;113
0000de  4281              CMP      r1,r0                 ;113
0000e0  d8ed              BHI      |L9.190|
                  |L9.226|
0000e2  490a              LDR      r1,|L9.268|
0000e4  f44f7080          MOV      r0,#0x100             ;117
0000e8  6188              STR      r0,[r1,#0x18]         ;117
0000ea  bc30              POP      {r4,r5}
0000ec  2001              MOVS     r0,#1                 ;118
0000ee  4770              BX       lr
;;;120    
                          ENDP

                  |L9.240|
                          DCD      0x40020c10
                  |L9.244|
                          DCD      __delay
                  |L9.248|
                          DCD      0x40020c18
                  |L9.252|
                          DCD      0x40003808
                  |L9.256|
                          DCD      0x4000380c
                  |L9.260|
                          DCD      ||.data||+0x44
                  |L9.264|
                          DCD      ||.bss||
                  |L9.268|
                          DCD      0x40020c00

                          AREA ||i.IMU_setFeatureCommand||, CODE, READONLY, ALIGN=2

                  IMU_setFeatureCommand PROC
;;;306    //Also sets the specific config word. Useful for personal activity classifier
;;;307    void IMU_setFeatureCommand(uint8_t reportID, uint16_t freq, uint32_t specificConfig)
000000  f44f737a          MOV      r3,#0x3e8
;;;308    {
;;;309    	int64_t microsBetweenReports = (int64_t)freq * 1000L;
000004  fba13c03          UMULL    r3,r12,r1,r3
000008  b430              PUSH     {r4,r5}               ;308
;;;310    
;;;311    	shtpData[0] = SHTP_REPORT_SET_FEATURE_COMMAND;	 //Set feature command. Reference page 55
00000a  4912              LDR      r1,|L10.84|
00000c  24fd              MOVS     r4,#0xfd
;;;312    	shtpData[1] = reportID;							   //Feature Report ID. 0x01 = Accelerometer, 0x05 = Rotation vector
;;;313    	shtpData[2] = 0;								   //Feature flags
;;;314    	shtpData[3] = 0;								   //Change sensitivity (LSB)
;;;315    	shtpData[4] = 0;								   //Change sensitivity (MSB)
;;;316    	shtpData[5] = (microsBetweenReports >> 0) & 0xFF;  //Report interval (LSB) in microseconds. 0x7A120 = 500ms
;;;317    	shtpData[6] = (microsBetweenReports >> 8) & 0xFF;  //Report interval
00000e  0a1d              LSRS     r5,r3,#8
000010  700c              STRB     r4,[r1,#0]            ;311
000012  7048              STRB     r0,[r1,#1]            ;312
000014  2000              MOVS     r0,#0                 ;313
000016  7088              STRB     r0,[r1,#2]            ;313
000018  70c8              STRB     r0,[r1,#3]            ;314
00001a  7108              STRB     r0,[r1,#4]            ;315
00001c  ea45640c          ORR      r4,r5,r12,LSL #24
000020  714b              STRB     r3,[r1,#5]            ;316
;;;318    	shtpData[7] = (microsBetweenReports >> 16) & 0xFF; //Report interval
000022  0c1d              LSRS     r5,r3,#16
000024  718c              STRB     r4,[r1,#6]            ;317
000026  ea45440c          ORR      r4,r5,r12,LSL #16
;;;319    	shtpData[8] = (microsBetweenReports >> 24) & 0xFF; //Report interval (MSB)
00002a  0e1b              LSRS     r3,r3,#24
00002c  71cc              STRB     r4,[r1,#7]            ;318
00002e  ea43230c          ORR      r3,r3,r12,LSL #8
000032  720b              STRB     r3,[r1,#8]
;;;320    	shtpData[9] = 0;								   //Batch Interval (LSB)
000034  7248              STRB     r0,[r1,#9]
;;;321    	shtpData[10] = 0;								   //Batch Interval
000036  7288              STRB     r0,[r1,#0xa]
;;;322    	shtpData[11] = 0;								   //Batch Interval
000038  72c8              STRB     r0,[r1,#0xb]
;;;323    	shtpData[12] = 0;								   //Batch Interval (MSB)
00003a  7308              STRB     r0,[r1,#0xc]
;;;324    	shtpData[13] = (specificConfig >> 0) & 0xFF;	   //Sensor-specific config (LSB)
00003c  734a              STRB     r2,[r1,#0xd]
;;;325    	shtpData[14] = (specificConfig >> 8) & 0xFF;	   //Sensor-specific config
00003e  0a10              LSRS     r0,r2,#8
000040  7388              STRB     r0,[r1,#0xe]
;;;326    	shtpData[15] = (specificConfig >> 16) & 0xFF;	  //Sensor-specific config
000042  0c10              LSRS     r0,r2,#16
000044  73c8              STRB     r0,[r1,#0xf]
;;;327    	shtpData[16] = (specificConfig >> 24) & 0xFF;	  //Sensor-specific config (MSB)
000046  0e10              LSRS     r0,r2,#24
000048  7408              STRB     r0,[r1,#0x10]
;;;328    
;;;329    	//Transmit packet on channel 2, 17 bytes
;;;330    	IMU_sendPacket(CHANNEL_CONTROL, 17);
00004a  2111              MOVS     r1,#0x11
00004c  bc30              POP      {r4,r5}
00004e  2002              MOVS     r0,#2
000050  f7ffbffe          B.W      IMU_sendPacket
;;;331    }
;;;332    
                          ENDP

                  |L10.84|
                          DCD      ||.bss||

                          AREA ||i.IMU_transfer||, CODE, READONLY, ALIGN=2

                  IMU_transfer PROC
;;;42     
;;;43     uint8_t IMU_transfer(uint8_t byte) {
000000  4906              LDR      r1,|L11.28|
                  |L11.2|
;;;44     	while (!(IMU_SPI->SR & SPI_SR_TXE));
000002  680a              LDR      r2,[r1,#0]
000004  f0120f02          TST      r2,#2
000008  d0fb              BEQ      |L11.2|
;;;45     	LL_SPI_TransmitData8(IMU_SPI,byte);
00000a  4a05              LDR      r2,|L11.32|
00000c  6010              STR      r0,[r2,#0]
                  |L11.14|
;;;46     	while (!(IMU_SPI->SR & SPI_SR_RXNE));
00000e  6808              LDR      r0,[r1,#0]
000010  f0100f01          TST      r0,#1
000014  d0fb              BEQ      |L11.14|
;;;47     	return LL_SPI_ReceiveData8(IMU_SPI);
000016  6810              LDR      r0,[r2,#0]
000018  b2c0              UXTB     r0,r0
;;;48     }
00001a  4770              BX       lr
;;;49     
                          ENDP

                  |L11.28|
                          DCD      0x40003808
                  |L11.32|
                          DCD      0x4000380c

                          AREA ||i.IMU_waitForSPI||, CODE, READONLY, ALIGN=2

                  IMU_waitForSPI PROC
;;;89     
;;;90     uint8_t IMU_waitForSPI(void){
000000  4b0a              LDR      r3,|L12.44|
000002  480b              LDR      r0,|L12.48|
;;;91     	for (uint8_t i=0; i<125;i++){
000004  2200              MOVS     r2,#0
                  |L12.6|
;;;92     		if (!gpio_read(APU_IRQ)) return 1;
000006  6819              LDR      r1,[r3,#0]
000008  f4117f00          TST      r1,#0x200
;;;93     		delay(1);
00000c  bf1c              ITT      NE
00000e  2101              MOVNE    r1,#1
000010  6001              STRNE    r1,[r0,#0]  ; __delay
000012  d008              BEQ      |L12.38|
                  |L12.20|
000014  6801              LDR      r1,[r0,#0]            ;92  ; __delay
000016  2900              CMP      r1,#0                 ;92
000018  d1fc              BNE      |L12.20|
00001a  1c51              ADDS     r1,r2,#1              ;91
00001c  b2ca              UXTB     r2,r1                 ;91
00001e  2a7d              CMP      r2,#0x7d              ;91
000020  d3f1              BCC      |L12.6|
;;;94     	}
;;;95     	return 0;
000022  2000              MOVS     r0,#0
;;;96     }
000024  4770              BX       lr
                  |L12.38|
000026  2001              MOVS     r0,#1                 ;92
000028  4770              BX       lr
;;;97     
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x40020c10
                  |L12.48|
                          DCD      __delay

                          AREA ||i.getAccelFlick||, CODE, READONLY, ALIGN=2

                  getAccelFlick PROC
;;;436    
;;;437    uint8_t getAccelFlick(void) {
000000  480a              LDR      r0,|L13.44|
000002  b510              PUSH     {r4,lr}
;;;438    	// float x=getAccelX(),y=getAccelY(),z=getAccelZ();
;;;439    	// float mag = square(x)+square(y)+square(z);
;;;440    	// static uint32_t last_ticks = 0;
;;;441    	// if (imu_control && mag > 110 && square(y)>65) {
;;;442    	// 	last_ticks = get_ticks();
;;;443    	// 	return 1;
;;;444    	// }
;;;445    	// if (get_ticks()-last_ticks<200) return 1;
;;;446    	// if (getAccelY())
;;;447    	if (imu_control && getRoll()<-75.0f && getRoll() > -115.0f) return 1;
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b178              CBZ      r0,|L13.40|
000008  f7fffffe          BL       getRoll
00000c  ee100a10          VMOV     r0,s0
000010  4907              LDR      r1,|L13.48|
000012  4288              CMP      r0,r1
000014  d908              BLS      |L13.40|
000016  f7fffffe          BL       getRoll
00001a  ee100a10          VMOV     r0,s0
00001e  4905              LDR      r1,|L13.52|
000020  4281              CMP      r1,r0
000022  bf84              ITT      HI
000024  2001              MOVHI    r0,#1
;;;448    	return 0;
;;;449    }
000026  bd10              POPHI    {r4,pc}
                  |L13.40|
000028  2000              MOVS     r0,#0                 ;448
00002a  bd10              POP      {r4,pc}
                          ENDP

                  |L13.44|
                          DCD      ||.data||
                  |L13.48|
                          DCD      0xc2960000
                  |L13.52|
                          DCD      0xc2e60000

                          AREA ||i.getAccelLeft||, CODE, READONLY, ALIGN=2

                  getAccelLeft PROC
;;;425    }
;;;426    uint8_t getAccelLeft(void) {
000000  4807              LDR      r0,|L14.32|
000002  b510              PUSH     {r4,lr}
;;;427        // if (imu_control && getAccelX()<-5.0f) return 1;
;;;428        if (imu_control && getPitch()>30.0f) return 1;
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b140              CBZ      r0,|L14.26|
000008  f7fffffe          BL       getPitch
00000c  ee100a10          VMOV     r0,s0
000010  4904              LDR      r1,|L14.36|
000012  4288              CMP      r0,r1
000014  bfc4              ITT      GT
000016  2001              MOVGT    r0,#1
;;;429        return 0;
;;;430    }
000018  bd10              POPGT    {r4,pc}
                  |L14.26|
00001a  2000              MOVS     r0,#0                 ;429
00001c  bd10              POP      {r4,pc}
;;;431    uint8_t getAccelRight(void) {
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      ||.data||
                  |L14.36|
                          DCD      0x41f00000

                          AREA ||i.getAccelRight||, CODE, READONLY, ALIGN=2

                  getAccelRight PROC
;;;430    }
;;;431    uint8_t getAccelRight(void) {
000000  4807              LDR      r0,|L15.32|
000002  b510              PUSH     {r4,lr}
;;;432        // if (imu_control && getAccelX()>5.0f) return 1;
;;;433        if (imu_control && getPitch()<-30.0f) return 1;
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b140              CBZ      r0,|L15.26|
000008  f7fffffe          BL       getPitch
00000c  ee100a10          VMOV     r0,s0
000010  4904              LDR      r1,|L15.36|
000012  4288              CMP      r0,r1
000014  bf84              ITT      HI
000016  2001              MOVHI    r0,#1
;;;434        return 0;
;;;435    }
000018  bd10              POPHI    {r4,pc}
                  |L15.26|
00001a  2000              MOVS     r0,#0                 ;434
00001c  bd10              POP      {r4,pc}
;;;436    
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      ||.data||
                  |L15.36|
                          DCD      0xc1f00000

                          AREA ||i.getAccelX||, CODE, READONLY, ALIGN=2

                  getAccelX PROC
;;;413    
;;;414    float getAccelX(void) {return  qToFloat(rawAccelX, accelerometer_Q1); }
000000  4802              LDR      r0,|L16.12|
000002  7981              LDRB     r1,[r0,#6]  ; accelerometer_Q1
000004  8940              LDRH     r0,[r0,#0xa]  ; rawAccelX
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
                          ENDP

                  |L16.12|
                          DCD      ||.data||

                          AREA ||i.getAccelY||, CODE, READONLY, ALIGN=2

                  getAccelY PROC
;;;414    float getAccelX(void) {return  qToFloat(rawAccelX, accelerometer_Q1); }
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
000000  4802              LDR      r0,|L17.12|
000002  7981              LDRB     r1,[r0,#6]  ; accelerometer_Q1
000004  8980              LDRH     r0,[r0,#0xc]  ; rawAccelY
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;416    float getAccelZ(void) {return qToFloat(rawAccelZ, accelerometer_Q1); }
                          ENDP

                  |L17.12|
                          DCD      ||.data||

                          AREA ||i.getAccelZ||, CODE, READONLY, ALIGN=2

                  getAccelZ PROC
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
;;;416    float getAccelZ(void) {return qToFloat(rawAccelZ, accelerometer_Q1); }
000000  4802              LDR      r0,|L18.12|
000002  7981              LDRB     r1,[r0,#6]  ; accelerometer_Q1
000004  89c0              LDRH     r0,[r0,#0xe]  ; rawAccelZ
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;417    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.getGyroX||, CODE, READONLY, ALIGN=2

                  getGyroX PROC
;;;372    //Return the gyro component
;;;373    float getGyroX(void) {return qToFloat(rawGyroX, gyro_Q1); }
000000  4802              LDR      r0,|L19.12|
000002  7a01              LDRB     r1,[r0,#8]  ; gyro_Q1
000004  8b40              LDRH     r0,[r0,#0x1a]  ; rawGyroX
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
                          ENDP

                  |L19.12|
                          DCD      ||.data||

                          AREA ||i.getGyroY||, CODE, READONLY, ALIGN=2

                  getGyroY PROC
;;;373    float getGyroX(void) {return qToFloat(rawGyroX, gyro_Q1); }
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
000000  4802              LDR      r0,|L20.12|
000002  7a01              LDRB     r1,[r0,#8]  ; gyro_Q1
000004  8b80              LDRH     r0,[r0,#0x1c]  ; rawGyroY
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;375    float getGyroZ(void) {return qToFloat(rawGyroZ, gyro_Q1); }
                          ENDP

                  |L20.12|
                          DCD      ||.data||

                          AREA ||i.getGyroZ||, CODE, READONLY, ALIGN=2

                  getGyroZ PROC
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
;;;375    float getGyroZ(void) {return qToFloat(rawGyroZ, gyro_Q1); }
000000  4802              LDR      r0,|L21.12|
000002  7a01              LDRB     r1,[r0,#8]  ; gyro_Q1
000004  8bc0              LDRH     r0,[r0,#0x1e]  ; rawGyroZ
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;376    // //Return the gyro component
                          ENDP

                  |L21.12|
                          DCD      ||.data||

                          AREA ||i.getIMUControl||, CODE, READONLY, ALIGN=2

                  getIMUControl PROC
;;;422    }
;;;423    uint8_t getIMUControl(void){ 
000000  4801              LDR      r0,|L22.8|
;;;424    	return imu_control;
000002  7800              LDRB     r0,[r0,#0]  ; imu_control
;;;425    }
000004  4770              BX       lr
;;;426    uint8_t getAccelLeft(void) {
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||.data||

                          AREA ||i.getPitch||, CODE, READONLY, ALIGN=3

                  getPitch PROC
;;;396    }
;;;397    float getPitch(void) {
000000  b510              PUSH     {r4,lr}
000002  4c3b              LDR      r4,|L23.240|
000004  ed2d8b04          VPUSH    {d8-d9}
000008  b084              SUB      sp,sp,#0x10
00000a  8e20              LDRH     r0,[r4,#0x30]  ; rawQuatReal
00000c  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00000e  b200              SXTH     r0,r0
000010  f7fffffe          BL       qToFloat
000014  eeb01a40          VMOV.F32 s2,s0
000018  8d60              LDRH     r0,[r4,#0x2a]  ; rawQuatI
;;;398    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
00001a  eef08a41          VMOV.F32 s17,s2
00001e  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
000020  b200              SXTH     r0,r0
000022  f7fffffe          BL       qToFloat
000026  eef00a40          VMOV.F32 s1,s0
00002a  8da0              LDRH     r0,[r4,#0x2c]  ; rawQuatJ
00002c  eeb08a60          VMOV.F32 s16,s1
000030  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
000032  b200              SXTH     r0,r0
000034  f7fffffe          BL       qToFloat
000038  eef00a40          VMOV.F32 s1,s0
00003c  8de0              LDRH     r0,[r4,#0x2e]  ; rawQuatK
00003e  eeb09a60          VMOV.F32 s18,s1
000042  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
000044  b200              SXTH     r0,r0
000046  f7fffffe          BL       qToFloat
;;;399    	float sinp = +2.0f * (q1* q3- q4 * q2);
00004a  ee680a89          VMUL.F32 s1,s17,s18
;;;400    	if (fabs(sinp) >= 1.0f)
;;;401    		return copysign(3.1415926535897932384626f/2.0f, sinp)*CONVERT_TO_DEGS; // use 90 degrees if out of range
00004e  ed9f9b2a          VLDR     d9,|L23.248|
000052  ee400a48          VMLS.F32 s1,s0,s16             ;399
000056  eeb00a00          VMOV.F32 s0,#2.00000000        ;399
00005a  ed9f8b29          VLDR     d8,|L23.256|
00005e  ee200a80          VMUL.F32 s0,s1,s0              ;399
000062  eef00ac0          VABS.F32 s1,s0                 ;400
000066  ee100a90          VMOV     r0,s1                 ;400
00006a  f1b05f7e          CMP      r0,#0x3f800000        ;400
00006e  db22              BLT      |L23.182|
000070  ee100a10          VMOV     r0,s0
000074  ed9f1b24          VLDR     d1,|L23.264|
000078  ed8d1b02          VSTR     d1,[sp,#8]
00007c  f7fffffe          BL       __aeabi_f2d
000080  e9cd0100          STRD     r0,r1,[sp,#0]
000084  9903              LDR      r1,[sp,#0xc]
000086  9801              LDR      r0,[sp,#4]
000088  ec532b19          VMOV     r2,r3,d9
00008c  f361001e          BFI      r0,r1,#0,#31
000090  9003              STR      r0,[sp,#0xc]
000092  ed9d0b02          VLDR     d0,[sp,#8]
000096  ec510b10          VMOV     r0,r1,d0
00009a  f7fffffe          BL       __aeabi_dmul
00009e  ec532b18          VMOV     r2,r3,d8
0000a2  f7fffffe          BL       __aeabi_ddiv
0000a6  f7fffffe          BL       __aeabi_d2f
;;;402    	else
;;;403    		return asin(sinp)*CONVERT_TO_DEGS;
;;;404    }
0000aa  b004              ADD      sp,sp,#0x10
0000ac  ee000a10          VMOV     s0,r0                 ;401
0000b0  ecbd8b04          VPOP     {d8-d9}
0000b4  bd10              POP      {r4,pc}
                  |L23.182|
0000b6  ee100a10          VMOV     r0,s0                 ;403
0000ba  f7fffffe          BL       __aeabi_f2d
0000be  ec410b10          VMOV     d0,r0,r1              ;403
0000c2  f7fffffe          BL       __hardfp_asin
0000c6  ec532b19          VMOV     r2,r3,d9              ;403
0000ca  ec510b10          VMOV     r0,r1,d0              ;403
0000ce  f7fffffe          BL       __aeabi_dmul
0000d2  ec532b18          VMOV     r2,r3,d8              ;403
0000d6  f7fffffe          BL       __aeabi_ddiv
0000da  f7fffffe          BL       __aeabi_d2f
0000de  b004              ADD      sp,sp,#0x10
0000e0  ee000a10          VMOV     s0,r0                 ;403
0000e4  ecbd8b04          VPOP     {d8-d9}
0000e8  bd10              POP      {r4,pc}
;;;405    float getYaw(void){
                          ENDP

0000ea  0000              DCW      0x0000
                          DCD      0x00000000
                  |L23.240|
                          DCD      ||.data||
                          DCD      0x00000000
                  |L23.248|
0000f8  00000000          DCFD     0x4066800000000000 ; 180
0000fc  40668000
                  |L23.256|
000100  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
000104  400921fb
                  |L23.264|
000108  60000000          DCFD     0x3ff921fb60000000 ; 1.5707963705062866
00010c  3ff921fb

                          AREA ||i.getQuatI||, CODE, READONLY, ALIGN=2

                  getQuatI PROC
;;;377    // uint8_t getGyroAccuracy(void) {return gyroAccuracy; }
;;;378    float getQuatI(void) {return qToFloat(rawQuatI, rotationVector_Q1); }
000000  4802              LDR      r0,|L24.12|
000002  7901              LDRB     r1,[r0,#4]  ; rotationVector_Q1
000004  8d40              LDRH     r0,[r0,#0x2a]  ; rawQuatI
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.getQuatJ||, CODE, READONLY, ALIGN=2

                  getQuatJ PROC
;;;378    float getQuatI(void) {return qToFloat(rawQuatI, rotationVector_Q1); }
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
000000  4802              LDR      r0,|L25.12|
000002  7901              LDRB     r1,[r0,#4]  ; rotationVector_Q1
000004  8d80              LDRH     r0,[r0,#0x2c]  ; rawQuatJ
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
                          ENDP

                  |L25.12|
                          DCD      ||.data||

                          AREA ||i.getQuatK||, CODE, READONLY, ALIGN=2

                  getQuatK PROC
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
000000  4802              LDR      r0,|L26.12|
000002  7901              LDRB     r1,[r0,#4]  ; rotationVector_Q1
000004  8dc0              LDRH     r0,[r0,#0x2e]  ; rawQuatK
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;381    float getQuatReal(void) {return qToFloat(rawQuatReal, rotationVector_Q1); }
                          ENDP

                  |L26.12|
                          DCD      ||.data||

                          AREA ||i.getQuatReal||, CODE, READONLY, ALIGN=2

                  getQuatReal PROC
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
;;;381    float getQuatReal(void) {return qToFloat(rawQuatReal, rotationVector_Q1); }
000000  4802              LDR      r0,|L27.12|
000002  7901              LDRB     r1,[r0,#4]  ; rotationVector_Q1
000004  8e00              LDRH     r0,[r0,#0x30]  ; rawQuatReal
000006  b200              SXTH     r0,r0
000008  f7ffbffe          B.W      qToFloat
;;;382    
                          ENDP

                  |L27.12|
                          DCD      ||.data||

                          AREA ||i.getRoll||, CODE, READONLY, ALIGN=3

                  getRoll PROC
;;;387    }
;;;388    float getRoll(void) {
000000  b510              PUSH     {r4,lr}
000002  4c2f              LDR      r4,|L28.192|
000004  ed2d8b04          VPUSH    {d8-d9}
000008  8e20              LDRH     r0,[r4,#0x30]  ; rawQuatReal
00000a  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00000c  b200              SXTH     r0,r0
00000e  f7fffffe          BL       qToFloat
000012  eef00a40          VMOV.F32 s1,s0
000016  8d60              LDRH     r0,[r4,#0x2a]  ; rawQuatI
;;;389    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
000018  eef08a60          VMOV.F32 s17,s1
00001c  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00001e  b200              SXTH     r0,r0
000020  f7fffffe          BL       qToFloat
000024  8da0              LDRH     r0,[r4,#0x2c]  ; rawQuatJ
000026  eeb09a40          VMOV.F32 s18,s0
00002a  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00002c  b200              SXTH     r0,r0
00002e  f7fffffe          BL       qToFloat
000032  eef00a40          VMOV.F32 s1,s0
000036  8de0              LDRH     r0,[r4,#0x2e]  ; rawQuatK
000038  eeb08a60          VMOV.F32 s16,s1
00003c  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00003e  b200              SXTH     r0,r0
000040  f7fffffe          BL       qToFloat
000044  eeb01a40          VMOV.F32 s2,s0
;;;390    	float q12_q32 = square(q1) - square(q3);
000048  eef00a68          VMOV.F32 s1,s17
;;;391    	float q22_q42 = square(q2) - square(q4);
;;;392    	float sinr_cosp = +2.0f * (q1* q2+ q3* q4);
00004c  ee280a89          VMUL.F32 s0,s17,s18
000050  ee601aa0          VMUL.F32 s3,s1,s1              ;390
000054  ee292a09          VMUL.F32 s4,s18,s18            ;391
000058  eef00a00          VMOV.F32 s1,#2.00000000
00005c  ee080a01          VMLA.F32 s0,s16,s2
000060  ee481a48          VMLS.F32 s3,s16,s16            ;390
000064  ee012a41          VMLS.F32 s4,s2,s2              ;391
000068  ee209a20          VMUL.F32 s18,s0,s1
;;;393    	float cosr_cosp = q12_q32 - q22_q42;
00006c  ee310ac2          VSUB.F32 s0,s3,s4
;;;394    	return atan2(sinr_cosp, cosr_cosp)*CONVERT_TO_DEGS;
000070  ee100a10          VMOV     r0,s0
000074  f7fffffe          BL       __aeabi_f2d
000078  ec410b18          VMOV     d8,r0,r1
00007c  ee190a10          VMOV     r0,s18
000080  f7fffffe          BL       __aeabi_f2d
000084  ec410b10          VMOV     d0,r0,r1
000088  eeb01a48          VMOV.F32 s2,s16
00008c  eef01a68          VMOV.F32 s3,s17
000090  f7fffffe          BL       __hardfp_atan2
000094  ed9f1b0c          VLDR     d1,|L28.200|
000098  ec510b10          VMOV     r0,r1,d0
00009c  ec532b11          VMOV     r2,r3,d1
0000a0  f7fffffe          BL       __aeabi_dmul
0000a4  ed9f1b0a          VLDR     d1,|L28.208|
0000a8  ec532b11          VMOV     r2,r3,d1
0000ac  f7fffffe          BL       __aeabi_ddiv
0000b0  f7fffffe          BL       __aeabi_d2f
;;;395    
;;;396    }
0000b4  ecbd8b04          VPOP     {d8-d9}
0000b8  ee000a10          VMOV     s0,r0                 ;394
0000bc  bd10              POP      {r4,pc}
;;;397    float getPitch(void) {
                          ENDP

0000be  0000              DCW      0x0000
                  |L28.192|
                          DCD      ||.data||
                          DCD      0x00000000
                  |L28.200|
0000c8  00000000          DCFD     0x4066800000000000 ; 180
0000cc  40668000
                  |L28.208|
0000d0  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
0000d4  400921fb

                          AREA ||i.getYaw||, CODE, READONLY, ALIGN=3

                  getYaw PROC
;;;404    }
;;;405    float getYaw(void){
000000  b510              PUSH     {r4,lr}
000002  4c2f              LDR      r4,|L29.192|
000004  ed2d8b04          VPUSH    {d8-d9}
000008  8e20              LDRH     r0,[r4,#0x30]  ; rawQuatReal
00000a  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00000c  b200              SXTH     r0,r0
00000e  f7fffffe          BL       qToFloat
000012  eef00a40          VMOV.F32 s1,s0
000016  8d60              LDRH     r0,[r4,#0x2a]  ; rawQuatI
;;;406    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
000018  eef08a60          VMOV.F32 s17,s1
00001c  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
00001e  b200              SXTH     r0,r0
000020  f7fffffe          BL       qToFloat
000024  eeb01a40          VMOV.F32 s2,s0
000028  8da0              LDRH     r0,[r4,#0x2c]  ; rawQuatJ
00002a  eeb09a41          VMOV.F32 s18,s2
00002e  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
000030  b200              SXTH     r0,r0
000032  f7fffffe          BL       qToFloat
000036  eef00a40          VMOV.F32 s1,s0
00003a  8de0              LDRH     r0,[r4,#0x2e]  ; rawQuatK
00003c  eeb08a60          VMOV.F32 s16,s1
000040  7921              LDRB     r1,[r4,#4]  ; rotationVector_Q1
000042  b200              SXTH     r0,r0
000044  f7fffffe          BL       qToFloat
;;;407    	float q12_q32 = square(q1) - square(q3);
;;;408    	float q22_q42 = square(q2) - square(q4);
000048  ee691a09          VMUL.F32 s3,s18,s18
00004c  eef00a68          VMOV.F32 s1,s17                ;407
000050  ee202aa0          VMUL.F32 s4,s1,s1              ;407
000054  ee401a40          VMLS.F32 s3,s0,s0
;;;409    	float siny_cosp = +2.0f * (q1* q4 + q2* q3);
000058  ee200a80          VMUL.F32 s0,s1,s0
00005c  eef00a00          VMOV.F32 s1,#2.00000000
000060  ee082a48          VMLS.F32 s4,s16,s16            ;407
000064  ee090a08          VMLA.F32 s0,s18,s16
000068  ee209a20          VMUL.F32 s18,s0,s1
;;;410    	float cosy_cosp = q12_q32 - q22_q42;  
00006c  ee320a61          VSUB.F32 s0,s4,s3
;;;411    	return atan2(siny_cosp, cosy_cosp)*CONVERT_TO_DEGS;
000070  ee100a10          VMOV     r0,s0
000074  f7fffffe          BL       __aeabi_f2d
000078  ec410b18          VMOV     d8,r0,r1
00007c  ee190a10          VMOV     r0,s18
000080  f7fffffe          BL       __aeabi_f2d
000084  ec410b10          VMOV     d0,r0,r1
000088  eeb01a48          VMOV.F32 s2,s16
00008c  eef01a68          VMOV.F32 s3,s17
000090  f7fffffe          BL       __hardfp_atan2
000094  ed9f1b0c          VLDR     d1,|L29.200|
000098  ec510b10          VMOV     r0,r1,d0
00009c  ec532b11          VMOV     r2,r3,d1
0000a0  f7fffffe          BL       __aeabi_dmul
0000a4  ed9f1b0a          VLDR     d1,|L29.208|
0000a8  ec532b11          VMOV     r2,r3,d1
0000ac  f7fffffe          BL       __aeabi_ddiv
0000b0  f7fffffe          BL       __aeabi_d2f
;;;412    }
0000b4  ecbd8b04          VPOP     {d8-d9}
0000b8  ee000a10          VMOV     s0,r0                 ;411
0000bc  bd10              POP      {r4,pc}
;;;413    
                          ENDP

0000be  0000              DCW      0x0000
                  |L29.192|
                          DCD      ||.data||
                          DCD      0x00000000
                  |L29.200|
0000c8  00000000          DCFD     0x4066800000000000 ; 180
0000cc  40668000
                  |L29.208|
0000d0  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
0000d4  400921fb

                          AREA ||i.qToFloat||, CODE, READONLY, ALIGN=3

                  qToFloat PROC
;;;297    
;;;298    float qToFloat(int16_t fixedPointValue, uint8_t qPoint)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300    	float qFloat = fixedPointValue;
000002  ee000a10          VMOV     s0,r0
000006  ed2d8b04          VPUSH    {d8-d9}               ;299
;;;301    	qFloat *= pow(2, qPoint * -1);
00000a  4248              RSBS     r0,r1,#0
00000c  eeb88ac0          VCVT.F32.S32 s16,s0                ;300
000010  f7fffffe          BL       __aeabi_i2d
000014  ec410b11          VMOV     d1,r0,r1
000018  ed9f0b0b          VLDR     d0,|L30.72|
00001c  f7fffffe          BL       __hardfp_pow
000020  eeb09a40          VMOV.F32 s18,s0
000024  eef09a60          VMOV.F32 s19,s1
000028  ee180a10          VMOV     r0,s16
00002c  f7fffffe          BL       __aeabi_f2d
000030  ec532b19          VMOV     r2,r3,d9
000034  f7fffffe          BL       __aeabi_dmul
000038  f7fffffe          BL       __aeabi_d2f
;;;302    	return (qFloat);
;;;303    }
00003c  ecbd8b04          VPOP     {d8-d9}
000040  ee000a10          VMOV     s0,r0                 ;301
000044  bd10              POP      {r4,pc}
;;;304    
                          ENDP

000046  0000              DCW      0x0000
                  |L30.72|
000048  00000000          DCFD     0x4000000000000000 ; 2
00004c  40000000

                          AREA ||i.toggleIMUControl||, CODE, READONLY, ALIGN=2

                  toggleIMUControl PROC
;;;418    static uint8_t imu_control = 0;
;;;419    uint8_t toggleIMUControl(void){
000000  4903              LDR      r1,|L31.16|
;;;420    	imu_control = !imu_control;
000002  7808              LDRB     r0,[r1,#0]  ; imu_control
000004  2800              CMP      r0,#0
000006  bf0c              ITE      EQ
000008  2001              MOVEQ    r0,#1
00000a  2000              MOVNE    r0,#0
00000c  7008              STRB     r0,[r1,#0]
;;;421    	return imu_control;
;;;422    }
00000e  4770              BX       lr
;;;423    uint8_t getIMUControl(void){ 
                          ENDP

                  |L31.16|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  shtpData
                          %        128

                          AREA ||area_number.34||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.bss||
                  metaData
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  imu_control
000000  00                DCB      0x00
                  stabilityClassifier
000001  00                DCB      0x00
                  activityClassifier
000002  00                DCB      0x00
                  calibrationStatus
000003  00                DCB      0x00
                  rotationVector_Q1
000004  000e              DCW      0x000e
                  accelerometer_Q1
000006  0008              DCW      0x0008
                  gyro_Q1
000008  0009              DCW      0x0009
                  rawAccelX
00000a  0000              DCB      0x00,0x00
                  rawAccelY
00000c  0000              DCB      0x00,0x00
                  rawAccelZ
00000e  0000              DCB      0x00,0x00
                  accelAccuracy
000010  0000              DCB      0x00,0x00
                  rawLinAccelX
000012  0000              DCB      0x00,0x00
                  rawLinAccelY
000014  0000              DCB      0x00,0x00
                  rawLinAccelZ
000016  0000              DCB      0x00,0x00
                  accelLinAccuracy
000018  0000              DCB      0x00,0x00
                  rawGyroX
00001a  0000              DCB      0x00,0x00
                  rawGyroY
00001c  0000              DCB      0x00,0x00
                  rawGyroZ
00001e  0000              DCB      0x00,0x00
                  gyroAccuracy
000020  0000              DCB      0x00,0x00
                  rawMagX
000022  0000              DCB      0x00,0x00
                  rawMagY
000024  0000              DCB      0x00,0x00
                  rawMagZ
000026  0000              DCB      0x00,0x00
                  magAccuracy
000028  0000              DCB      0x00,0x00
                  rawQuatI
00002a  0000              DCB      0x00,0x00
                  rawQuatJ
00002c  0000              DCB      0x00,0x00
                  rawQuatK
00002e  0000              DCB      0x00,0x00
                  rawQuatReal
000030  0000              DCB      0x00,0x00
                  rawQuatRadianAccuracy
000032  0000              DCB      0x00,0x00
                  quatAccuracy
000034  0000              DCB      0x00,0x00
                  stepCount
000036  0000              DCB      0x00,0x00
                  shtpHeader
                          DCD      0x00000000
                  timeStamp
                          DCD      0x00000000
                  _activityConfidences
                          DCD      0x00000000
                  sequenceNumber
000044  00000000          DCB      0x00,0x00,0x00,0x00
000048  0000              DCB      0x00,0x00

                          AREA ||area_number.37||, DATA, ALIGN=0

                          EXPORTAS ||area_number.37||, ||.data||
                  commandSequenceNumber
000000  00                DCB      0x00

                          AREA ||area_number.38||, DATA, ALIGN=1

                          EXPORTAS ||area_number.38||, ||.data||
                  linear_accelerometer_Q1
000000  0008              DCW      0x0008

                          AREA ||area_number.39||, DATA, ALIGN=1

                          EXPORTAS ||area_number.39||, ||.data||
                  magnetometer_Q1
000000  0004              DCW      0x0004

;*** Start embedded assembler ***

#line 1 "..\\Src\\imu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___5_imu_c_60885fe7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____REVSH|
#line 402
|__asm___5_imu_c_60885fe7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____RRX|
#line 587
|__asm___5_imu_c_60885fe7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
